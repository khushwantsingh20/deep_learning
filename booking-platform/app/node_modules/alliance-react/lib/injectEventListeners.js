'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = injectEventListeners;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __DEV__ = process.env.NODE_ENV !== 'production'; // eslint-disable-line

var instanceCount = 0;
function injectEventListeners() {
    return function (WrappedComponent) {
        var _class, _temp;

        if (++instanceCount > 1) {
            var msg = "You should only have one component wrapped with 'injectEventListeners'";
            // Don't throw error as it will stop hot-loading on component working
            if (module.hot) {
                console.warn( // eslint-disable-line no-console
                msg + '. If you hot-loaded the component you can ignore this.');
            } else {
                console.error(msg); // eslint-disable-line no-console
            }
        }

        var knownEvents = ('keyDown keyPress keyUp click doubleClick ' + 'touchCancel touchEnd touchMove touchStart' + 'click contextMenu doubleClick drag dragEnd ' + 'dragEnter dragExit dragLeave dragOver ' + 'dragStart drop mouseDown mouseEnter ' + 'mouseLeave mouseMove mouseOut mouseOver ' + 'mouseUp').split(' ');
        var knownEventsLower = knownEvents.map(function (e) {
            return e.toLowerCase();
        });

        /*
         * Root app component
         *
         * Supports adding event listeners via context for things like click-to-close
         * that you would normally have to add on body. The advantage of doing it here
         * is that you can use the React event system still. @see RootEventListener
         * NOTE: This may not do what you expect for some events. eg. keyDown may
         * not fire at all depending on where focus currently is on app. If you want
         * to capture all key downs you will still need to add it to document direclty
         */
        var App = (_temp = _class = function (_React$Component) {
            _inherits(App, _React$Component);

            /**
             * Constructor
             * @param  {Object} props
             */
            function App(props) {
                _classCallCheck(this, App);

                var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(App).call(this, props));

                _this.addRootEventListener = _this.addRootEventListener.bind(_this);
                _this.state = {
                    eventListeners: {},
                    eventCallbacks: {},
                    eventCallbackIds: {}
                };
                return _this;
            }

            /**
             * Expose addRootEventListener to context for use in components such as
             * RootEventListener
             * @return {Object}
             */


            _createClass(App, [{
                key: 'getChildContext',
                value: function getChildContext() {
                    return {
                        addRootEventListener: this.addRootEventListener
                    };
                }

                /**
                 * Add an event listener to this root element
                 * @param {string}   eventName event name (without the 'on', eg. 'click')
                 * @param {Function} cb    function to call when event triggered
                 * @return {Function}      function to remove this listener
                 */

            }, {
                key: 'addRootEventListener',
                value: function addRootEventListener(eventName, cb) {
                    var _this2 = this;

                    if (knownEvents.indexOf(eventName) === -1) {
                        var i = knownEventsLower.indexOf(eventName.toLowerCase());
                        var extra = void 0;
                        if (i !== -1) {
                            extra = ' Did you mean \'' + knownEvents[i] + '\'?';
                        }
                        console.warn( // eslint-disable-line no-console
                        'You specified event \'' + eventName + '\' which may not be valid. ' + extra);
                    }
                    if (__DEV__) {
                        if (['keyDown', 'keyUp', 'keyPress'].indexOf(eventName) !== -1) {
                            var _msg = 'You have bound a keyboard event %c' + eventName + '%c. Note ' + 'that these events will only fire if you have focus on a form ' + 'element that fires these events. If you need to listen for all ' + 'events you must attach a handler using %cwindow.addEventListener%c ' + 'instead or add tabIndex to your container.';
                            console.warn( // eslint-disable-line no-console
                            _msg, 'font-weight: bold', 'font-weight: normal', 'font-weight: bold', 'font-weight: normal');
                        }
                    }
                    var _state = this.state;
                    var eventCallbacks = _state.eventCallbacks;
                    var eventCallbackIds = _state.eventCallbackIds;
                    var eventListeners = _state.eventListeners;

                    if (!eventCallbacks[eventName]) {
                        eventCallbacks[eventName] = {};
                        eventCallbackIds[eventName] = 0;
                        eventListeners[eventName] = function () {
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }

                            Object.keys(eventCallbacks[eventName]).forEach(function (i) {
                                var _eventCallbacks$event;

                                (_eventCallbacks$event = eventCallbacks[eventName])[i].apply(_eventCallbacks$event, args);
                            });
                        };
                    }
                    var id = eventCallbackIds[eventName];
                    eventCallbacks[eventName][id] = cb;
                    eventCallbackIds[eventName]++;

                    this.setState({ eventCallbacks: eventCallbacks, eventCallbackIds: eventCallbackIds, eventListeners: eventListeners });
                    return function () {
                        var nextEventCallbacks = _this2.state.eventCallbacks;

                        delete nextEventCallbacks[eventName][id];
                        _this2.setState({ eventCallbacks: nextEventCallbacks });
                    };
                }

                /**
                 * Render the app and add any event listeners that may have been added using
                 * addRootEventListener
                 * @return {ReactElement}
                 */

            }, {
                key: 'render',
                value: function render() {
                    var _this3 = this;

                    var props = {};
                    Object.keys(this.state.eventListeners).forEach(function (eventName) {
                        if (_this3.state.eventListeners.hasOwnProperty(eventName)) {
                            var e = 'on' + (eventName[0].toUpperCase() + eventName.substr(1));
                            props[e] = _this3.state.eventListeners[eventName];
                        }
                    });
                    // TODO: Don't do this - just bind some fixed methods
                    // and call relevant listeners if they exist. This forces a rerender
                    // everytime you use RootEventListener which makes it difficult (or
                    // impossible to update handlers on props changes)
                    return _react2.default.createElement(WrappedComponent, _extends({}, this.props, { eventListeners: props }));
                }
            }]);

            return App;
        }(_react2.default.Component), _class.childContextTypes = {
            addRootEventListener: _propTypes2.default.func
        }, _temp);


        return App;
    };
}