import React from 'react';
import PropTypes from 'prop-types';

const __DEV__ = process.env.NODE_ENV !== 'production'; // eslint-disable-line

let instanceCount = 0;
export default function injectEventListeners() {
    return WrappedComponent => {
        if (++instanceCount > 1) {
            const msg = "You should only have one component wrapped with 'injectEventListeners'";
            // Don't throw error as it will stop hot-loading on component working
            if (module.hot) {
                console.warn(// eslint-disable-line no-console
                    `${msg}. If you hot-loaded the component you can ignore this.`);
            } else {
                console.error(msg); // eslint-disable-line no-console
            }
        }

        const knownEvents = ('keyDown keyPress keyUp click doubleClick ' +
                             'touchCancel touchEnd touchMove touchStart' +
                             'click contextMenu doubleClick drag dragEnd ' +
                             'dragEnter dragExit dragLeave dragOver ' +
                             'dragStart drop mouseDown mouseEnter ' +
                             'mouseLeave mouseMove mouseOut mouseOver ' +
                             'mouseUp').split(' ');
        const knownEventsLower = knownEvents.map(e => e.toLowerCase());

        /*
         * Root app component
         *
         * Supports adding event listeners via context for things like click-to-close
         * that you would normally have to add on body. The advantage of doing it here
         * is that you can use the React event system still. @see RootEventListener
         * NOTE: This may not do what you expect for some events. eg. keyDown may
         * not fire at all depending on where focus currently is on app. If you want
         * to capture all key downs you will still need to add it to document direclty
         */
        class App extends React.Component {

            static childContextTypes = {
                addRootEventListener: PropTypes.func,
            };

            /**
             * Constructor
             * @param  {Object} props
             */
            constructor(props) {
                super(props);
                this.addRootEventListener = this.addRootEventListener.bind(this);
                this.state = {
                    eventListeners: {},
                    eventCallbacks: {},
                    eventCallbackIds: {},
                };
            }

            /**
             * Expose addRootEventListener to context for use in components such as
             * RootEventListener
             * @return {Object}
             */
            getChildContext() {
                return {
                    addRootEventListener: this.addRootEventListener,
                };
            }

            /**
             * Add an event listener to this root element
             * @param {string}   eventName event name (without the 'on', eg. 'click')
             * @param {Function} cb    function to call when event triggered
             * @return {Function}      function to remove this listener
             */
            addRootEventListener(eventName, cb) {
                if (knownEvents.indexOf(eventName) === -1) {
                    const i = knownEventsLower.indexOf(eventName.toLowerCase());
                    let extra;
                    if (i !== -1) {
                        extra = ` Did you mean '${knownEvents[i]}'?`;
                    }
                    console.warn(// eslint-disable-line no-console
                        `You specified event '${eventName}' which may not be valid. ${extra}`);
                }
                if (__DEV__) {
                    if (['keyDown', 'keyUp', 'keyPress'].indexOf(eventName) !== -1) {
                        const msg = `You have bound a keyboard event %c${eventName}%c. Note ` +
                            'that these events will only fire if you have focus on a form ' +
                            'element that fires these events. If you need to listen for all ' +
                            'events you must attach a handler using %cwindow.addEventListener%c ' +
                            'instead or add tabIndex to your container.';
                        console.warn(// eslint-disable-line no-console
                            msg, 'font-weight: bold', 'font-weight: normal',
                            'font-weight: bold', 'font-weight: normal');
                    }
                }
                const { eventCallbacks, eventCallbackIds, eventListeners } = this.state;
                if (!eventCallbacks[eventName]) {
                    eventCallbacks[eventName] = {};
                    eventCallbackIds[eventName] = 0;
                    eventListeners[eventName] = (...args) => {
                        Object.keys(eventCallbacks[eventName]).forEach(i => {
                            eventCallbacks[eventName][i](...args);
                        });
                    };
                }
                const id = eventCallbackIds[eventName];
                eventCallbacks[eventName][id] = cb;
                eventCallbackIds[eventName]++;

                this.setState({ eventCallbacks, eventCallbackIds, eventListeners });
                return () => {
                    const { eventCallbacks: nextEventCallbacks } = this.state;
                    delete nextEventCallbacks[eventName][id];
                    this.setState({ eventCallbacks: nextEventCallbacks });
                };
            }

            /**
             * Render the app and add any event listeners that may have been added using
             * addRootEventListener
             * @return {ReactElement}
             */
            render() {
                const props = {};
                Object.keys(this.state.eventListeners).forEach(eventName => {
                    if (this.state.eventListeners.hasOwnProperty(eventName)) {
                        const e = `on${eventName[0].toUpperCase() + eventName.substr(1)}`;
                        props[e] = this.state.eventListeners[eventName];
                    }
                });
                // TODO: Don't do this - just bind some fixed methods
                // and call relevant listeners if they exist. This forces a rerender
                // everytime you use RootEventListener which makes it difficult (or
                // impossible to update handlers on props changes)
                return (
                    <WrappedComponent {...this.props} eventListeners={props} />
                );
            }
        }

        return App;
    };
}
