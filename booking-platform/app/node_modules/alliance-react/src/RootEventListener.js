import React, { Children } from 'react';
import PropTypes from 'prop-types';
import shallowEqual from './shallowEqual';
import invariant from 'invariant';

function getEventsFromProps(props) {
    const eventProps = {};
    Object.keys(props).forEach(key => {
        if (key.substr(0, 2) === 'on' && typeof props[key] == 'function') {
            eventProps[key] = props[key];
        }
    });
    return eventProps;
}

export default class RootEventListener extends React.Component {

    static contextTypes = {
        addRootEventListener: PropTypes.func.isRequired,
    };

    static propTypes = {
        children: PropTypes.node.isRequired,
    };

    componentWillMount() {
        this.processEventProps(getEventsFromProps(this.props));
    }

    componentWillReceiveProps(nextProps) {
        const nextPropsEvents = getEventsFromProps(nextProps);
        if (!shallowEqual(nextPropsEvents, getEventsFromProps(this.props))) {
            this.processEventProps(nextProps);
        }
    }

    componentWillUnmount() {
        this.unsubscribeFns.map(unsubscribe => unsubscribe());
    }


    processEventProps(props) {
        if (this.detectRenderLoop()) return;

        this.unsubscribeFns.map(unsubscribe => unsubscribe());
        const { addRootEventListener } = this.context;
        let count = 0;
        Object.keys(props).forEach(key => {
            if (key.substr(0, 2) === 'on') {
                count++;
                const eventName = key.substr(2, 1).toLowerCase() + key.substr(3);
                this.unsubscribeFns.push(addRootEventListener(eventName, props[key]));
            }
        });
        invariant(count !== 0,
            'You are using RootEventListener but have specified no' +
            "props with 'on' prefix (eg. onClick). Have you made a " +
            'typo in a prop? No event listeners have been added.');
    }

    unsubscribeFns = [];

    // It's very possible to get into an infinite loop if you pass props
    // that always fail equality checks (eg. arrow functions). Detect
    // this and log an error.
    lastPropUpdate = null;
    propUpdateCount = null;
    disableUpdates = false;

    detectRenderLoop() {
        if (this.disableUpdates) return true;

        const now = (new Date()).getTime();
        if (this.lastPropUpdate != null) {
            if ((now - this.lastPropUpdate) < 100) {
                this.propUpdateCount++;
            }
            if (this.propUpdateCount > 10) {
                this.disableUpdates = true;
                console.error(// eslint-disable-line no-console
                    'Render loop detected. If you are passing in a arrow function ' +
                    'or binding a function when you assign props you  should cache ' +
                    'it instead. No further changes to props will be made.'
                );
            }
        }
        this.lastPropUpdate = now;
        return this.disableUpdates;
    }

    render() {
        return Children.only(this.props.children);
    }

}
