import React, { Component } from 'react';

// Tracks each component that is using hoverState
const mountedInstances = [];
// Tracks each instance that is currently hovered
const hoverStack = [];

/**
 * When a change occurs we want to force each component to update to check new hover state
 */
function emitChange() {
    for (const instance of mountedInstances) {
        instance.forceUpdate();
    }
}

/**
 * Track hover state for a component. Passes an 'isHovered' prop to the component.
 * @param {Object} config
 * @param {Boolean} config.shallow only consider component to be hovered if no nested
 * components are hovered
 * @returns {Function}
 */
export default function hoverState(config = {}) {
    const { shallow = false } = config;
    return DecoratedComponent => {
        class WrappedComponent extends Component {

            constructor(props) {
                super(props);
                this.onMouseEnter = this.onMouseEnter.bind(this);
                this.onMouseOrDragLeave = this.onMouseOrDragLeave.bind(this);
                this.removeHover = this.removeHover.bind(this);
                this.state = { hovered: false };
            }

            /**
             * When component mounts we need to track it. This is so when hover occurs
             * (on any instance) we can notify this component.
             */
            componentWillMount() {
                mountedInstances.push(this);
                emitChange();
            }

            /**
             * When componentn unmounts we want to remove it from our tracking and force
             * a change on all existing elements incase the hover state has changed
             */
            componentWillUnmount() {
                const index = mountedInstances.indexOf(this);
                mountedInstances.splice(index, 1);
                this.removeHover();
                emitChange();
            }

            /**
             * On mouse enter we mark this instance as hovered and track it in the global
             * hoverStack list. We notify all instances so they can re-render with correct
             * isHovered value.
             */
            onMouseEnter() {
                this.setState({ hovered: true });
                hoverStack.push(this);
                emitChange();
            }

            /**
             * On mouse leave we need to remove hover state and force re-render of all instances.
             * We also handle onDragLeave here as mouse leave doesn't get fired if you
             * use HTML5 drag-n-drop on it so hovered won't be toggled even though mouse has
             * left the element.
             */
            onMouseOrDragLeave() {
                // dragLeave events seem to propogate - so even if you are still within
                // a container it could have a dragLeave event fired from a child element
                // Not much we can do about this I don't think and is an edge case (only
                // came up in test cases)
                this.setState({ hovered: false });
                this.removeHover();
                emitChange();
            }

            setRef = ref => { this.ref = ref; };

            removeHover() {
                const index = hoverStack.indexOf(this);
                if (index !== -1) {
                    hoverStack.splice(index, 1);
                }
            }

            render() {
                const lastOver = hoverStack.length && hoverStack[hoverStack.length - 1];
                const isOver = this.state.hovered && (!shallow || lastOver === this);
                return (
                    <div
                        ref={this.setRef}
                        onMouseEnter={this.onMouseEnter}
                        onMouseLeave={this.onMouseOrDragLeave}
                        onDragLeave={this.onMouseOrDragLeave}
                    >
                        <DecoratedComponent isHovered={isOver} {...this.props} />
                    </div>
                );
            }
        }
        return WrappedComponent;
    };
}
