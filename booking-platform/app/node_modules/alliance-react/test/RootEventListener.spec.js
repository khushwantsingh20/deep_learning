import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { mount } from 'enzyme';
import sinon from 'sinon';
import TestUtils from 'react-addons-test-utils';
import injectEventListeners from '../src/injectEventListeners';
import RootEventListener from '../src/RootEventListener';

describe('RootEventListener', () => {
    class ClickComponent extends Component {

        stopProp = e => e.stopPropagation();

        render() {
            return (
                <div id="root">
                    <RootEventListener {...this.props}>
                        <div>
                            <button id="button">Click me</button>
                            <button id="button2" onClick={this.stopProp}>
                                Click me
                            </button>
                        </div>
                    </RootEventListener>
                </div>
            );
        }
    }

    class RootComponent extends Component {

        static propTypes = {
            eventListeners: PropTypes.object,
        };

        render() {
            /* eslint-disable */
            const { eventListeners, ...otherProps } = this.props;
            /* eslint-enable */
            return (
                <div {...eventListeners} >
                    <ClickComponent {...otherProps} />
                </div>
            );
        }

    }

    const WrappedRoot = injectEventListeners()(RootComponent);

    it('should handle onClick events', () => {
        const click1 = sinon.spy();
        const container = mount(<WrappedRoot onClick={click1} />);
        container.find('#button').simulate('click');
        expect(click1.callCount).toEqual(1);
        container.find('#button').simulate('click');
        expect(click1.callCount).toEqual(2);
        container.find('#root').simulate('click');
        expect(click1.callCount).toEqual(3);
        container.find('#button2').simulate('click');
        expect(click1.callCount).toEqual(3);
        container.find('#button2').simulate('click');
        expect(click1.callCount).toEqual(3);
        container.find('#root').simulate('click');
        expect(click1.callCount).toEqual(4);
        container.find('#root').simulate('click');
        expect(click1.callCount).toEqual(5);
    });

    it('should remove events if prop changes', () => {
        const click1 = sinon.spy();
        const click2 = sinon.spy();
        const cont = mount(<WrappedRoot onClick={click1} />);
        cont.find('#button').simulate('click');
        expect(click1.callCount).toEqual(1);
        expect(click2.callCount).toEqual(0);
        cont.find('#button').simulate('click');
        expect(click1.callCount).toEqual(2);
        expect(click2.callCount).toEqual(0);
        const cont2 = mount(<WrappedRoot onClick={click2} />);
        cont2.find('#root').simulate('click');
        expect(click2.callCount).toEqual(1);
        expect(click1.callCount).toEqual(2);
    });

    it('should optimise for identical event props coming in', () => {
        const click1 = sinon.spy();
        const click2 = sinon.spy();
        const cont = mount(<WrappedRoot onClick={() => {}} />);
        const comp = TestUtils.findRenderedComponentWithType(cont.instance(), RootEventListener);
        cont.update();
        const processEventPropsSpy = sinon.spy();
        comp.processEventProps = processEventPropsSpy;
        cont.setProps({ onClick: click2 }).update();
        expect(processEventPropsSpy.callCount).toEqual(1);
        cont.setProps({ onClick: click2 }).update();
        expect(processEventPropsSpy.callCount).toEqual(1);
        cont.setProps({ notAnEvent: 1, onClick: click2 }).update();
        expect(processEventPropsSpy.callCount).toEqual(1);
        cont.setProps({ onNotAnEvent: 1, onClick: click2 }).update();
        expect(processEventPropsSpy.callCount).toEqual(1);
        cont.setProps({ onSomething: () => {}, onClick: click2 }).update();
        expect(processEventPropsSpy.callCount).toEqual(2);
        cont.setProps({ onSomething: () => {}, onClick: click2 }).update();
       // Arrow function causes to call
        expect(processEventPropsSpy.callCount).toEqual(3);
        cont.setProps({ onClick: click2, onSomething: null }).update();
        expect(processEventPropsSpy.callCount).toEqual(4);
        cont.setProps({ onClick: click1 }).update();
        expect(processEventPropsSpy.callCount).toEqual(5);
        cont.setProps({ onClick: click1 }).update();
        expect(processEventPropsSpy.callCount).toEqual(5);
    });
});
