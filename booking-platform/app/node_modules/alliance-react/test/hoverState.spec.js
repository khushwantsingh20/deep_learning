import { mount } from 'enzyme';
import React from 'react';
import TestUtils from 'react-addons-test-utils';
import hoverState from '../src/hoverState';

describe('hoverState', () => {
    class TestComponent extends React.Component {
        render() {
            return <div className="innerDiv">test</div>;
        }
    }

    const WrappedComponent = hoverState()(TestComponent);

    class NestingComponent extends React.Component {
        render() {
            return (
                <div>
                    <div>test</div>
                    <div id="inner">
                        <WrappedComponent />
                    </div>
                </div>
            );
        }
    }

    const WrappedNestingComponent = hoverState()(NestingComponent);
    const WrappedNestingComponentShallow = hoverState({ shallow: true })(NestingComponent);

    it('should hover', () => {
        const component = mount(<WrappedComponent />);
        const testComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), TestComponent);
        expect(testComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(true);
        component.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
    });

    it('should hover nested', () => {
        const component = mount(<WrappedNestingComponent />);
        const innerComponent = component.find('#inner').children().first();
        const testComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), TestComponent);
        const nestingComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), NestingComponent);
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        innerComponent.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(true);
        expect(nestingComponent.props.isHovered).toEqual(true);
        innerComponent.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
    });

    it('should hover nested (shallow)', () => {
        const component = mount(<WrappedNestingComponentShallow />);
        const innerComponent = component.find('#inner').children().first();
        const testComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), TestComponent);
        const nestingComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), NestingComponent);
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        innerComponent.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(true);
        expect(nestingComponent.props.isHovered).toEqual(false);
        innerComponent.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
    });

    it('should handle drag events', () => {
        // When dragging mouse leave doesn't fire - we handle this as a special case
        const component = mount(<WrappedNestingComponentShallow />);
        const innerComponent = component.find('#inner').children().first();
        const testComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), TestComponent);
        const nestingComponent = TestUtils.findRenderedComponentWithType(
            component.instance(), NestingComponent);
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('dragLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
        component.simulate('mouseEnter');
        innerComponent.simulate('mouseEnter');
        expect(testComponent.props.isHovered).toEqual(true);
        expect(nestingComponent.props.isHovered).toEqual(false);
        // Doing a dragLeave here will propogate up and so will be handled on
        // both components. This behaviour is different to mouseLeave. See
        // onMouseOrDragLeave in hoverState.js for details - we aren't handling
        // this for now.
        // innerComponent.simulate('dragLeave');
        innerComponent.simulate('mouseLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(true);
        component.simulate('dragLeave');
        expect(testComponent.props.isHovered).toEqual(false);
        expect(nestingComponent.props.isHovered).toEqual(false);
    });
});
