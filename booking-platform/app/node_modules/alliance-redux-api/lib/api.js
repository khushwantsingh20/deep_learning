"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApi = configureApi;
exports.setBaseApiUrl = setBaseApiUrl;
exports.toQueryString = toQueryString;
exports.isApiConfigured = isApiConfigured;
exports.getApiConfigFor = getApiConfigFor;
exports.buildHeaders = buildHeaders;
exports.callApi = callApi;
exports.get = get;
exports.post = post;
exports.patch = patch;
exports.del = del;
exports.CLIENT_UID = exports.API_CALL_AUTH_REQUIRED = exports.API_CALL_RESULT = exports.API_CALL_REQUEST = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _uid = _interopRequireDefault(require("./uid"));

var _map = _interopRequireDefault(require("lodash/map"));

var _trim = _interopRequireDefault(require("lodash/trim"));

var _invariant = _interopRequireDefault(require("invariant"));

var _startsWith = _interopRequireDefault(require("lodash/startsWith"));

var _identity = _interopRequireDefault(require("lodash/identity"));

var _reduxApiMiddleware = require("redux-api-middleware");

var API_CALL_REQUEST = '@alliance-redux-api/apiCallRequest';
exports.API_CALL_REQUEST = API_CALL_REQUEST;
var API_CALL_RESULT = '@alliance-redux-api/apiCallResult';
exports.API_CALL_RESULT = API_CALL_RESULT;
var API_CALL_AUTH_REQUIRED = '@alliance-redux-api/authRequired';
exports.API_CALL_AUTH_REQUIRED = API_CALL_AUTH_REQUIRED;

var CLIENT_UID = _uid["default"].v4();

exports.CLIENT_UID = CLIENT_UID;
var apiSettings = {};
var defaultApi = null;
var defaultConfiguration = {
  // True for historical reason (exists only for historical reasons - could be
  // done as part of headers param below)
  includeCsrfTokenHeader: true,
  appendSlash: true,
  // Set this to true to avoid sending a API_CALL_AUTH_REQUIRED action on
  // a 401
  bypassAuthRetry: false,
  // Only one configuration can be default
  isDefault: true,
  credentials: 'include',
  headers: {},
  includeClientIdHeader: false
};

function configureApi(baseUrl, config) {
  if (typeof baseUrl != 'string') {
    throw new Error('configureApi() has changed signature to configureApi(baseUrl: string, config:Object)');
  }

  apiSettings[baseUrl] = (0, _objectSpread2["default"])({}, defaultConfiguration, config, {
    baseUrl: baseUrl
  });

  if (apiSettings[baseUrl].isDefault && defaultApi) {
    throw new Error("Default API already set to ".concat(defaultApi, "; you can only have one default. Pass { isDefault: false, /* other options */ } to configureApi for ").concat(baseUrl));
  }

  if (apiSettings[baseUrl].isDefault) {
    defaultApi = baseUrl;
  }
}

function setBaseApiUrl() {
  throw new Error('Please use configureApi instead of setBaseApiUrl');
}

function toQueryString(params) {
  var convertValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _identity["default"];
  return (0, _map["default"])(params, function (value, key) {
    if (Array.isArray(value)) {
      var values = value.map(function (v) {
        return encodeURIComponent(convertValue(v));
      }).join("&".concat(encodeURIComponent(key), "="));
      return "".concat(encodeURIComponent(key), "=").concat(values);
    }

    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(convertValue(value)));
  }).join('&');
}

function buildApiUrl(endPoint) {
  var apiConfig = getApiConfigFor(endPoint);

  var _endPoint$split = endPoint.split('?'),
      _endPoint$split2 = (0, _slicedToArray2["default"])(_endPoint$split, 2),
      uri = _endPoint$split2[0],
      query = _endPoint$split2[1];

  var url = "".concat(apiConfig.baseUrl).concat((0, _trim["default"])(uri, '/'));

  if (apiConfig.appendSlash) {
    url = "".concat(url, "/");
  }

  if (query) {
    url += "?".concat(query);
  }

  return url;
}

function isAbsUrl(maybeUrl) {
  return (0, _startsWith["default"])(maybeUrl, 'http://') || (0, _startsWith["default"])(maybeUrl, 'https://');
}
/**
 * Helper to get django CSRF token. Needs to be called on every request as
 * the token can change (ie. after you login it will change)
 * @return {String} token
 */


function getCsrfToken() {
  var cookieMatch = document.cookie.match(/csrftoken=(.*?)(?:$|;)/);

  if (cookieMatch && cookieMatch.length > 1) {
    return cookieMatch[1];
  }

  console.error( // eslint-disable-line
  'CSRF cookie not set. Authentication can not take place. Please contact a developer.');
  return 'COOKIE NOT FOUND';
}

function isApiConfigured(baseUrl) {
  if (!isAbsUrl(baseUrl)) {
    return !!apiSettings[defaultApi];
  }

  var matches = Object.keys(apiSettings).filter(function (key) {
    return baseUrl.startsWith(key);
  });
  return matches.length > 0;
}

function getApiConfigFor(url) {
  if (!isAbsUrl(url)) {
    var config = apiSettings[defaultApi];
    (0, _invariant["default"])(config, "Default API config not set - you must set this with 'configureApi(baseUrl, { isDefault: true })' in your app entry file before using relative API urls");
    return config;
  } else {
    var matches = Object.keys(apiSettings).filter(function (key) {
      return url.startsWith(key);
    });

    if (matches.length > 1) {
      console.warn("Multiple configurations found for ".concat(url, ", using ").concat(matches[0]));
    }

    if (matches.length > 0) {
      return apiSettings[matches[0]];
    }

    return defaultConfiguration;
  }
}

function buildHeaders(apiConfig) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var finalHeaders = (0, _objectSpread2["default"])({}, apiConfig.headers, {
    'Content-Type': 'application/json',
    Accept: 'application/json'
  }, extraHeaders);

  if (apiConfig.includeClientIdHeader) {
    finalHeaders['X-Client-UID'] = CLIENT_UID;
  }

  if (apiConfig.includeCsrfTokenHeader) {
    finalHeaders['X-CSRFToken'] = getCsrfToken();
  }

  return finalHeaders;
}
/**
 * Call an endpoint. See @post() and @get() below for method helpers.
 *
 * If the request itself fails (eg. you provide an invalid actionType) then
 * only the request action type will be dispatched and it will be marked as
 * an error.
 *
 * Otherwise requestType will be dispatched followed by either successType
 * or failureType depending on status code response. By default these action
 * types are the same - you can differentiate in reducer if 'error' key is
 * set to true.
 *
 * @param {String} endpoint can be relative in which case it will be made
 * absolute with baseUrl
 * @param {String} method
 * @param {Object?} data
 * @param {Object?} config
 */


function callApi(endpoint, method, data) {
  var _arguments = arguments;

  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$types = _ref.types,
      types = _ref$types === void 0 ? [API_CALL_REQUEST, API_CALL_RESULT, API_CALL_RESULT] : _ref$types,
      _ref$requestType = _ref.requestType,
      requestType = _ref$requestType === void 0 ? types[0] : _ref$requestType,
      _ref$successType = _ref.successType,
      successType = _ref$successType === void 0 ? types[1] : _ref$successType,
      _ref$failureType = _ref.failureType,
      failureType = _ref$failureType === void 0 ? successType : _ref$failureType,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      _ref$fetchOptions = _ref.fetchOptions,
      fetchOptions = _ref$fetchOptions === void 0 ? {} : _ref$fetchOptions;

  method = method.toUpperCase(); // eslint-disable-line

  (0, _invariant["default"])(['GET', 'PUT', 'POST', 'DELETE', 'PATCH'].includes(method), "Invalid method '".concat(method, "' specified to callApi"));
  var apiConfig = getApiConfigFor(endpoint);

  if (!isAbsUrl(endpoint)) {
    endpoint = buildApiUrl(endpoint); // eslint-disable-line
  }

  if (requestType === API_CALL_REQUEST) {
    requestType = {
      // eslint-disable-line
      type: requestType,
      meta: {
        endpoint: endpoint,
        method: method,
        data: data
      }
    };
  }

  var finalTypes = [requestType, successType, failureType];
  finalTypes.forEach(function (reqType) {
    (0, _invariant["default"])(reqType && ((0, _typeof2["default"])(reqType) == 'object' && reqType.type || typeof reqType == 'string'), "Invalid request type provided for callApi('".concat(endpoint, "', '").concat(method, "', ...) must ") + "either be a string or an object with a 'type' property set");
  });
  var finalHeaders = buildHeaders(apiConfig, headers);
  var finalData = null;

  if (data instanceof FormData) {
    finalData = data;
    delete finalHeaders['Content-Type'];
  } else if (data) {
    // If we have received any files convert our data to a FormData instance
    // with a key 'formData' that contains our stringified non-File data with
    // placeholder values for each file upload (eg. ____ATTACHED_FILE_ID_1 etc)
    // Add a matching form key to the actual file data for every file field found
    // On the backend this is handled transparently and converts it back to the
    // nested JSON structure with each placeholder value replaced with actual
    // file contents (eg. in django an InMemoryUploadedFile)
    // This special case is identified by the header X-RADCOMBINEDFORMPOST
    var fileCount = 0;
    var files = {};

    var replacer = function replacer(key, value) {
      if (value instanceof File) {
        var id = "____ATTACHED_FILE_ID_".concat(fileCount++);
        files[id] = value;
        return id;
      }

      return value;
    };

    var stringifiedData = JSON.stringify(data, replacer);

    if (fileCount > 0) {
      delete finalHeaders['Content-Type'];
      finalData = new FormData();
      finalData.append('formData', stringifiedData);
      Object.keys(files).forEach(function (fileKey) {
        return finalData.append(fileKey, files[fileKey]);
      });
      finalHeaders['X-RADCombinedFormPost'] = true;
    } else {
      finalData = stringifiedData;
    }
  }

  return function (dispatch) {
    return dispatch((0, _defineProperty2["default"])({}, _reduxApiMiddleware.CALL_API, {
      endpoint: endpoint,
      method: method,
      body: finalData,
      types: finalTypes,
      credentials: apiConfig.credentials,
      headers: finalHeaders,
      options: fetchOptions
    })).then(function (response) {
      // For calls to our API invalidate auth if we get a 401 (unless config says not to)
      if (!apiConfig.bypassAuthRetry && response.error && response.payload.status === 401) {
        // If we get a 401 handle it such that a login form can be displayed
        // and then the API call retried.
        var deferred; // Create a promise that we return instead to defer handling of
        // the result of the API call. This means that the caller will
        // NEVER see a 401 - the promise it will be dealing with will
        // be unresolved until they log in. This allows any UI dependencies
        // on the state of the promise to work until the login has finished.
        // It does mean UI must allow for a pending API call while  login
        // form is displayed (eg. displayed a full screen loading message
        // which obscures the login form would be bad)

        var p = new Promise(function (resolve, reject) {
          deferred = {
            resolve: resolve,
            reject: reject
          };
        });
        dispatch({
          type: API_CALL_AUTH_REQUIRED,
          // Payload is a function that de-dispatches the API call
          // and resolves the promise we created above.
          payload: function payload(dispatch) {
            return dispatch(callApi.apply(void 0, (0, _toConsumableArray2["default"])(_arguments))).then(deferred.resolve, deferred.reject);
          },
          meta: {
            requestTypes: {
              requestType: requestType,
              successType: successType,
              failureType: failureType
            }
          }
        });
        return p;
      }

      return response;
    });
  };
}

var apiCallInProgressByEndpoint = {};
/**
 * Django rest framework filters in query parameters require booleans be
 * either True or False
 */

function convertDjangoQueryParam(value) {
  if (value === true) return 'True';
  if (value === false) return 'False';
  return value;
}

function buildEndpointWithQueryParams(endpoint, params, apiConfig) {
  (0, _invariant["default"])(endpoint.indexOf('?') === -1, "Call to API method provided endpoint of ".concat(endpoint, " which contains a '?'. Pass ") + 'any query parameters through as an object to the second parameter');
  endpoint = (0, _trim["default"])(endpoint, '/');

  if (apiConfig.appendSlash) {
    endpoint += '/';
  }

  return [endpoint, // Convert query params into form expected by django-rest-framework
  // but only if we aren't dealing with absolute URL
  toQueryString(params, isAbsUrl(endpoint) ? _identity["default"] : convertDjangoQueryParam)].join('?');
}
/**
 * For GET's don't fire same request multiple times
 */


function get(endpoint) {
  var getParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _invariant["default"])(endpoint.indexOf('?') === -1, "Call to get provided endpoint of ".concat(endpoint, " which contains a '?'. Pass ") + 'any query parameters through as an object to the second parameter');
  var apiConfig = getApiConfigFor(endpoint);
  var finalEndpoint = buildEndpointWithQueryParams(endpoint, getParams, apiConfig);
  return function (dispatch) {
    var cacheKey = finalEndpoint;

    if (config.headers && Object.keys(config.headers).length > 0) {
      var headersList = Object.keys(config.headers).map(function (header) {
        return "".concat(header, "=").concat(config.headers[header]);
      });
      headersList.sort(function (a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });
      cacheKey += headersList.join(',');
    }

    if (apiCallInProgressByEndpoint[cacheKey]) {
      return apiCallInProgressByEndpoint[cacheKey];
    }

    apiCallInProgressByEndpoint[cacheKey] = dispatch(callApi(finalEndpoint, 'get', null, config));
    return apiCallInProgressByEndpoint[cacheKey].then(function (result) {
      delete apiCallInProgressByEndpoint[cacheKey];
      return result;
    }, function (e) {
      delete apiCallInProgressByEndpoint[cacheKey];
      throw e;
    });
  };
}

function post(endpoint) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return callApi(endpoint, 'post', data, config);
}

function patch(endpoint) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return callApi(endpoint, 'patch', data, config);
}

function del(endpoint) {
  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var apiConfig = getApiConfigFor(endpoint);
  var finalEndpoint = buildEndpointWithQueryParams(endpoint, queryParams, apiConfig);
  return callApi(finalEndpoint, 'delete', null, config);
}