"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateEntityOrder = updateEntityOrder;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread3 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _actions = require("./actions");

var _Model = require("./Model");

function updateEntityOrder(entity, groupKey, dropResult) {
  return (
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(dispatch, getState) {
        var state, entityClass, groupedEntities, allEntities, draggableId, destination, source, entities, payload, optimisticPayload, seq, isSameList, isLast, isAfter, to, orderedModel, currentSortKey, _dispatch, optimisticId, undoOptimistic;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                state = getState();
                entityClass = entity.constructor;
                groupedEntities = entityClass.selectors.groupedByOrderWithRespectTo(state);
                allEntities = entityClass.selectors.all(state);
                draggableId = dropResult.draggableId, destination = dropResult.destination, source = dropResult.source;

                if (!(destination == null)) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return");

              case 7:
                entities = groupedEntities.get(groupKey);

                if (entities) {
                  seq = entities.toIndexedSeq();
                  isSameList = source.droppableId === destination.droppableId;
                  isLast = destination.index >= entities.size;
                  isAfter = isSameList && source.index < destination.index || isLast;
                  to = isLast ? entities.last() : destination.index === -1 ? entities.first() : seq.get(destination.index);
                  payload = {
                    reorderRelativeTo: to.getId(),
                    insertAfter: isAfter
                  };
                  orderedModel = entity[_Model.$modelDefinition].orderedModel;
                  currentSortKey = to.get(orderedModel.orderFieldName);
                  optimisticPayload = (0, _objectSpread3["default"])((0, _defineProperty2["default"])({}, orderedModel.orderFieldName, currentSortKey + (isAfter ? 0.01 : -0.01)), groupKey);
                } else {
                  payload = groupKey;
                  optimisticPayload = groupKey;
                }

                _dispatch = dispatch((0, _actions.updateOptimistic)(entity, optimisticPayload)), optimisticId = _dispatch.optimisticId, undoOptimistic = _dispatch.undoOptimistic;
                _context.prev = 10;
                _context.next = 13;
                return dispatch((0, _actions.customDetailRoute)('patch', entity, 'reorder', payload, {
                  optimisticId: optimisticId
                }));

              case 13:
                return _context.abrupt("return", _context.sent);

              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](10);
                undoOptimistic();
                throw _context.t0;

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[10, 16]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
}