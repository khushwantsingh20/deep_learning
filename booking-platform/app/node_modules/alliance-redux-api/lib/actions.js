"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeResponseData = normalizeResponseData;
exports.fetchEntities = fetchEntities;
exports.fetchEntitiesPaginated = fetchEntitiesPaginated;
exports.fetchEntity = fetchEntity;
exports.updateEntity = updateEntity;
exports.addEntity = addEntity;
exports.addEntityLocal = addEntityLocal;
exports.deleteEntityLocal = deleteEntityLocal;
exports.deleteEntity = deleteEntity;
exports.customDetailRoute = customDetailRoute;
exports.customListRoute = customListRoute;
exports.reorderEntity = reorderEntity;
exports.getReorderPayload = getReorderPayload;
exports.updateEntityOrdering = updateEntityOrdering;
exports.updateOptimistic = updateOptimistic;
exports.actionTypes = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _immutable = _interopRequireDefault(require("immutable"));

var _invariant = _interopRequireDefault(require("invariant"));

var _reduxApiMiddleware = require("redux-api-middleware");

var _uid = _interopRequireDefault(require("./uid"));

var _api = require("./api");

var _normalize = _interopRequireDefault(require("./normalize"));

var _Model = require("./Model");

var _util = require("./util");

var _serialize = require("./serialize");

var apiMethods = {
  get: _api.get,
  patch: _api.patch,
  post: _api.post,
  del: _api.del,
  "delete": _api.del
};
/**
 * Create a pagination record that is returned for paginated API responses.
 *
 * This is the structure consumed by users of fetchEntities and related API
 * endpoints.
 *
 * @param page {Number} the page number requested
 * @param pageSize {Number} the size of the page that was requested
 * @param ids {Array<number|string>} the ids of the records returned
 * @param count {Number} the total number of records available from the API
 * @returns {{paginated: boolean, previousPage: *, nextPage: *, count: *, ids: *, pageSize: *, page: *}}
 */

function createPaginationRecord(page, pageSize, ids, count) {
  // There's no way to know what the page / pageSize was from the response
  // returned by the default DRF pagination classes. As such the page and pageSize
  // need to be extracted at the time of the request and passed in to this function.
  // Unfortunately this isn't always set (in most new code it is, but not required).
  // As such we have to set some defaults if not specified.
  // TODO: This is fragile in that if the backend defaults
  // don't match our defaults and page/pageSize aren't explicitly
  // passed then things won't match.... but backwards compat :(
  pageSize = Number(pageSize || 20);
  page = Number(page || 1);
  var offset = (page - 1) * pageSize;
  var nextPage = offset + pageSize < count ? page + 1 : null;
  var previousPage = page > 1 ? page - 1 : null;
  return {
    ids: ids,
    count: count,
    paginated: true,
    nextPage: nextPage,
    previousPage: previousPage,
    pageSize: pageSize,
    page: page
  };
}
/**
 * Handle normalizing data that may be for a single entity OR may be
 * structured as:
 * {
 *    entities: {
 *       someModelId: [...list of updated records...]
 *    }
 * }
 * Where 'someModelId' is the model ID as determined by the backend. This
 * must match your Model's modelId which can be specified when you create
 * the model as an optional parameter. This allows multiple records be
 * returned in a single response without requiring they be a foreign key
 * from the main object. Use cases for this are if you are creating associated
 * records with a main record but they aren't specified as relationships
 * on the main record so aren't serialized as part of the base record.
 * @param {*} entity entity class or entity instance
 * @param {*} data  data from API call
 */


function normalizeResponseData(entity, data) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      page = _ref.page,
      pageSize = _ref.pageSize;

  var stateKey = entity[_Model.$modelDefinition].stateKey;

  if (data.entities || data.deletedEntities || data.paginatedEntity) {
    var deletedEntities = Object.keys(data.deletedEntities || {}).reduce(function (acc, modelId) {
      var modelData = data.deletedEntities[modelId];
      var modelClass = _Model.modelClassMap[modelId];

      if (modelClass) {
        var _acc$_stateKey;

        var _stateKey = modelClass[_Model.$modelDefinition].stateKey;
        var ids = Array.isArray(modelData) ? modelData : [modelData];

        if (!acc[_stateKey]) {
          acc[_stateKey] = [];
        }

        (_acc$_stateKey = acc[_stateKey]).push.apply(_acc$_stateKey, (0, _toConsumableArray2["default"])(ids));

        return acc;
      }

      console.warn("Response included data for unknown model ".concat(modelId, ". If this isn't intenitional ensure your Model was created and specified a 'modelId' of '").concat(modelId, "'."));
      return acc;
    }, {});

    var _normalizedData = Object.keys(data.entities || {}).reduce(function (acc, modelId) {
      var modelData = data.entities[modelId];
      var modelClass = _Model.modelClassMap[modelId];

      if (modelClass) {
        var _normalizeData = (0, _normalize["default"])(modelClass, modelData),
            entities = _normalizeData.entities,
            result = _normalizeData.result;

        Object.keys(entities).forEach(function (entitiesStateKey) {
          if (!acc.entities[entitiesStateKey]) {
            acc.entities[entitiesStateKey] = {};
          }

          Object.keys(entities[entitiesStateKey]).forEach(function (entityId) {
            acc.entities[entitiesStateKey][entityId] = entities[entitiesStateKey][entityId];
          });
        }); // For the main model set result which contains the relevant id(s)

        if (modelClass[_Model.$modelDefinition].stateKey === stateKey) {
          acc.result = result;
        }

        return acc;
      }

      console.warn("Response included data for unknown model ".concat(modelId, ". If this isn't intenitional ensure your Model was created and specified a 'modelId' of '").concat(modelId, "'."));
      return acc;
    }, (0, _objectSpread2["default"])({}, data, {
      entities: {},
      result: [],
      deletedEntities: deletedEntities,
      // This is included so that things that use the response know what
      // the calling entity was.
      entityClass: entity
    })); // Backwards compat - some stuff uses result others ids; they mean the same thing


    _normalizedData.ids = _normalizedData.result;

    if (data.paginatedEntity) {
      // A paginated entity can be returned nested in `data` for cases where
      // extra data is being returned in addition to the regular paginated
      // response. On the backend you would do this like:
      // ```
      // return DjradEntityResponse(
      //    self.get_serializer(request.user),
      //    AdminProfileSerializer(AdminProfile.objects.all(), many=True),
      //    paginated_response=self.get_paginated_response(serializer.data),
      //    data={"someExtraData": 5},
      // )
      // ```
      // In this example the current user would be returned, a list of
      // admin profiles would be returned (and available in `data.entities`,
      // the paginated response for the API in question (users) would be
      // returned and finally some extra data is also included.
      // Here we take the data extracted from `paginated_response` and we
      // transform that into the `entities` object. So in the example above
      // the `entities` object might look like:
      // {
      //    // Data from the paginated response and serialized current user
      //    users: { ... },
      //    // The data from AdminProfileSerializer
      //    adminprofile: { ... },
      // }
      // And `data.results` will be the list of id's returned in
      // `paginated_response`. The pagination data (as returned by
      // `createPaginationRecord`) is included as well so the final
      // normalized data looks something like:
      // ```
      // {
      //   entities: {...},
      //   results: [1,2,3,4,5],
      //   ids: [1,2,3,4,5],
      //   count: 5,
      //   paginated: true,
      //   nextPage: null,
      //   previousPage: null,
      //   page: 1,
      //   pageSize: 10,
      //   someExtraData: 5 ,
      // }
      // ```
      // There is some duplication here (eg. results and ids) - this whole
      // structure is basically for backwards compatibility. It could be
      // represented _much_ better... but at this stage a lot of things
      // depend on it.
      delete _normalizedData.paginatedEntity;

      if (!_normalizedData.entities[stateKey]) {
        _normalizedData.entities[stateKey] = {};
      }

      var _data$paginatedEntity = data.paginatedEntity,
          paginatedResults = _data$paginatedEntity.results,
          pagination = (0, _objectWithoutProperties2["default"])(_data$paginatedEntity, ["results"]);

      var _normalizeData2 = (0, _normalize["default"])(entity, paginatedResults),
          entities = _normalizeData2.entities,
          result = _normalizeData2.result;

      Object.keys(entities).forEach(function (key) {
        Object.assign(_normalizedData.entities[key], entities[key]);
      });
      _normalizedData.result = result;
      _normalizedData.ids = result;
      _normalizedData.paginated = true;
      Object.assign(_normalizedData, createPaginationRecord(page, pageSize, result, pagination.count));
    }

    return _normalizedData;
  }

  var normalizedData = (0, _normalize["default"])(entity, data); // Backwards compat - some stuff uses result others ids; they mean the same thing

  normalizedData.ids = normalizedData.result;
  return normalizedData;
}

var actionTypes = {
  fetch: '@alliance-redux-api/fetch',
  fetchStart: '@alliance-redux-api/fetch.start',
  fetchFailure: '@alliance-redux-api/fetch.failure',
  customDetail: '@alliance-redux-api/customDetail',
  customDetailStart: '@alliance-redux-api/customDetail.start',
  customDetailFailure: '@alliance-redux-api/customDetail.failure',
  customList: '@alliance-redux-api/customList',
  customListStart: '@alliance-redux-api/customList.start',
  customListFailure: '@alliance-redux-api/customList.failure',
  add: '@alliance-redux-api/add',
  addStart: '@alliance-redux-api/add.start',
  addFailure: '@alliance-redux-api/add.failure',
  update: '@alliance-redux-api/update',
  updateStart: '@alliance-redux-api/update.start',
  updateFailure: '@alliance-redux-api/update.failure',
  updateOptimistic: '@alliance-redux-api/updateOptimistic',
  updateOptimisticUndo: '@alliance-redux-api/updateOptimisticUndo',
  addLocal: '@alliance-redux-api/addLocal',
  deleteLocal: '@alliance-redux-api/deleteLocal',
  "delete": '@alliance-redux-api/delete',
  deleteStart: '@alliance-redux-api/delete.start',
  deleteFailure: '@alliance-redux-api/delete.failure',
  reorder: '@alliance-redux-api/reorder'
};
exports.actionTypes = actionTypes;
var endpointDoesNotSupportPagination = {};
/**
 * Fetch entities from API endpoint. Dispatches a ENTITY_FETCH action with
 * payload patching normalizr.normalize result:
 * {
 *   // Entities are defined by schema, eg. if tasks was the schema and it
 *   // had a relationship on subProject the result may look like: (indexed by id)
 *   entities: { tasks: {...}, subProject: {...} },
 *   // List of id's in the order recieved from API
 *   result: [...],
 * }
 *
 * You can call this multiple times before it resolves and it will only generated
 * a single request (see get() in api/actions).
 *
 * Multiple calls to fetch the same entities (based on filter values) will only
 * trigger one request by default. Subsequent calls will not trigger a XHR
 * request and will resolve the promise with the records fetched originally.
 *
 * Pass options.nocache = true to opt out.
 *
 * @param {String} entityName the name of entity, should match API endpoint, eg.
 * if endpoint is /api/tasks the entity name is tasks
 * @param {Schema} singleEntitySchema a normalizr schema for a single entity,
 * will automatically convert it to arrayOf
 * @param {Object} filters any filters to apply - this get converted to query
 * parameters
 * @param {Object} options
 * @param {Bool} options.nocache set to true to bypass fetch caching and always
 * perform an server request.
 * @return Promise<List<entityClass>> resolves to a list of records fetched
 */

function fetchEntities(modelClass) {
  var filters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return function (dispatch, getState) {
    // validateEntityClass(entityClass);
    var _modelClass$$modelDef = modelClass[_Model.$modelDefinition],
        stateKey = _modelClass$$modelDef.stateKey,
        cache = _modelClass$$modelDef.cache,
        _modelClass$$modelDef2 = _modelClass$$modelDef.transformResponse,
        transformResponse = _modelClass$$modelDef2 === void 0 ? function (x) {
      return x;
    } : _modelClass$$modelDef2;
    var endpoint = options.endpoint || modelClass[_Model.$modelDefinition].endpoint; // The forcePagination exists for historical reasons; original usage of this module
    // was on a site where we did not paginate and so option here was actually to opt
    // in to pagination with option to fake the pagination locally if endpoint didn't
    // support pagination. I've left the logic in place for this but the default is now
    // to always paginate and you can't control it from the front end - the backend
    // has full control over whether pagination is in place or not.

    var _options$forcePaginat = options.forcePagination,
        forcePagination = _options$forcePaginat === void 0 ? false : _options$forcePaginat,
        partialRecordFieldNames = options.partialRecordFieldNames,
        _options$headers = options.headers,
        headers = _options$headers === void 0 ? {} : _options$headers,
        _options$fetchOptions = options.fetchOptions,
        fetchOptions = _options$fetchOptions === void 0 ? {} : _options$fetchOptions;
    var finalMeta = (0, _objectSpread2["default"])({}, meta, {
      stateKey: stateKey,
      filters: filters,
      partialRecordFieldNames: partialRecordFieldNames
    });
    var finalHeaders = (0, _objectSpread2["default"])({}, headers);

    if (partialRecordFieldNames) {
      finalHeaders['X-Djradfields'] = partialRecordFieldNames.join(' ');
    }

    var selectEntities = function selectEntities() {
      if (partialRecordFieldNames) {
        return modelClass.selectors.partialFields.synced(getState())(partialRecordFieldNames);
      }

      return modelClass.selectors.synced(getState());
    };

    var getResultingEntities = function getResultingEntities(ids) {
      var allEntities = selectEntities();
      return _immutable["default"].List(ids.map(function (id) {
        return allEntities.get(id);
      }));
    };

    var finalFilters = (0, _objectSpread2["default"])({}, filters);
    var endpointSupportPagination = !endpointDoesNotSupportPagination[modelClass];
    var cacheKey = (0, _objectSpread2["default"])({}, finalFilters, {
      endpoint: endpoint,
      partialRecordFieldNames: partialRecordFieldNames
    });

    if (!endpointSupportPagination) {
      delete cacheKey.pageSize;
      delete cacheKey.page;
    }

    if (!options.nocache) {
      var cachedValue = cache.get(getState, cacheKey, selectEntities);

      if (cachedValue) {
        var ids = cachedValue.ids;

        if (forcePagination && !endpointSupportPagination) {
          var _filters$page = filters.page,
              page = _filters$page === void 0 ? 1 : _filters$page,
              _filters$pageSize = filters.pageSize,
              pageSize = _filters$pageSize === void 0 ? 20 : _filters$pageSize;
          var offset = (page - 1) * pageSize;
          ids = ids.slice(offset, offset + pageSize);
        }

        return Promise.resolve((0, _objectSpread2["default"])({}, cachedValue, {
          entities: getResultingEntities(ids),
          entityClass: modelClass
        }));
      }
    }

    return dispatch((0, _api.get)("".concat(endpoint, "/"), finalFilters, {
      headers: finalHeaders,
      fetchOptions: fetchOptions,
      requestType: {
        type: actionTypes.fetchStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes.fetch,
        payload: function payload(action, state, response) {
          return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
            (0, _invariant["default"])(json, "Expected JSON Content-Type on API call to the endpoint '".concat(endpoint, "'. ") + 'Does the endpoint exist? Do you need to customise the endpoint on the Model?');
            var page = filters.page,
                pageSize = filters.pageSize;
            var data = transformResponse(json);

            if (data.count != null && data.results) {
              var results = data.results,
                  count = data.count,
                  next = data.next,
                  previous = data.previous,
                  rest = (0, _objectWithoutProperties2["default"])(data, ["results", "count", "next", "previous"]);
              return normalizeResponseData(modelClass, (0, _objectSpread2["default"])({
                entities: {},
                paginatedEntity: {
                  results: results,
                  count: count,
                  next: next,
                  previous: previous
                }
              }, rest), {
                page: page,
                pageSize: pageSize
              });
            }

            if (forcePagination) {
              endpointDoesNotSupportPagination[modelClass] = true;
            }

            return normalizeResponseData(modelClass, data, {
              page: page,
              pageSize: pageSize
            });
          });
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.fetchFailure,
        meta: finalMeta
      }
    })).then(function (_ref2) {
      var payload = _ref2.payload,
          error = _ref2.error;

      if (error) {
        // This will be an ApiError object from redux-api-middleware
        throw payload;
      }

      var cacheValue = (0, _objectSpread2["default"])({}, payload, {
        entityClass: modelClass
      });
      var ids = payload.ids;

      if (forcePagination && endpointDoesNotSupportPagination[modelClass]) {
        // If the endpoint doesn't actually support pagination we
        // just do it locally. As such store all id's then paginate
        // them when we retrieve from cache. Also note the cacheKey
        // excludes pagination related values so that subsequent
        // requests for a different page don't trigger a refetch
        var _offset = payload.offset,
            _pageSize = payload.pageSize;
        cacheValue.ids = ids;
        ids = ids.slice(_offset, _offset + _pageSize);
        delete cacheKey.pageSize;
        delete cacheKey.page;
      }

      cache.set(getState, cacheKey, cacheValue, selectEntities);
      return (0, _objectSpread2["default"])({}, cacheValue, {
        paginated: cacheValue.paginated || forcePagination,
        entities: getResultingEntities(ids)
      });
    });
  };
}

function fetchEntitiesPaginated(modelClass) {
  var filters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return fetchEntities(modelClass, filters, (0, _objectSpread2["default"])({}, options, {
    paginate: true
  }), meta);
}
/**
 * Get a single record from the backend. This assumes your backend viewset
 * has support as described below.
 *
 * When passing an ID return a single record (DRF RetrieveModelMixin):
 *
 * ```
 * /api/user/5/
 * ```
 *
 * When passing a filter object support for listing records (DRF ListModelMixin):
 *
 * ```
 * /api/users/?userId=5&projectId=2
 * ```
 *
 * Your backend must also apply the filters for `userId` and `projectId` in this
 * case (eg. using a `filterset_class` on your viewset).
 *
 * @param {ModelRecord} modelClass The model class to fetch record from
 * @param {Number|Object} id either the id of the entity to fetch or a filter object
 * that should result in a single record being returned. This is useful when you
 * have a unique constraint on a record that you want to use to identify a record.
 * When the filter object is passed the API call is to the list view and passes
 * the filter as query parameters. For example if you pass `{ userId: 5, projectId: 2 }`
 * you might get:
 * ```
 * /api/users/?userId=5&projectId2
 * ```
 * Your backend must handle those query parameters such that a single record is returned.
 * If multiple records are returned a ApiError will be raised with a status of 400.
 * @param {Object} options
 * @param {Array<string>} options.partialRecordFieldNames An optional list of field
 * names to fetch. If provided it's expected the backend will only return these
 * fields. This can be used to reduce the size of the return payload or optimise
 * the queries used on the backend.
 * @param {Object} options.headers Any extra headers to pass through to the backend
 * @param {Object} options.fetchOptions Extra options to pass through to the
 * [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) call.
 * @param {Boolean} options.nocache set to true to bypass fetch caching and always
 * perform an server request.
 * @return Promise
 */


function fetchEntity(modelClass, id) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return (
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(dispatch, getState) {
        var _modelClass$$modelDef3, stateKey, endpoint, cache, partialRecordFieldNames, _options$headers2, headers, fetchOptions, selectEntities, cachedValue, entity, generateReturnValue, finalHeaders, finalMeta;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                generateReturnValue = function _ref6(id) {
                  cache.set(getState, id, id, selectEntities);
                  var allEntities;

                  if (partialRecordFieldNames) {
                    allEntities = modelClass.selectors.partialFields.synced(getState())(partialRecordFieldNames);
                  } else {
                    allEntities = modelClass.selectors.synced(getState());
                  }

                  return allEntities.get(id);
                };

                _modelClass$$modelDef3 = modelClass[_Model.$modelDefinition], stateKey = _modelClass$$modelDef3.stateKey, endpoint = _modelClass$$modelDef3.endpoint, cache = _modelClass$$modelDef3.cache;
                partialRecordFieldNames = options.partialRecordFieldNames, _options$headers2 = options.headers, headers = _options$headers2 === void 0 ? {} : _options$headers2, fetchOptions = options.fetchOptions;

                selectEntities = function selectEntities() {
                  if (partialRecordFieldNames) {
                    return modelClass.selectors.partialFields.synced(getState())(partialRecordFieldNames);
                  }

                  return modelClass.selectors.synced(getState());
                };

                if (options.nocache) {
                  _context.next = 9;
                  break;
                }

                cachedValue = cache.get(getState, id, selectEntities);
                entity = selectEntities().get(cachedValue);

                if (!entity) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(entity));

              case 9:
                if (!(id && (0, _typeof2["default"])(id) == 'object')) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return", dispatch(fetchEntities(modelClass, id, options, meta)).then(function (_ref4) {
                  var ids = _ref4.ids;

                  if (ids.length === 0) {
                    throw new _reduxApiMiddleware.ApiError(404, 'Not found');
                  }

                  if (ids.length > 1) {
                    // eslint-disable-next-line no-console
                    console.warn("Expected only one result from endpoint, received ".concat(ids.length, ". Make sure endpoint applies filters on '").concat(Object.keys(id).join(', '), "' such that only one result is returned"));
                    throw new _reduxApiMiddleware.ApiError(400, 'Multiple objects returned');
                  }

                  return generateReturnValue(ids[0]);
                }));

              case 11:
                finalHeaders = (0, _objectSpread2["default"])({}, headers);

                if (partialRecordFieldNames) {
                  finalHeaders['X-Djradfields'] = partialRecordFieldNames.join(' ');
                }

                finalMeta = (0, _objectSpread2["default"])({}, meta, {
                  stateKey: stateKey,
                  partialRecordFieldNames: partialRecordFieldNames
                });
                return _context.abrupt("return", dispatch((0, _api.get)("".concat(endpoint, "/").concat(id, "/"), null, {
                  headers: finalHeaders,
                  fetchOptions: fetchOptions,
                  requestType: {
                    type: actionTypes.fetchStart,
                    meta: finalMeta
                  },
                  successType: {
                    type: actionTypes.fetch,
                    payload: function payload(action, state, response) {
                      return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
                        if (json.entities) {
                          // This means our API endpoint returned the record
                          // we care about + some extra data. In that case
                          // we need to handle it slightly different... we
                          // set isSimpleResponse here and then look for that
                          // in the final `then` below. It's difficult to do
                          // this check below as both `normalizeData` and
                          // `normalizeResponseData` will generate a structure
                          // that can look the same depending on the response
                          // data returned from the backend (ie. we can't
                          // necessarily differentiated between them after
                          // these calls are made).
                          return (0, _objectSpread2["default"])({}, normalizeResponseData(modelClass, json), {
                            isSimpleResponse: false
                          });
                        }

                        return (0, _objectSpread2["default"])({}, (0, _normalize["default"])(modelClass, json), {
                          isSimpleResponse: true
                        });
                      });
                    },
                    meta: finalMeta
                  },
                  failureType: {
                    type: actionTypes.fetchFailure,
                    meta: finalMeta
                  }
                })).then(function (_ref5) {
                  var payload = _ref5.payload,
                      error = _ref5.error;

                  if (error) {
                    // This will be an ApiError object from redux-api-middleware
                    throw payload;
                  }

                  var record = generateReturnValue(id);
                  var isSimpleResponse = payload.isSimpleResponse,
                      rest = (0, _objectWithoutProperties2["default"])(payload, ["isSimpleResponse"]);

                  if (payload.isSimpleResponse) {
                    // If it's a simple response we only return a record - there's no
                    // access to anything from the response (which is fine, as the response
                    // only contained the record data itself).
                    return record;
                  } // If it's not a simple record response we return the record as a key
                  // on an object and all the rest of the data as returned by
                  // `normalizeResponseData`. This is for more advanced use cases where
                  // you want to fetch a record and at the same time fetch some extra
                  // info in the same API call.


                  return (0, _objectSpread2["default"])({}, rest, {
                    record: record
                  });
                }));

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref3.apply(this, arguments);
      };
    }()
  );
}
/**
 * Update an existing entity
 * @param {Record} entity to update
 * @param {Object} data extra data fields to apply to entity
 * @param {Object} extra options. Set optimistic to true to apply updates
 * immediately before waiting for server to respond.
 * @param {Object} meta
 * @return {Promise}
 */


function updateEntity(entity, data) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // validateEntityInstance(entity);
  var _entity$$modelDefinit = entity[_Model.$modelDefinition],
      stateKey = _entity$$modelDefinit.stateKey,
      modelId = _entity$$modelDefinit.modelId;
  var endpoint = options.endpoint || entity[_Model.$modelDefinition].endpoint;

  if (options.endpointAppend) {
    endpoint = "".concat(endpoint, "/").concat(options.endpointAppend);
  }

  data = (0, _serialize.serializeModelData)(entity, data);
  var finalMeta = (0, _objectSpread2["default"])({}, meta, {
    entity: entity,
    stateKey: stateKey
  });
  (0, _invariant["default"])(entity.getId() != null, "You called updateEntity for state key '".concat(stateKey, "' with entity ") + "instance that has no 'id' field set. This is required.");
  var selectors = entity.constructor.selectors;
  return function (dispatch, getState) {
    var undoOptimistic;

    if (options.optimistic) {
      var optimisticId = _uid["default"].v4();

      finalMeta.optimisticId = optimisticId;
      var state = getState();
      var path = (0, _util.getRecordPath)(state, entity);
      var entitiesRoot = state[path.shift()];
      var existingEntity = entitiesRoot.getIn(path);

      undoOptimistic = function undoOptimistic() {
        dispatch({
          type: actionTypes.updateOptimisticUndo,
          meta: finalMeta,
          payload: {
            entity: existingEntity,
            data: data
          }
        });
      };

      dispatch({
        type: actionTypes.updateOptimistic,
        meta: finalMeta,
        payload: {
          entity: entity,
          data: data
        }
      });
    }

    return dispatch((0, _api.patch)("".concat(endpoint, "/").concat(entity.getId(), "/"), data, {
      headers: options.headers,
      fetchOptions: options.fetchOptions,
      requestType: {
        type: actionTypes.updateStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes.update,
        payload: function payload(action, state, response) {
          return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
            return normalizeResponseData(entity, json);
          });
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.updateFailure,
        meta: finalMeta
      }
    })).then(function (_ref7) {
      var payload = _ref7.payload,
          error = _ref7.error;

      if (error) {
        if (undoOptimistic) {
          undoOptimistic();
        } // This will be an ApiError object from redux-api-middleware


        throw payload;
      } // For an update we always know the original id so can use entity.getId() rather than payload.result


      var record = selectors.synced(getState()).get(entity.getId());

      if (!record) {
        console.warn("Expected response to to include the updated record but it did not. If the record did update on the backend your local cache is now out of sync.");
        return payload;
      }

      return (0, _objectSpread2["default"])({}, payload, {
        record: record
      });
    });
  };
}
/**
 * Add a new entity
 */


function addEntity(entity) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return function (dispatch, getState) {
    // validateEntityInstance(entity);
    var stateKey = entity[_Model.$modelDefinition].stateKey;
    var endpoint = options.endpoint || entity[_Model.$modelDefinition].endpoint;

    if (options.endpointAppend) {
      endpoint = "".concat(endpoint, "/").concat(options.endpointAppend);
    }

    var finalMeta = (0, _objectSpread2["default"])({}, meta, {
      stateKey: stateKey,
      entity: entity
    });

    if (!data) {
      data = entity.serialize(); // eslint-disable-line
    } else {
      data = (0, _serialize.serializeModelData)(entity, data);
    }

    (0, _invariant["default"])(entity.id == null, "You called addEntity for entity name '".concat(stateKey, "' with data ") + "that has an 'id' field set. To update records call updateEntity.");
    return dispatch((0, _api.post)("".concat(endpoint, "/"), data, {
      headers: options.headers,
      fetchOptions: options.fetchOptions,
      requestType: {
        type: actionTypes.addStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes.add,
        payload: function payload(action, state, response) {
          return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
            return normalizeResponseData(entity, json);
          });
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.addFailure,
        meta: finalMeta
      }
    })).then(function (_ref8) {
      var payload = _ref8.payload,
          error = _ref8.error;

      if (error) {
        throw payload;
      } // payload.result will contain an id if a single record is returned from the endpoint.
      // in the case of multiple entities using the { entities: { ... } } structure result will
      // be an array of id's but with no indication as to which entity was created. The 'createdId'
      // field can be returned from the API to indicate the ID of the created entity.


      var id = payload.createdId || payload.result;
      var record = entity.selectors.synced(getState()).get(id);

      if (!record) {
        console.warn('Expected response to include the created record but it did not. If the record did ' + 'create on the backend your local cache is now out of sync. If you are returning multiple ' + "records from the backend specify which is the created record with the 'createdId' field.");
        return payload;
      }

      return (0, _objectSpread2["default"])({}, payload, {
        record: record
      });
    });
  };
}
/**
 * Add an entity to the local cache but don't persist it to the server
 *
 * The entity created is returned.
 */


function addEntityLocal(entityClass, data) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var stateKey = entityClass[_Model.$modelDefinition].stateKey;
  data = (0, _serialize.serializeModelData)(entityClass, data);
  (0, _invariant["default"])(data.id == null, "You called addEntityLocal for entity name '".concat(stateKey, "' with data ") + "that has an 'id' field set. To update existing records saved on backend " + 'call updateEntity.');
  var finalMeta = (0, _objectSpread2["default"])({}, meta, {
    stateKey: stateKey
  });
  return function (dispatch, getState) {
    // Generate ID here; reducer expects this. This is so we can fetch the
    // created entity from the state.
    var modelUUID = _uid["default"].v4();

    dispatch({
      type: actionTypes.addLocal,
      payload: {
        data: data,
        modelUUID: modelUUID
      },
      meta: finalMeta
    });
    return entityClass.selectors.entities(getState()).getIn([stateKey, 'local', modelUUID]);
  };
}
/**
 * Delete an entity that was added with addEntityLocal
 */


function deleteEntityLocal(entity) {
  var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // validateEntityInstance(entity);
  var stateKey = entity[_Model.$modelDefinition].stateKey;
  var finalMeta = (0, _objectSpread2["default"])({}, meta, {
    stateKey: stateKey
  });
  return function (dispatch) {
    dispatch({
      type: actionTypes.deleteLocal,
      payload: {
        entity: entity
      },
      meta: finalMeta
    });
  };
}
/**
 * Delete an entity. On completion reducer will remove item from state.
 */


function deleteEntity(entity) {
  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (dispatch) {
    // validateEntityInstance(entity);
    var _entity$$modelDefinit2 = entity[_Model.$modelDefinition],
        stateKey = _entity$$modelDefinit2.stateKey,
        endpoint = _entity$$modelDefinit2.endpoint; // NOTE: to be consistent with other methods there really should be a
    // 'options' param to this function... hard to add now because of backwards
    // compatibility

    var fetchOptions = meta.fetchOptions,
        headers = meta.headers,
        restMeta = (0, _objectWithoutProperties2["default"])(meta, ["fetchOptions", "headers"]);
    var finalMeta = (0, _objectSpread2["default"])({}, restMeta, {
      stateKey: stateKey,
      entity: entity
    });
    (0, _invariant["default"])(entity.getId() != null, "You called deleteEntity for entity name '".concat(stateKey, "' with entity ") + "that has no 'id' field set. This is required.");
    return dispatch((0, _api.del)("".concat(endpoint, "/").concat(entity.getId(), "/"), queryParams, {
      headers: headers,
      fetchOptions: fetchOptions,
      requestType: {
        type: actionTypes.deleteStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes["delete"],
        payload: {
          id: entity.getId()
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.deleteFailure,
        meta: finalMeta
      }
    })).then(function (_ref9) {
      var payload = _ref9.payload,
          error = _ref9.error;

      if (error) {
        // This will be an ApiError object from redux-api-middleware
        throw payload;
      }

      return payload;
    });
  };
}
/**
 * Helper to perform a request on a particular detail route for an entity, eg.
 * /todos/123/reorder
 * The response from the server should contain entities that can be normalized
 * according to singleEntitySchema. eg. Patching /todos/123/reorder could reorder
 * items and the response might be all todo's that had their sortKey updated
 * @param method {String} one of post, patch, get
 * @param entityName {String} name of entity
 * @param singleEntitySchema {Schema} schema for entity
 * @param entity {Object} instance of entity; should have id field
 * @param uri {String} uri to be appended after entities URI (eg. 'reorder' in example above)
 * @param data {?Object} data to be passed through to endpoint
 * @returns {*}
 */


function customDetailRoute(method, entity, uri) {
  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  return function (dispatch, getState) {
    // validateEntityInstance(entity);
    var _entity$$modelDefinit3 = entity[_Model.$modelDefinition],
        stateKey = _entity$$modelDefinit3.stateKey,
        endpoint = _entity$$modelDefinit3.endpoint; // NOTE: to be consistent with other methods there really should be a
    // 'options' param to this function... hard to add now because of backwards
    // compatibility

    var fetchOptions = meta.fetchOptions,
        headers = meta.headers,
        restMeta = (0, _objectWithoutProperties2["default"])(meta, ["fetchOptions", "headers"]);
    (0, _invariant["default"])(entity.getId() != null, "You called customDetailRoute for entity name '".concat(stateKey, "' with entity ") + "that has no 'id' field set. This is required.");
    var methodFn = apiMethods[method];
    (0, _invariant["default"])(methodFn, "".concat(method, " is not a valid method. Should be one of ").concat(Object.keys(apiMethods).join(', ')));
    var finalMeta = (0, _objectSpread2["default"])({}, restMeta, {
      stateKey: stateKey,
      entity: entity,
      patchEntityUri: uri
    });
    var url = "".concat(endpoint, "/").concat(entity.getId(), "/").concat(uri, "/");
    var selectors = entity.constructor.selectors;
    return dispatch(methodFn(url, data, {
      fetchOptions: fetchOptions,
      headers: headers,
      requestType: {
        type: actionTypes.customDetailStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes.customDetail,
        payload: function payload(action, state, response) {
          return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
            return normalizeResponseData(entity, json);
          });
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.customDetailFailure,
        meta: finalMeta
      }
    })).then(function (_ref10) {
      var payload = _ref10.payload,
          error = _ref10.error;

      if (error) {
        // This will be an ApiError object from redux-api-middleware
        return Promise.reject(payload);
      }

      var record = selectors.synced(getState()).get(entity.getId());

      if (!record) {
        console.warn("Expected response to contain updated record but it did not. If the record did update on the backend your local cache is now out of sync.");
        return payload;
      }

      return (0, _objectSpread2["default"])({}, payload, {
        record: record
      });
      return payload;
    });
  };
}

function customListRoute(method, entity, uri) {
  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  return function (dispatch) {
    // validateEntityInstance(entity);
    var _entity$$modelDefinit4 = entity[_Model.$modelDefinition],
        stateKey = _entity$$modelDefinit4.stateKey,
        endpoint = _entity$$modelDefinit4.endpoint; // NOTE: to be consistent with other methods there really should be a
    // 'options' param to this function... hard to add now because of backwards
    // compatibility

    var fetchOptions = meta.fetchOptions,
        headers = meta.headers,
        restMeta = (0, _objectWithoutProperties2["default"])(meta, ["fetchOptions", "headers"]);
    var methodFn = apiMethods[method];
    (0, _invariant["default"])(methodFn, "".concat(method, " is not a valid method. Should be one of ").concat(Object.keys(apiMethods).join(', ')));
    var finalMeta = (0, _objectSpread2["default"])({}, restMeta, {
      stateKey: stateKey,
      entity: entity
    });
    var url = "".concat(endpoint, "/").concat(uri, "/");
    return dispatch(methodFn(url, data, {
      headers: headers,
      fetchOptions: fetchOptions,
      requestType: {
        type: actionTypes.customListStart,
        meta: finalMeta
      },
      successType: {
        type: actionTypes.customList,
        payload: function payload(action, state, response) {
          // There's no way to know what the page / pageSize was
          // apart from extracting it from the data we pass to the
          // backend.
          // TODO: This is fragile in that if the backend defaults
          // don't match our defaults and page/pageSize aren't explicitly
          // passed then things won't match.... but backwards compat :(
          var _ref11 = data || {},
              page = _ref11.page,
              pageSize = _ref11.pageSize;

          return (0, _reduxApiMiddleware.getJSON)(response).then(function (json) {
            return normalizeResponseData(entity, json, {
              page: page,
              pageSize: pageSize
            });
          });
        },
        meta: finalMeta
      },
      failureType: {
        type: actionTypes.customListFailure,
        meta: finalMeta
      }
    })).then(function (_ref12) {
      var payload = _ref12.payload,
          error = _ref12.error;

      if (error) {
        // This will be an ApiError object from redux-api-middleware
        return Promise.reject(payload);
      }

      return payload;
    });
  };
}
/**
 * Reorder an entity locally
 * @param entity {ModelRecord} the entity to move
 * @param withRespectTo {ModelRecord|Object} either another entity to re-order
 * against OR an object that specifies values for all fields in the models
 * orderWithRespectTo field list. You typically use ModelRecord if you have a
 * record to re-order against and the Object notation if you are moving an entity
 * to a new 'list'. The default behaviour when a ModelRecord is specified is to
 * swap positions if adjacent and otherwise move adjacent to withRespectTo
 * with the minimum amount of changes. eg.
 *   [1, 2, 3, 4]
 * Re-ordering 1 and 3 would result in: [2, 1, 3, 4]
 * Re-ordering 1 and 2 would result in the same.
 * Re-ordering 4 and 3 would result in: [1, 2, 4, 3]
 * Re-ordering 4 and 2 would result in the same.
 * To change the default behaviour you can specifiy insertAfter or insertBefore.
 * You should rarely need this and keep in mind it would sometime result in NO
 * change.
 * When re-ordering using an object of field values the default behaviour is
 * to add it to the end of the list. To change this behaviour supply the
 * insertStart option.
 * @param options {Object}
 * @param options.insertAfter {Boolean = false} only relevant if withRespectTo is a
 * ModelRecord. Force entity to be inserted after withRespectTo if true.
 * @param options.insertBefore {Boolean = false} only relevant if withRespectTo is a
 * ModelRecord. Force entity to be inserted before withRespectTo if true.
 * @param options.insertStart {Boolean = false} only relevant if withRespectTo is a
 * Object of field values. Force entity to be inserted at start of 'list'.
 * NOTE: You MUST save the entity manually when ready, ie. all changes here
 * are only local. This is because you can have lots of changes when dragging
 * which you wouldn't want to save in most situations (would trigger lots of
 * changes as entities get new sort keys and also trigger updates on other
 * connected clients for live updates)
 */


function reorderEntity(entity, withRespectTo) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var payload = {
    entity: entity,
    withRespectTo: withRespectTo
  };
  var orderedModel = entity[_Model.$modelDefinition].orderedModel;
  (0, _invariant["default"])(orderedModel, 'You can only call reorderEntity on a model class ' + 'that was created with the orderedModel option');

  if ((0, _Model.isModel)(withRespectTo)) {
    (0, _invariant["default"])(entity.prototype === withRespectTo.prototype, 'Entity and item to order against should be of same type');
    var _options$insertAfter = options.insertAfter,
        insertAfter = _options$insertAfter === void 0 ? false : _options$insertAfter,
        _options$insertBefore = options.insertBefore,
        insertBefore = _options$insertBefore === void 0 ? false : _options$insertBefore;
    (0, _invariant["default"])(!(insertAfter && insertBefore), 'insertAfter and insertBefore cannot both be true');
    payload = (0, _objectSpread2["default"])({}, payload, {
      insertAfter: insertAfter,
      insertBefore: insertBefore
    });
  } else {
    var orderWithRespectTo = orderedModel.orderWithRespectTo;
    (0, _invariant["default"])(orderWithRespectTo, 'Calling reorderEntity passing withRespectTo as an object of field values is ' + 'only valid if your model specifies orderedWithRespectTo');
    orderWithRespectTo.forEach(function (fieldName) {
      (0, _invariant["default"])(withRespectTo[fieldName], 'If calling reorderEntity passing withRespectTo as an object of field values ' + "that object must contain all fields: ".concat(orderWithRespectTo.join(', '), " \n") + "Missing: ".concat(fieldName));
    });
    var insertEnd = options.insertEnd;
    var insertStart = options.insertStart;

    if (!insertStart && insertEnd == null) {
      insertEnd = true;
    }

    (0, _invariant["default"])(insertStart ^ insertEnd, 'When calling reorderEntity passing withRespectTo as an object ' + 'you must also specify one of insertStart or insertEnd as true');
    payload = (0, _objectSpread2["default"])({}, payload, {
      insertStart: insertStart,
      insertEnd: insertEnd
    });
  }

  return {
    type: actionTypes.reorder,
    payload: payload
  };
}

/**
 * Helper to get re-order payload used for syncing to server
 * @param entity {ModelRecord} entity to fetch re-order data for
 * @param {Object} object containing either reorderRelativeTo
 */
function getReorderPayload(state, entity) {
  // First re-fetch entity in case an old version is being used
  var path = (0, _util.getRecordPath)(state, entity);
  (0, _invariant["default"])(path, 'Could not find entity'); // Root state is just an object, not immutable so fetch entities root

  var entitiesRoot = state[path.shift()]; // ... which is immutable so can use getIn

  entity = entitiesRoot.getIn(path); // eslint-disable-line
  // Will be null if not ordered with respect to anything

  var groupKey = entity.getOrderWithRespectToValue();
  var entities;

  if (groupKey) {
    entities = entity.constructor.selectors.groupedByOrderWithRespectTo(state).get(groupKey);

    if (!entities || entities.size === 1) {
      // Only exists by itself (or not at all) - just specify the group
      // data as it's the only item in the group
      return groupKey;
    }
  } else {
    var orderedModel = entity[_Model.$modelDefinition].orderedModel;
    entities = entitiesRoot.getIn(path.slice(0, -1)).toList().sortBy(function (entity) {
      return entity.get(orderedModel.orderFieldName);
    });
  } // Otherwise find the item it's relative to


  var list = entities.toList();
  var index = list.findIndex(function (record) {
    return record.modelUUID === entity.modelUUID;
  });

  if (index === -1) {
    if (groupKey) {
      return groupKey;
    }

    return {
      reorderRelativeTo: list.last().getId(),
      insertAfter: true
    };
  }

  if (index === 0) {
    return {
      reorderRelativeTo: list.get(1).getId()
    };
  }

  return {
    reorderRelativeTo: list.get(index - 1).getId(),
    insertAfter: true
  };
}

function updateEntityOrdering(entity) {
  return function (dispatch, getState) {
    var data = getReorderPayload(getState(), entity);
    return dispatch(customDetailRoute('patch', entity, 'reorder', data));
  };
}

function updateOptimistic(entity, data) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var stateKey = entity[_Model.$modelDefinition].stateKey;
  var finalMeta = (0, _objectSpread2["default"])({}, meta, {
    entity: entity,
    stateKey: stateKey
  });
  (0, _invariant["default"])(entity.getId() != null, "You called updateEntity for state key '".concat(stateKey, "' with entity ") + "instance that has no 'id' field set. This is required.");
  var selectors = entity.constructor.selectors;
  return function (dispatch, getState) {
    var undoOptimistic;

    var optimisticId = _uid["default"].v4();

    finalMeta.optimisticId = optimisticId;
    var existingEntity = selectors.entities(getState()).getIn([stateKey, 'synced', entity.getId()]);

    undoOptimistic = function undoOptimistic() {
      dispatch({
        type: actionTypes.updateOptimisticUndo,
        meta: finalMeta,
        payload: {
          entity: existingEntity,
          data: data
        }
      });
    };

    dispatch({
      type: actionTypes.updateOptimistic,
      meta: finalMeta,
      payload: {
        entity: entity,
        data: data
      }
    });
    return {
      optimisticId: optimisticId,
      undoOptimistic: undoOptimistic
    };
  };
}