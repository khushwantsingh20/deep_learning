"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringify = stringify;
exports["default"] = createReducer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _typedImmutable = require("typed-immutable");

var _invariant = _interopRequireDefault(require("invariant"));

var _lodash = _interopRequireDefault(require("lodash.isplainobject"));

function isValidStateObject(state) {
  return state instanceof _typedImmutable.Record || state instanceof _typedImmutable.List || state instanceof _typedImmutable.Map;
} // Helper to get a nice plain text description of a object for debugging


function stringify(obj) {
  if ((0, _lodash["default"])(obj)) {
    return 'plain object';
  }

  if (obj && obj.constructor && obj.constructor.prototype[_typedImmutable.Typed.label]) {
    return obj.constructor.prototype[_typedImmutable.Typed.label];
  }

  if (obj && obj.prototype && obj.prototype[_typedImmutable.Typed.label]) {
    return obj.prototype[_typedImmutable.Typed.label];
  }

  if (obj.constructor.name) {
    return obj.constructor.name;
  }

  if ((0, _typeof2["default"])(obj) == 'object' && obj.toString) {
    return obj.toString();
  }

  return obj;
}
/**
 * Helper to create a Redux reducer function that enables you to write a
 * reducer that provides an object who's keys are the actions it knows how to
 * handle. If key isn't handled it returns current state.
 *
 * Also checks returned state is immutable and handles converting plain JS
 * object state into immutable instance.
 * @param {Record} stateConstructor this should be a typed-immutable Record.
 * It can optionally be null if you are attaching a reducer to state object
 * defined by another reducer. For example,
 * {
 *   items: {
 *     products: [],
 *   }
 * }
 * If you had an itemsReducer() that defined the structure of 'items' but wanted
 * to attach another reducer on the 'products' keys then you could set the
 * constructor parameter to null
 * @param {Object} handlers each key is an action constant, value the handler function, eg
 *
 * {
 *    // Defines handler for LOGIN
 *    [ActionTypes.LOGIN](state, action) {
 *      return state.update(....);
 *    }
 * }
 */


function createReducer(constructor, handlers) {
  var transformInitialState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (data) {
    return data;
  };
  var validStateConstructor = constructor;
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    if (validStateConstructor == null) {
      // When constructor is passed as null it is assumed the reducer is
      // attached to a state structure defined by another reducer. In this
      // cases store the type constructor we expect all returned types to
      // be so we can validate it below.
      validStateConstructor = state.constructor;
    }

    var handler = handlers[action.type];
    var currentState = state;

    if (state == null) {
      (0, _invariant["default"])(constructor, 'You must provide a constructor if this is a reducer ' + 'that defines the state shape'); // Provide initial state

      currentState = new constructor(); // TODO: Allow List & Map as well. Need to get Map support into
      // typed-immutable see https://github.com/Gozala/typed-immutable/pull/19

      (0, _invariant["default"])(isValidStateObject(currentState), 'Initial state for a reducer must be an typed-immutable Record.');
    }

    if (!isValidStateObject(currentState)) {
      (0, _invariant["default"])(constructor, 'You must provide a constructor if this is a reducer ' + 'that defines the state shape'); // This handles initial data passed to configureStore() as a plain JS object. This is
      // useful for populating client side data from the server. See main.js for how this
      // is handled (window.__INITIAL_STATE__)

      currentState = new constructor(transformInitialState(currentState));
    }

    if (!handler) {
      return currentState;
    }

    var nextState = handler(currentState, action);
    (0, _invariant["default"])(nextState != null, "Reducer returned ".concat(nextState === null ? 'null' : 'undefined', ". ") + "Did you forget to return for reducer handling action '".concat(action.type, "'?")); // Do relaxed check on constructor to help catch issues where you return the wrong
    // thing.

    var looksLikeSameConstructor = nextState instanceof validStateConstructor || stringify(nextState) === stringify(validStateConstructor);

    if (!looksLikeSameConstructor) {
      throw new Error('Reducers must return instance of provided stateConstructor. Using immutable ' + 'make sure you are returning the root state object for where your reducer is ' + 'attached and not some child descendant or other value. \n\n' + "eg. if you have a child called 'items' which is a list then doing this: \n\n" + '  return state.items.push(5)\n\n' + 'will return a new list with 5 pushed on rather than a new instance of your ' + "state with new value appended to 'items'. What you want is: \n\n" + '  return state.update(items, items => items.push(5));\n\n' + 'We expected an instance of ' + "".concat(stringify(validStateConstructor), " but instead got ").concat(stringify(nextState)));
    }

    return nextState;
  };
}