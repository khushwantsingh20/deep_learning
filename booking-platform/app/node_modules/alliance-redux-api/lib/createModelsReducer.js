"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createModelsReducer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var Immutable = _interopRequireWildcard(require("immutable"));

var _typedImmutable = require("typed-immutable");

var _invariant = _interopRequireDefault(require("invariant"));

var _reselect = require("reselect");

var _fromPairs = _interopRequireDefault(require("lodash/fromPairs"));

var _get3 = _interopRequireDefault(require("lodash/get"));

var _memoize = _interopRequireDefault(require("lodash/memoize"));

var _uid = _interopRequireDefault(require("./uid"));

var _normalize2 = _interopRequireDefault(require("./normalize"));

var _createReducer = _interopRequireWildcard(require("./createReducer"));

var _reduceReducers = _interopRequireDefault(require("./reduceReducers"));

var _createModelReducer = _interopRequireWildcard(require("./createModelReducer"));

var _createLoadingReducer = _interopRequireDefault(require("./createLoadingReducer"));

var _Model = require("./Model");

var _modelReducerHandlers = _interopRequireWildcard(require("./modelReducerHandlers"));

var uuidLength = _uid["default"].v4().length;

var $isRootEntitiesState = Symbol["for"]('@alliance-redux-api/rootEntitiesState');
/**
 * Create final models reducer.
 *
 * @param {...ModelRecord|Function} either a ModelRecord (a record created using
 * Model) or a reducer create with createModelReducer.
 */

function createModelsReducer(modelReducers) {
  var entitiesStateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['Entities'];

  if (!Array.isArray(entitiesStateKey)) {
    var _entitiesStateKey = [_entitiesStateKey];
  }

  var stateStructure = {};
  var modelRecordsByKey = {};
  var individualModelReducers = modelReducers.map(function (reducer) {
    if (reducer[_Model.$modelDefinition]) {
      reducer = (0, _createModelReducer["default"])(reducer); // eslint-disable-line
    }

    var definition = reducer[_createModelReducer.$modelReducerDefinition];
    (0, _invariant["default"])(definition, 'All reducers passed to createModelsReducer must be created ' + "with createModelReducer. Invalid reducer received: ".concat((0, _createReducer.stringify)(reducer)));
    (0, _invariant["default"])(!stateStructure[definition.stateKey], "Same state key used for 2 Model classes: ".concat(definition.stateKey));
    stateStructure[definition.stateKey] = definition.modelStateRecord;
    modelRecordsByKey[definition.stateKey] = definition.modelRecord;
    return [definition.stateKey, reducer];
  }); // Allow selectors to work from Entities root rather than just state root

  var rootSelector = function rootSelector(state) {
    (0, _invariant["default"])(state && state.constructor, 'Invalid state object passed to rootSelector');

    if (state.constructor && state.constructor[$isRootEntitiesState]) {
      return state;
    }

    return (0, _get3["default"])(state, entitiesStateKey);
  };

  Object.keys(modelRecordsByKey).forEach(function (key) {
    var record = modelRecordsByKey[key];
    var _record$$modelDefinit = record[_Model.$modelDefinition],
        stateKey = _record$$modelDefinit.stateKey,
        orderedModel = _record$$modelDefinit.orderedModel,
        structure = _record$$modelDefinit.structure,
        idFieldName = _record$$modelDefinit.idFieldName,
        IdType = _record$$modelDefinit.IdType,
        _record$$modelDefinit2 = _record$$modelDefinit.sortBy,
        sortBy = _record$$modelDefinit2 === void 0 ? function (entity) {
      return orderedModel ? entity.get(orderedModel.orderFieldName) : entity.getId();
    } : _record$$modelDefinit2; // This is so we can avoid hardcoding the base state key everywhere
    // Allows things to look it up on model

    record[_Model.$modelDefinition].getFullStateKeyPath = function () {
      return [].concat((0, _toConsumableArray2["default"])(entitiesStateKey), [stateKey]);
    };

    record[_Model.$modelDefinition].partialRecordClass[_Model.$modelDefinition].getFullStateKeyPath = record[_Model.$modelDefinition].getFullStateKeyPath;
    var entitySelector = (0, _reselect.createSelector)(rootSelector, function (entities) {
      return entities.get(key);
    });

    function replaceGetWithTypedGet(mapInstance) {
      // Replace get() so it has same behaviour as typed immutable Map
      // in converting the value of the key if required.
      // This is particularly useful in converting "325" => 325
      var originalGet = mapInstance.get.bind(mapInstance);

      mapInstance.get = function (key) {
        var convertedKey = key; // Hacky workaround so that items in 'local' - which are indexed
        // by uuid - don't go through the id field read fn.

        if (typeof key == 'string' && key.length !== uuidLength) {
          convertedKey = (0, _typedImmutable.typeOf)(IdType)[_typedImmutable.Typed.read](key);
        }

        return originalGet(convertedKey);
      };

      return mapInstance;
    }

    var synced = (0, _reselect.createSelector)(entitySelector, function (s) {
      return replaceGetWithTypedGet(s.synced.sortBy(sortBy));
    });
    var local = (0, _reselect.createSelector)(entitySelector, function (s) {
      return replaceGetWithTypedGet(s.local.sortBy(sortBy));
    });
    var loading = (0, _reselect.createSelector)(entitySelector, function (s) {
      return s.loading;
    });
    var partialRecordsSynced = (0, _reselect.createSelector)(entitySelector, function (s) {
      return s.partialRecords.synced;
    });
    var partialRecordsLocal = (0, _reselect.createSelector)(entitySelector, function (s) {
      return s.partialRecords.local;
    });

    var getPartialState = function getPartialState(fields, state) {
      var invalidFields = fields.filter(function (fieldName) {
        return !(fieldName in structure);
      });

      if (invalidFields.length > 0) {
        throw new Error("Some field(s) passed to partialFields selector are not valid: ".concat(invalidFields.join(', ')));
      }

      var idFieldNames = [].concat(idFieldName);
      var fieldsNoId = fields.filter(function (fieldName) {
        return !idFieldNames.includes(fieldName);
      });
      var fieldsWithId = [].concat((0, _toConsumableArray2["default"])(fieldsNoId), (0, _toConsumableArray2["default"])(idFieldNames)); // For historical reasons we support with or without the id field name(s) - they are equivalent. We always
      // have id even if not explicitly specified so we are guaranteed to always have this data.

      var key1 = new Immutable.Set(fieldsNoId);
      var key2 = new Immutable.Set(fieldsWithId);
      return state.get(key1) || state.get(key2);
    };

    var buildPartialSelector = function buildPartialSelector(partialKeySelector) {
      return (0, _reselect.createSelector)(partialKeySelector, function (state) {
        return (0, _memoize["default"])(function (fields) {
          var values = getPartialState(fields, state);

          if (!values) {
            return new Immutable.OrderedMap();
          }

          return replaceGetWithTypedGet(values.sortBy(sortBy));
        }, function (fields) {
          return fields.toString();
        });
      });
    };

    var partialFields = {
      local: buildPartialSelector(partialRecordsLocal),
      synced: buildPartialSelector(partialRecordsSynced)
    };
    partialFields.all = (0, _reselect.createSelector)([partialRecordsSynced, partialRecordsLocal], function (local, synced) {
      return (0, _memoize["default"])(function (fields) {
        var a = getPartialState(fields, local);
        var b = getPartialState(fields, synced);

        if (!a && !b) {
          return new Immutable.OrderedMap();
        }

        if (!b) return replaceGetWithTypedGet(a.toMap().sortBy(sortBy));
        if (!a) return replaceGetWithTypedGet(b.toMap().sortBy(sortBy));
        return replaceGetWithTypedGet(a.toMap().merge(b).sortBy(sortBy));
      }, function (fields) {
        return fields.toString();
      });
    });
    var all = (0, _reselect.createSelector)([synced, local], function (a, b) {
      // NOTE: This results in a plain typed immutable OrderedMap
      return replaceGetWithTypedGet(a.toMap().merge(b).sortBy(sortBy));
    });
    var meta = (0, _reselect.createSelector)(entitySelector, function (s) {
      return s.meta;
    });
    var syncingEntityUUIDs = (0, _reselect.createSelector)(loading, function (l) {
      return l.syncingEntityUUIDs;
    });
    var isFetching = (0, _reselect.createSelector)(loading, function (l) {
      return l.isFetching;
    });

    var groupedByOrderWithRespectTo = function groupedByOrderWithRespectTo() {
      throw new Error('Model is not ordered or has no orderWithRespectTo fields set');
    };

    if (orderedModel && orderedModel.orderWithRespectTo) {
      var keyStructure = {};
      orderedModel.orderWithRespectTo.forEach(function (fieldName) {
        keyStructure[fieldName] = structure[fieldName];
      });
      var keyRecord = (0, _typedImmutable.Record)(keyStructure, "".concat(key, " Order By Key")); // We use Any here rather than a TypedMap(IdType, record) so that
      // we can apply sorting and return an OrderedMap (see groupBy below)

      var GroupedEntitiesMap =
      /*#__PURE__*/
      function (_TypedMap) {
        (0, _inherits2["default"])(GroupedEntitiesMap, _TypedMap);

        function GroupedEntitiesMap() {
          (0, _classCallCheck2["default"])(this, GroupedEntitiesMap);
          return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(GroupedEntitiesMap).apply(this, arguments));
        }

        (0, _createClass2["default"])(GroupedEntitiesMap, [{
          key: "get",
          value: function get(keyData) {
            return (0, _get2["default"])((0, _getPrototypeOf2["default"])(GroupedEntitiesMap.prototype), "get", this).call(this, new keyRecord(keyData));
          }
        }]);
        return GroupedEntitiesMap;
      }((0, _typedImmutable.Map)(keyRecord, _typedImmutable.Any));

      groupedByOrderWithRespectTo = (0, _reselect.createSelector)(all, function (entities) {
        return new GroupedEntitiesMap(entities.groupBy(function (entity) {
          return new keyRecord((0, _fromPairs["default"])(orderedModel.orderWithRespectTo.map(function (fieldName) {
            return [fieldName, entity.get(fieldName)];
          })));
        }).map(function (groupedEntities) {
          return groupedEntities.sortBy(function (groupedEntity) {
            return groupedEntity.get(orderedModel.orderFieldName);
          });
        }));
      });
    }

    var selectors = {
      synced: synced,
      local: local,
      all: all,
      partialFields: partialFields,
      meta: meta,
      loading: loading,
      isFetching: isFetching,
      syncingEntityUUIDs: syncingEntityUUIDs,
      groupedByOrderWithRespectTo: groupedByOrderWithRespectTo,
      entities: rootSelector
    };

    if (record.buildSelectors) {
      var additionalSelectors = record.buildSelectors(selectors);
      (0, _invariant["default"])(additionalSelectors && (0, _typeof2["default"])(additionalSelectors) == 'object', 'buildSelectors must return an object of selector name => selector');
      Object.assign(selectors, additionalSelectors);
    }

    record.selectors = record[_Model.$modelDefinition].partialRecordClass.selectors = selectors;
  });
  var EntityState = (0, _typedImmutable.Record)(stateStructure, 'Entities');
  EntityState[$isRootEntitiesState] = true;
  var reducer = (0, _createReducer["default"])(EntityState, _modelReducerHandlers["default"], function (initialState) {
    // This function is only called once when initial data is populate from server
    // Transform each provided entity using normalize
    var transformedData = new EntityState();

    for (var _i = 0, _Object$keys = Object.keys(initialState); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var recordClass = modelRecordsByKey[key];

      if (!recordClass) {
        console.warn( // eslint-disable-line
        "Unexpected entity key '".concat(key, "' in initial state. Is there a typo?"));
        continue;
      }

      var _normalize = (0, _normalize2["default"])(recordClass, initialState[key]),
          entities = _normalize.entities;

      transformedData = (0, _modelReducerHandlers.entitiesPayloadStateTransition)(transformedData, {
        payload: {
          entities: entities
        }
      });
    }

    return transformedData;
  });
  return _reduceReducers["default"].apply(void 0, [reducer].concat((0, _toConsumableArray2["default"])(individualModelReducers), [(0, _createLoadingReducer["default"])()]));
}