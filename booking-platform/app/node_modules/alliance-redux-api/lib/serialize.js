"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeModelData = serializeModelData;
exports.serializeValue = serializeValue;
exports.serializeFields = serializeFields;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var Immutable = _interopRequireWildcard(require("immutable"));

var _typedImmutable = require("typed-immutable");

var _util = require("./util");

var _Model = require("./Model");

var _Field = require("./Field");

/**
 * Serialize supplied data according to the field definitions on modelClass
 * This respects custom fields that supply a serialize method (see Field.js)
 */
function serializeModelData(modelClass, data) {
  // $FlowFixMe
  var modelFieldDefinitions = modelClass[_Model.$modelDefinition].structure;

  if (Immutable.Iterable.isIterable(data)) {
    // $FlowFixMe
    data = data.toJS();
  }

  return Object.keys(data).reduce(function (acc, fieldName) {
    var fieldDef = modelFieldDefinitions[fieldName]; // $FlowFixMe: guaranteed to be JS object now due to data.toJS above

    var value = data[fieldName];
    value = fieldDef ? serializeValue(value, fieldDef) : value; // undefined indicates no value and we shouldn't include it in the data at all
    // null could indicate the value was removed or explicitly set to no-value - we
    // need to keep this (eg. un-setting a nullable value after it was set)

    if (value !== undefined) {
      acc[fieldName] = value;
    }

    return acc;
  }, {});
}

function getConcreteType(type) {
  if (type && (0, _typeof2["default"])(type) == 'object' && (0, _util.isMaybeType)(type) && type[_typedImmutable.Typed.type]) {
    return type[_typedImmutable.Typed.type];
  }

  return type;
}

function serializeValue(value, fieldDef) {
  if (value == null) {
    return value;
  }

  if (fieldDef[_Field.$serialize]) {
    return fieldDef[_Field.$serialize](value);
  }

  var concreteFieldDef = getConcreteType(fieldDef);

  if (concreteFieldDef[_Field.$serialize]) {
    return concreteFieldDef[_Field.$serialize](value);
  }

  if ((0, _Model.isModelInstance)(value)) {
    return value.serialize();
  }

  if ((0, _Model.isModel)(concreteFieldDef)) {
    var modelFieldDefinitions = concreteFieldDef[_Model.$modelDefinition].structure;
    return serializeFields(value, modelFieldDefinitions);
  }

  if ((0, _util.isRecordType)(concreteFieldDef)) {
    return serializeFields(value, concreteFieldDef[_typedImmutable.Typed.type]);
  }

  if (Array.isArray(value) || value && (0, _typeof2["default"])(value) === 'object' && Immutable.Iterable.isIterable(value)) {
    if ((0, _util.isListType)(concreteFieldDef)) {
      concreteFieldDef = (0, _util.getListElementType)(concreteFieldDef);
    }

    var iterableValues = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;
        iterableValues.push(serializeValue(v, concreteFieldDef));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return iterableValues;
  }

  return value;
}

function serializeFields(source, fieldDefs) {
  var data = {};
  Object.keys(fieldDefs).forEach(function (key) {
    var value = source[key];
    var fieldDef = fieldDefs[key];
    value = serializeValue(value, fieldDef);

    if (value != null) {
      data[key] = value;
    }
  });
  return data;
}