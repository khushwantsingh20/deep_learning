"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = initialiseLiveUpdater;

var _reconnectingWebsocket = _interopRequireDefault(require("reconnecting-websocket"));

var _Model = require("./Model");

var _normalize = _interopRequireDefault(require("./normalize"));

var _actions = require("./actions");

var _api = require("./api");

/**
 * Initialise live updates for entities.
 *
 * This works with django-channels on the backend. For any model you want
 * live updates on you need to create a 'Binding' class
 * (eg. forward_planning.models.WeekAllocationBinding) that defines that model,
 * serializer class and permissions required to receive updates on entities.
 * That will start triggering changes that you can observer in the network
 * panel (click on the WS tab and inspect each frame that comes through)
 *
 * On the frontend you need to opt a record into live updates by specifying
 * the model it maps to on the backend - this is the model label string
 * that you will see in the payload sent from the backend. Specify this with
 * the 'liveUpdateModel' option in the call to Model():
 *
 *   import Model from 'alliance-redux-api/Model';
 *   const TodoRecord = Model({
 *     // ... specify fields as normal
 *   }, 'todos', 'Todo Items', { liveUpdateModel: 'dashboard.todo' });
 *
 * Once this is done redux store should update live when any model changes
 * are triggered on the backend. Note that a client will ignore any model
 * changes that are triggered by them to avoid applying the same change twice.
 *
 * @param {Object} store redux store - used to dispatch actions based on
 * updates received from the server
 */
function initialiseLiveUpdater(store) {
  var host = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.host;
  var wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
  var socket = new _reconnectingWebsocket["default"]("".concat(wsScheme, "://").concat(host));

  socket.onmessage = function (event) {
    var message = JSON.parse(event.data);

    if (!message) {
      console.warn( // eslint-disable-line
      'Received invalid json string in message', message);
      return;
    }

    var stream = message.stream,
        payload = message.payload;

    if (stream !== 'model_updates') {
      return;
    }

    if (!payload.action) {
      console.warn( // eslint-disable-line
      'Expected action field in data', payload);
      return;
    }

    var action = payload.action,
        clientId = payload.clientId,
        data = payload.data,
        model = payload.model; // This client triggered this message so ignore it

    if (clientId === _api.CLIENT_UID) {
      return;
    }

    var entityRecord = _Model.liveUpdateModels[model];

    if (!entityRecord) {
      if (__DEBUG__) {
        console.warn( // eslint-disable-line
        "Received live updates for '".concat(model, "' but no record is registered ") + "for that. Make sure the 'liveUpdateModel' option is set to '".concat(model, "'") + 'on the relevant call to Model(). We know about the ' + "following models: ".concat(Object.keys(_Model.liveUpdateModels).join(', ')), message);
      }

      return;
    }

    var stateKey = entityRecord[_Model.$modelDefinition].stateKey;
    var meta = {
      stateKey: stateKey,
      liveUpdate: true
    };

    switch (action) {
      case 'update':
        {
          store.dispatch({
            type: _actions.actionTypes.update,
            payload: (0, _normalize["default"])(entityRecord, data),
            meta: meta
          });
          break;
        }

      case 'create':
        {
          store.dispatch({
            type: _actions.actionTypes.add,
            payload: (0, _normalize["default"])(entityRecord, data),
            meta: meta
          });
          break;
        }

      case 'bulk_update':
      case 'bulk_create':
        {
          store.dispatch({
            type: _actions.actionTypes.fetch,
            payload: (0, _normalize["default"])(entityRecord, data),
            meta: meta
          });
          break;
        }

      case 'delete':
        {
          store.dispatch({
            type: _actions.actionTypes["delete"],
            payload: data,
            meta: meta
          });
          break;
        }

      default:
        console.warn( // eslint-disable-line
        "Received unknown live update action ".concat(action), message);
    }

    _Model.liveUpdateListeners.forEach(function (fn) {
      return fn(entityRecord, payload, store);
    });
  };
}