"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findRecordEntryIn = findRecordEntryIn;
exports.getRecordPath = getRecordPath;
exports.isMaybeType = isMaybeType;
exports.isListType = isListType;
exports.getListElementType = getListElementType;
exports.isRecordType = isRecordType;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _immutable = _interopRequireDefault(require("immutable"));

var _typedImmutable = require("typed-immutable");

var _get = _interopRequireDefault(require("lodash/get"));

var _invariant = _interopRequireDefault(require("invariant"));

var _Model = require("./Model");

/**
 * In an immutable collection find a record
 * @param collection {Immutable.}
 * @param {undefined|[key, value]}
 */
function findRecordEntryIn(collection, record) {
  (0, _invariant["default"])((0, _Model.isModel)(record), 'findRecordEntryIn can only be used on records defined with the Model function');
  return collection.findEntry(function (value) {
    return (// Same object
      value === record || // Compare UID that's generated for each entity
      value.get('modelUUID') === record.get('modelUUID') || // Otherwise the entity ID itself
      value.getId() && value.getId() === record.getId()
    );
  });
}
/**
 * For a given record get the path to that record in the state.
 * Handles both local and sync'd items.
 * @param state {Function|Object} either state object itself or a function that
 * returns state (eg. getState from an action dispatch). State object can be any
 * part of the tree before the entity state. For example, if your state was
 * state = {
 *   Entities: {
 *     articles: { local: ..., synced: ... },
 *   }
 * }
 * You could pass state, state.Entities or state.Entities.articles.
 * @param record {ModelRecord} existing entity record
 * @return {Boolean|Array}
 */


function getRecordPath(state, record) {
  (0, _invariant["default"])((0, _Model.isModel)(record), 'getRecordPath can only be used on records defined with the Model function');
  var _record$$modelDefinit = record[_Model.$modelDefinition],
      stateKey = _record$$modelDefinit.stateKey,
      getFullStateKeyPath = _record$$modelDefinit.getFullStateKeyPath; // Accept getState() functions

  if (typeof state === 'function') {
    state = state(); // eslint-disable-line

    (0, _invariant["default"])(record.constructor.selectors.entities(state), 'You passed a function to getRecordPath but it did not return the expected root ' + 'state (there is no Entities key). You should pass the getState() function from ' + 'an action creator.');
  }

  var path = getFullStateKeyPath();

  while (path.length && !(0, _get["default"])(state, path)) {
    path.shift();
  }

  var entities = path.length ? (0, _get["default"])(state, path) : state;
  (0, _invariant["default"])(entities.synced && entities.local, "Expected one of the root state, the root 'Entities' state or the ".concat(stateKey, " state"));

  if (record[_Model.PARTIAL_FIELDS_KEY_FIELD_NAME]) {
    // This is to handle partial records - we store partial field names on the record itself
    // so we can actually work out where it came from
    var keys = _immutable["default"].Set(record[_Model.PARTIAL_FIELDS_KEY_FIELD_NAME]);

    var partialEntities = entities.partialRecords;

    for (var _i = 0, _arr = ['synced', 'local']; _i < _arr.length; _i++) {
      var type = _arr[_i];
      var match = findRecordEntryIn(partialEntities.getIn([type, keys]), record);

      if (match) {
        return [].concat((0, _toConsumableArray2["default"])(path), ['partialRecords', type, keys, match[0]]);
      }
    }
  } else {
    for (var _i2 = 0, _arr2 = ['synced', 'local']; _i2 < _arr2.length; _i2++) {
      var _type = _arr2[_i2];

      var _match = findRecordEntryIn(entities.get(_type), record);

      if (_match) {
        return [].concat((0, _toConsumableArray2["default"])(path), [_type, _match[0]]);
      }
    }
  }

  return false;
}

function isMaybeType(fieldDef) {
  // No easy way to determine maybe types - only option is to read the typeName
  return !!(fieldDef[_typedImmutable.Typed.typeName] && fieldDef[_typedImmutable.Typed.typeName]().startsWith('Maybe('));
}

function isListType(fieldDef) {
  var a = fieldDef.constructor && fieldDef.constructor.prototype[_typedImmutable.Typed.typeName] && fieldDef.constructor.prototype[_typedImmutable.Typed.typeName]().startsWith('Typed.List(');

  var b = fieldDef.prototype && fieldDef.prototype[_typedImmutable.Typed.typeName] && fieldDef.prototype[_typedImmutable.Typed.typeName]().startsWith('Typed.List(');

  var c = fieldDef[_typedImmutable.Typed.typeSignature] && fieldDef[_typedImmutable.Typed.typeSignature]().startsWith('Typed.List(');

  return a || b || c;
}

function getListElementType(fieldDef) {
  return fieldDef[_typedImmutable.Typed.type] || fieldDef.prototype[_typedImmutable.Typed.type];
}

function isRecordType(fieldDef) {
  return !!(fieldDef[_typedImmutable.Typed.typeSignature] && fieldDef[_typedImmutable.Typed.typeSignature]().startsWith('Typed.Record('));
}