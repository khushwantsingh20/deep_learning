"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isModel = isModel;
exports.isModelInstance = isModelInstance;
exports["default"] = Model;
exports.modelClassMap = exports.liveUpdateListeners = exports.liveUpdateModels = exports.$modelDefinition = exports.PARTIAL_FIELDS_KEY_FIELD_NAME = void 0;

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _invariant = _interopRequireDefault(require("invariant"));

var Immutable = _interopRequireWildcard(require("immutable"));

var _typedImmutable = require("typed-immutable");

var _typed = require("typed-immutable/lib/typed");

var _normalizr = require("normalizr");

var _serialize = require("./serialize");

var _util = require("./util");

var _fetchCache = require("./fetchCache");

var _Field = require("./Field");

var _ForeignKeyField = require("./ForeignKeyField");

var _fieldTypes = require("./fieldTypes");

// This the name of an actual field on any partial record that contains
var PARTIAL_FIELDS_KEY_FIELD_NAME = '@@alliance-redux-api/partialFields';
exports.PARTIAL_FIELDS_KEY_FIELD_NAME = PARTIAL_FIELDS_KEY_FIELD_NAME;
var $modelDefinition = Symbol["for"]('@@alliance-redux-api/model');
exports.$modelDefinition = $modelDefinition;
var $isModel = Symbol["for"]('@@alliance-redux-api/isModel');
var $isModelInstance = Symbol["for"]('@@alliance-redux-api/isModelInstance');
var $schemaAssignEntity = Symbol["for"]('@@alliance-redux-api/schemaAssignEntity');

function isModel(value) {
  return value && ((0, _typeof2["default"])(value) == 'object' || typeof value == 'function') && value[$isModel];
}

function isModelInstance(value) {
  return value && ((0, _typeof2["default"])(value) == 'object' || typeof value == 'function') && value[$isModelInstance];
}

function buildModelSchema(descriptor, schemaName, idFieldName) {
  var fieldParsers = [];
  var assignEntityFieldNameMap = {};
  var idAttribute = idFieldName;

  if (Array.isArray(idFieldName)) {
    // Implementation here must match what ModelRecord.getId specifies
    idAttribute = function idAttribute(entity) {
      // Flow needed this in the arrow func otherwise complained
      if (Array.isArray(idFieldName)) {
        return idFieldName.map(function (fieldName) {
          return entity[fieldName];
        }).join('_');
      }

      return idFieldName;
    };
  }

  var schema = new _normalizr.Schema(schemaName, {
    idAttribute: idAttribute
  });
  var schemaDefinition = {};
  Object.keys(descriptor).forEach(function (key) {
    var field = descriptor[key];

    if (field[_Field.$parse]) {
      fieldParsers.push({
        key: key,
        parse: field[_Field.$parse]
      });
    }

    if (field && field.prototype && field.prototype[_ForeignKeyField.$foreignKey]) {
      var foreignKey = field.prototype[_ForeignKeyField.$foreignKey];
      var _foreignKey$many = foreignKey.many,
          many = _foreignKey$many === void 0 ? false : _foreignKey$many,
          _foreignKey$schemaFie = foreignKey.schemaFieldName,
          schemaFieldName = _foreignKey$schemaFie === void 0 ? key : _foreignKey$schemaFie;
      schemaDefinition[schemaFieldName] = foreignKey.target[$modelDefinition].schema;

      if (many) {
        schemaDefinition[schemaFieldName] = (0, _normalizr.arrayOf)(schemaDefinition[schemaFieldName]);
      }

      if (schemaFieldName !== key) {
        assignEntityFieldNameMap[schemaFieldName] = key;
      }
    }
  });

  function assignEntity(normalized, key, entity, what, entitySchema) {
    // If this is a nested schema defer to its schema assign implementation
    var nestedAssignEntity = entitySchema[$schemaAssignEntity];

    if (nestedAssignEntity && nestedAssignEntity !== assignEntity) {
      nestedAssignEntity(normalized, key, entity, what, entitySchema);
      return;
    }

    if (assignEntityFieldNameMap[key]) {
      var recordFieldName = assignEntityFieldNameMap[key];
      normalized[recordFieldName] = entity; // eslint-disable-line
    } else {
      normalized[key] = entity; // eslint-disable-line
    }
  }

  schema.define(schemaDefinition); // Track assign entity on schema so that we can handle nested foreign
  // keys by deferring to nested schema assignEntity
  // $FlowFixMe

  schema[$schemaAssignEntity] = assignEntity;
  return {
    assignEntity: assignEntity,
    schema: schema,
    fieldParsers: fieldParsers
  };
} // This is added to by Model() if the liveUpdateModel option is specified


var liveUpdateModels = {};
exports.liveUpdateModels = liveUpdateModels;
var liveUpdateListeners = [];
exports.liveUpdateListeners = liveUpdateListeners;
var modelClassMap = {};
/**
 *
 * @param stateKey {String} this is the key this model will appear under in the
 * state tree. Used for two things; creating selectors and for normalizing
 * returned data from API.
 */

exports.modelClassMap = modelClassMap;

function Model( // eslint-disable-line brace-style
descriptor, stateKey, label) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  (0, _invariant["default"])(stateKey, 'stateKey must be provided');
  (0, _invariant["default"])(label, 'Label must be provided.');
  var _options$idFieldName = options.idFieldName,
      idFieldName = _options$idFieldName === void 0 ? 'id' : _options$idFieldName,
      _options$endpoint = options.endpoint,
      endpoint = _options$endpoint === void 0 ? stateKey : _options$endpoint,
      _options$modelId = options.modelId,
      modelId = _options$modelId === void 0 ? stateKey : _options$modelId,
      transformResponse = options.transformResponse,
      liveUpdateModel = options.liveUpdateModel,
      sortBy = options.sortBy,
      liveUpdateListener = options.liveUpdateListener,
      orderedModel = options.orderedModel,
      _options$cache = options.cache,
      cache = _options$cache === void 0 ? new _fetchCache.NoCache() : _options$cache;
  var IdType;

  if (Array.isArray(idFieldName)) {
    var missingFieldNames = [];
    idFieldName.forEach(function (fieldName) {
      if (!descriptor[fieldName]) {
        missingFieldNames.push(fieldName);
      }
    });
    IdType = String;
    (0, _invariant["default"])(missingFieldNames.length === 0, "You specified a compound id for '".concat(label, "' but the following fields were ") + "not found in the model descriptor: ".concat(missingFieldNames.join(', '), "\n") + 'Check for spelling mistakes or missing fields');
  } else {
    (0, _invariant["default"])(descriptor[idFieldName], "Model id field of '".concat(idFieldName, "' not found on descriptor for '").concat(label, "'. ") + "You either need to define a field with that name or provide an 'idFieldName' " + 'option which can be a single field name or a list of field names for compound ids.');
    IdType = descriptor[idFieldName];
  }

  var _buildModelSchema = buildModelSchema(descriptor, stateKey, idFieldName),
      schema = _buildModelSchema.schema,
      fieldParsers = _buildModelSchema.fieldParsers,
      assignEntity = _buildModelSchema.assignEntity;

  var pinnedFieldNames = Immutable.List(Array.isArray(idFieldName) ? idFieldName : [idFieldName]);

  if (orderedModel) {
    pinnedFieldNames = pinnedFieldNames.push(orderedModel.orderFieldName);

    if (orderedModel.orderWithRespectTo) {
      var _pinnedFieldNames;

      pinnedFieldNames = (_pinnedFieldNames = pinnedFieldNames).push.apply(_pinnedFieldNames, (0, _toConsumableArray2["default"])(orderedModel.orderWithRespectTo));
    }
  } // Add a field for tracking unique ID against every model instance


  var structure = Object.assign({}, descriptor, {
    modelUUID: _fieldTypes.UUIDType
  });

  function buildModelRecordClass(structure, label) {
    var ModelRecordClass =
    /*#__PURE__*/
    function (_Record) {
      (0, _inherits2["default"])(ModelRecordClass, _Record);

      function ModelRecordClass(data) {
        (0, _classCallCheck2["default"])(this, ModelRecordClass);
        var transformedData = fieldParsers.reduce(function (acc, _ref) {
          var key = _ref.key,
              parse = _ref.parse;
          return Object.assign(acc, (0, _defineProperty2["default"])({}, key, parse(data[key])));
        }, {});
        return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ModelRecordClass).call(this, Object.assign({}, data, transformedData)));
      }

      (0, _createClass2["default"])(ModelRecordClass, [{
        key: "getId",
        value: function getId() {
          var _this = this;

          if (Array.isArray(idFieldName)) {
            // Implementation here must match what buildModelSchema specifies
            // in the idAttribute function
            return idFieldName.map(function (fieldName) {
              var serialize = descriptor[fieldName][_Field.$serialize];

              var value = _this.get(fieldName);

              if (serialize) {
                return serialize(value);
              }

              return value;
            }).join('_');
          }

          var serialize = descriptor[idFieldName][_Field.$serialize];
          var value = this.get(idFieldName);

          if (serialize) {
            return serialize(value);
          }

          return value;
        }
      }, {
        key: "serialize",
        value: function serialize() {
          return (0, _serialize.serializeFields)(this, descriptor);
        }
      }, {
        key: "isOrderedModel",
        value: function isOrderedModel() {
          return !!orderedModel;
        }
      }, {
        key: "getOrderWithRespectToValue",
        value: function getOrderWithRespectToValue() {
          var _this2 = this;

          if (!orderedModel) {
            throw new Error('getOrderWithRespectToValue is only valid for ' + 'ordered models');
          }

          if (!orderedModel.orderWithRespectTo) {
            return null;
          }

          var value = {};
          orderedModel.orderWithRespectTo.forEach(function (fieldName) {
            value[fieldName] = _this2.get(fieldName);
          });
          return value;
        }
      }], [{
        key: "isOrderedModel",
        value: function isOrderedModel() {
          return !!orderedModel;
        }
      }]);
      return ModelRecordClass;
    }((0, _typedImmutable.Record)(structure, label));

    if (orderedModel) {
      (0, _invariant["default"])(descriptor[orderedModel.orderFieldName] !== undefined, "Specified orderFieldName ".concat(orderedModel.orderFieldName, " does not exist on model"));

      if (orderedModel.orderWithRespectTo) {
        orderedModel.orderWithRespectTo.forEach(function (fieldName) {
          return (0, _invariant["default"])(descriptor[fieldName] !== undefined, "Specified field ".concat(fieldName, " in orderWithRespectTo to does not exist on model"));
        });
      }
    } // $FlowFixMe


    ModelRecordClass[$isModel] = ModelRecordClass.prototype[$isModel] = true;
    ModelRecordClass.prototype[$isModelInstance] = true; // $FlowFixMe

    ModelRecordClass[$modelDefinition] = ModelRecordClass.prototype[$modelDefinition] = {
      structure: structure,
      modelId: modelId,
      cache: cache,
      label: label,
      IdType: IdType,
      stateKey: stateKey,
      idFieldName: idFieldName,
      transformResponse: transformResponse,
      endpoint: endpoint.replace(/\/$/, ''),
      liveUpdateModel: liveUpdateModel,
      sortBy: sortBy,
      liveUpdateListener: liveUpdateListener,
      orderedModel: orderedModel,
      schema: schema,
      schemaOptions: {
        assignEntity: assignEntity
      },
      getFullStateKeyPath: function getFullStateKeyPath() {
        throw new Error('getFullStateKeyPath used before initialized');
      },
      pinnedFieldNames: pinnedFieldNames
    };
    ModelRecordClass.buildSelectors = options.buildSelectors; // This will be replaced when createModelsReducer is run

    ModelRecordClass.selectors = null; // Proxy this to catch common error of creating model but not registering it

    if (typeof Proxy == 'function') {
      ModelRecordClass.selectors = new Proxy({}, {
        get: function get() {
          console.error( // eslint-disable-line
          'You tried to use a selector before the selectors were ' + "created. This probably means you haven't added your " + 'Model to Redux via the createModelsReducer() function. ' + 'See your core/reducers.js or equivalent file. If your selectors ' + 'have interdependencies then order matters - avoid this where ' + 'possible otherwise ensure parameter order to createModelsReducer is ' + 'correct to satisfy these dependencies');
        }
      });
    }

    return ModelRecordClass;
  }

  var ModelRecordClass = buildModelRecordClass(structure, label);
  var partialStructure = Object.keys(structure).reduce(function (acc, fieldName) {
    acc[fieldName] = structure[fieldName];

    if (!(0, _util.isMaybeType)(acc[fieldName]) && (0, _typed.typeOf)(acc[fieldName]) !== _typedImmutable.Any && fieldName !== 'modelUUID') {
      acc[fieldName] = (0, _typedImmutable.Maybe)(acc[fieldName]);
    }

    return acc;
  }, {});
  partialStructure[PARTIAL_FIELDS_KEY_FIELD_NAME] = (0, _typedImmutable.List)(String);

  var PartialModelRecordClass =
  /*#__PURE__*/
  function (_buildModelRecordClas) {
    (0, _inherits2["default"])(PartialModelRecordClass, _buildModelRecordClas);

    function PartialModelRecordClass() {
      (0, _classCallCheck2["default"])(this, PartialModelRecordClass);
      return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PartialModelRecordClass).apply(this, arguments));
    }

    (0, _createClass2["default"])(PartialModelRecordClass, [{
      key: "toJS",
      value: function toJS() {
        var values = (0, _get2["default"])((0, _getPrototypeOf2["default"])(PartialModelRecordClass.prototype), "toJS", this).call(this);
        var finalValues = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = values[PARTIAL_FIELDS_KEY_FIELD_NAME][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var fieldName = _step.value;
            finalValues[fieldName] = values[fieldName];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        pinnedFieldNames.forEach(function (fieldName) {
          finalValues[fieldName] = values[fieldName];
        });
        return finalValues;
      }
    }]);
    return PartialModelRecordClass;
  }(buildModelRecordClass(partialStructure, "".concat(label, " (Partial)"))); // $FlowFixMe


  ModelRecordClass[$modelDefinition].partialRecordClass = PartialModelRecordClass;

  if (liveUpdateModel) {
    liveUpdateModels[liveUpdateModel] = ModelRecordClass;
  }

  if (liveUpdateListener) {
    liveUpdateListeners.push(liveUpdateListener);
  }

  modelClassMap[modelId] = ModelRecordClass;
  return ModelRecordClass;
}