"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.entitiesPayloadStateTransition = entitiesPayloadStateTransition;
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread4 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _immutable = require("immutable");

var _actions = require("./actions");

var _Model = require("./Model");

var _util = require("./util");

var _actionTypes$fetch$ac;

function deleteEntitiesStateTransition(state, stateKey, ids) {
  var nextState = state;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var id = _step.value;
      nextState = nextState.deleteIn([stateKey, 'synced', id]);
    } // Remove any partial records that might exist as well

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  nextState = nextState.updateIn([stateKey, 'partialRecords', 'synced'], function (partialRecordsByFieldNames) {
    return partialRecordsByFieldNames.map(function (partialRecords, fieldNames) {
      return partialRecords.withMutations(function (s) {
        ids.forEach(function (id) {
          s["delete"](id);
        });
      });
    });
  });
  return nextState;
}
/**
 * Transition provided state to next state based on entities payload
 * This is used for both initial data and API calls.
 * @param state {EntitiesState} current state object
 * @param action {Object}
 * @return {EntitiesState} next state
 */


function entitiesPayloadStateTransition(state, _ref) {
  var payload = _ref.payload,
      error = _ref.error,
      _ref$meta = _ref.meta;
  _ref$meta = _ref$meta === void 0 ? {} : _ref$meta;
  var partialRecordFieldNames = _ref$meta.partialRecordFieldNames,
      fetchedEntityStateKey = _ref$meta.stateKey;

  if (error) {
    console.warn( // eslint-disable-line
    'Unexpected error doing state transition', payload);
    return state;
  }

  var nextState = state;
  Object.keys(payload.entities || {}).forEach(function (stateKey) {
    var entities = Object.assign({}, payload.entities[stateKey]);

    if (nextState.has(stateKey)) {
      if (!partialRecordFieldNames) {
        var entitiesSynced = nextState.getIn([stateKey, 'synced']);

        if (entitiesSynced && entitiesSynced.size) {
          Object.keys(entities).forEach(function (id) {
            // Make sure modelUUID is retained across updates
            var modelUUID = nextState.getIn([stateKey, 'synced', Number(id), 'modelUUID']);

            if (modelUUID) {
              entities[id] = (0, _objectSpread4["default"])({}, entities[id], {
                modelUUID: modelUUID
              });
            }
          });
        }

        nextState = nextState.mergeIn([stateKey, 'synced'], entities);
        nextState = nextState.getIn([stateKey, 'optimisticUpdates']).reduce(function (s, update) {
          return applyOptimisticUpdate(s, update.statePath, update.data);
        }, nextState);
        var ids = Object.keys(entities);
        nextState = nextState.updateIn([stateKey, 'partialRecords', 'synced'], function (partialRecordsByFieldNames) {
          return partialRecordsByFieldNames.map(function (partialRecords, fieldNames) {
            var pinnedFieldNames = partialRecords.getPinnedFieldNames();
            return partialRecords.withMutations(function (s) {
              ids.forEach(function (id) {
                var allValues = entities[id];
                var pinnedValues = pinnedFieldNames.reduce(function (acc, fieldName) {
                  acc[fieldName] = allValues[fieldName];
                  return acc;
                }, (0, _defineProperty2["default"])({}, _Model.PARTIAL_FIELDS_KEY_FIELD_NAME, fieldNames.toList()));
                var values = fieldNames.reduce(function (acc, fieldName) {
                  acc[fieldName] = entities[id][fieldName];
                  return acc;
                }, pinnedValues);
                s.set(id, values);
              });
            });
          });
        });
      } else {
        var _entitiesSynced = nextState.getIn([stateKey, 'partialRecords', 'synced']);

        var partialFieldsKey = new _immutable.Set(partialRecordFieldNames);

        if (_entitiesSynced && _entitiesSynced.size) {
          Object.keys(entities).forEach(function (id) {
            // Make sure modelUUID is retained across updates
            var modelUUID = nextState.getIn([stateKey, 'partialRecords', 'synced', partialFieldsKey, Number(id), 'modelUUID']);
            var nextData = (0, _objectSpread4["default"])({}, entities[id], (0, _defineProperty2["default"])({}, _Model.PARTIAL_FIELDS_KEY_FIELD_NAME, partialRecordFieldNames));

            if (modelUUID) {
              nextData.modelUUID = modelUUID;
            }

            entities[id] = nextData;
          });
        } else {
          Object.keys(entities).forEach(function (id) {
            entities[id] = (0, _objectSpread4["default"])({}, entities[id], (0, _defineProperty2["default"])({}, _Model.PARTIAL_FIELDS_KEY_FIELD_NAME, partialRecordFieldNames));
          });
        }

        nextState = nextState.mergeIn([stateKey, 'partialRecords', 'synced', partialFieldsKey], entities);
      }
    } else {
      console.warn( // eslint-disable-line
      "Unknown entity name '".concat(stateKey, "' encountered. This should ") + 'probably have a key in the entities state. Consider creating ' + 'the relevant reducer with createModelReducer and passing ' + 'that to createModelsReducer.');
    }
  });
  Object.keys(payload.deletedEntities || {}).forEach(function (stateKey) {
    if (nextState.has(stateKey)) {
      var ids = payload.deletedEntities[stateKey];
      nextState = deleteEntitiesStateTransition(nextState, stateKey, ids);
    } else {
      console.warn( // eslint-disable-line
      "Unknown entity name '".concat(stateKey, "' encountered. This should ") + 'probably have a key in the entities state. Consider creating ' + 'the relevant reducer with createModelReducer and passing ' + 'that to createModelsReducer.');
    }
  });

  if (partialRecordFieldNames) {
    // If no records were returned on a partial request still update the redux state with
    // an empty map so that selectors that expect it to have data have it AND so that any
    // subsequent fetchEntities or fetchEntity's on a superset of these fields can update
    // this part of the state.
    var entitiesSynced = nextState.getIn([fetchedEntityStateKey, 'partialRecords', 'synced']);
    var partialFieldsKey = new _immutable.Set(partialRecordFieldNames);

    if (entitiesSynced.get(partialFieldsKey) == null) {
      nextState = nextState.setIn([fetchedEntityStateKey, 'partialRecords', 'synced', partialFieldsKey], {});
    }
  }

  return nextState;
}
/**
 * Use this to reapply optimistic updates after entity has been updated from server
 * This solves issues with multiple optimistic updates being overwritten by an
 * intermediate server response.
 */


function applyOptimisticUpdate(state, stateKey, data) {
  return state.updateIn(stateKey, function (entity) {
    return entity ? entity.merge(data) : data;
  });
}

function addOrUpdateEntity(state, action) {
  var nextState = entitiesPayloadStateTransition(state, action); // Allow specification of optimisticStateKey for cases where the optimistic update
  // is for a different model. Ideally this would be refactored such that optimistic
  // updates are stored at the top level so we could just look them up by id easily.
  // Default behaviour is to treat the optimistic update as coming from same model.

  var _action$meta = action.meta,
      stateKey = _action$meta.stateKey,
      _action$meta$optimist = _action$meta.optimisticStateKey,
      optimisticStateKey = _action$meta$optimist === void 0 ? stateKey : _action$meta$optimist,
      entity = _action$meta.entity,
      optimisticId = _action$meta.optimisticId;

  if (entity) {
    // Now that entity has by sync'd remove it from local state key
    nextState = nextState.deleteIn([stateKey, 'local', entity.modelUUID]);
  }

  if (optimisticId) {
    var optimisticIndex = nextState.getIn([optimisticStateKey, 'optimisticUpdates']).findIndex(function (update) {
      return update.optimisticId === optimisticId;
    });
    nextState = nextState.deleteIn([optimisticStateKey, 'optimisticUpdates', optimisticIndex]);
  }

  return nextState.getIn([stateKey, 'optimisticUpdates']).reduce(function (s, update) {
    return applyOptimisticUpdate(s, update.statePath, update.data);
  }, nextState);
}

var _default = (_actionTypes$fetch$ac = {}, (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.fetch, entitiesPayloadStateTransition), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.customDetail, addOrUpdateEntity), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.customList, addOrUpdateEntity), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.add, addOrUpdateEntity), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.update, addOrUpdateEntity), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.updateOptimistic, function (state, _ref2) {
  var meta = _ref2.meta,
      payload = _ref2.payload;
  var stateKey = meta.stateKey,
      optimisticId = meta.optimisticId;
  var entity = payload.entity,
      data = payload.data;
  var statePath = (0, _util.getRecordPath)(state, entity);
  var nextState = applyOptimisticUpdate(state, statePath, data);
  return nextState.updateIn([stateKey, 'optimisticUpdates'], function (updates) {
    return updates.push({
      optimisticId: optimisticId,
      entityId: entity.getId(),
      data: data,
      statePath: statePath
    });
  });
}), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.updateOptimisticUndo, function (state, _ref3) {
  var meta = _ref3.meta,
      payload = _ref3.payload;
  var stateKey = meta.stateKey,
      optimisticId = meta.optimisticId;
  var entity = payload.entity;
  var path = (0, _util.getRecordPath)(state, entity);
  var nextState = state.setIn(path, entity);
  var optimisticIndex = nextState.getIn([stateKey, 'optimisticUpdates']).findIndex(function (update) {
    return update.optimisticId === optimisticId;
  });
  return nextState.deleteIn([stateKey, 'optimisticUpdates', optimisticIndex]);
}), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.addLocal, function (state, _ref4) {
  var payload = _ref4.payload,
      meta = _ref4.meta;
  var stateKey = meta.stateKey;
  var modelUUID = payload.modelUUID,
      data = payload.data;
  var path = [stateKey, 'local', modelUUID];
  return state.setIn(path, (0, _objectSpread4["default"])({}, data, {
    modelUUID: modelUUID
  }));
}), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.deleteLocal, function (state, _ref5) {
  var payload = _ref5.payload,
      meta = _ref5.meta;
  var stateKey = meta.stateKey;
  var entity = payload.entity;
  var path = [stateKey, 'local', entity.modelUUID];
  return state.deleteIn(path);
}), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes["delete"], function (state, _ref6) {
  var payload = _ref6.payload,
      meta = _ref6.meta;
  var stateKey = meta.stateKey;

  if (state.has(stateKey)) {
    // Accept either multiple ids or single id
    var ids = payload.ids || [payload.id];
    return deleteEntitiesStateTransition(state, stateKey, ids);
  }

  console.warn( // eslint-disable-line
  "Unknown entity name ".concat(stateKey, " encountered. This should ") + 'probably have a key in the entities state.');
  return state;
}), (0, _defineProperty2["default"])(_actionTypes$fetch$ac, _actions.actionTypes.reorder, function (state, _ref7) {
  var payload = _ref7.payload;
  // TODO: This should really be an optimistic update, not updating synced records
  var entity = payload.entity,
      withRespectTo = payload.withRespectTo;
  var entityPath = (0, _util.getRecordPath)(state, entity);
  var entities;

  if (!entity[_Model.PARTIAL_FIELDS_KEY_FIELD_NAME]) {
    entities = entity.constructor.selectors.all(state);
  } else {
    entities = entity.constructor.selectors.partialFields.all(state)(entity[_Model.PARTIAL_FIELDS_KEY_FIELD_NAME]);
  }

  if (!entityPath) {
    throw new Error('Passed entity to re-order was not found in state');
  } // Always make sure we use the latest version of entity in case
  // sort value has changed since it was fetched


  entity = state.getIn(entityPath);

  if ((0, _Model.isModel)(withRespectTo)) {
    var withRespectToPath = (0, _util.getRecordPath)(state, withRespectTo);

    if (!withRespectToPath) {
      throw new Error('Passed entity to re-order with respect to ' + 'was not found in state');
    }

    withRespectTo = state.getIn(withRespectToPath);
  }

  var orderedModel = entity[_Model.$modelDefinition].orderedModel;
  var orderWithRespectTo = orderedModel.orderWithRespectTo,
      orderFieldName = orderedModel.orderFieldName; // This tracks values to update in entity

  var newData = {};
  var filteredEntities = entities.filter(function (e) {
    if (!orderWithRespectTo) {
      return true;
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = orderWithRespectTo[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var fieldName = _step2.value;

        if (e[fieldName] !== entity[fieldName]) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return true;
  }).toList().sortBy(function (e) {
    return e.get(orderFieldName);
  });

  if (orderWithRespectTo) {
    // Copy all fields that are relevant to ordering. For example
    // if you have a todo that is ordered against other todo's
    // on a day then when re-ordering it we must set the day to
    // match it's target day
    orderWithRespectTo.forEach(function (fieldName) {
      newData[fieldName] = withRespectTo[fieldName];
    });
  } // Check if 2 entities are in the same 'list' (ie. they have same values
  // for all orderWithRespectTo fields)


  var isInSameList = function isInSameList(entity1, entity2) {
    if (!orderWithRespectTo) {
      return true;
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = orderWithRespectTo[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var fieldName = _step3.value;

        if (entity1[fieldName] !== entity2[fieldName]) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return true;
  };

  var entityIndex = filteredEntities.findIndex(function (en) {
    return en.modelUUID === entity.modelUUID;
  });
  var withRespectToIndex = filteredEntities.findIndex(function (en) {
    return en.modelUUID === withRespectTo.modelUUID;
  });

  var isAdjacent = function isAdjacent(i1, i2) {
    return Math.abs(i1 - i2) === 1;
  };

  var isBetween = function isBetween(bound1, bound2, target) {
    return target > bound1 && target < bound2 || target < bound1 && target > bound2;
  };

  if ((0, _Model.isModel)(withRespectTo)) {
    var insertAfter = payload.insertAfter;
    var insertBefore = payload.insertBefore;

    if (!(insertBefore || insertAfter)) {
      if (isInSameList(entity, withRespectTo)) {
        var isBefore = entity.get(orderFieldName) < withRespectTo.get(orderFieldName);
        var adjacent = isAdjacent(entityIndex, withRespectToIndex);
        insertAfter = isBefore && adjacent || !isBefore && !adjacent;
      } else {
        // Default behaviour is to insertAfter if moving lists
        insertAfter = true;
      }
    }

    var offset = insertAfter ? 0.001 : -0.001;
    newData[orderFieldName] = withRespectTo.get(orderFieldName) + offset;
    var nextState = state.updateIn(entityPath, function (e) {
      return e.merge(newData);
    });
    var previouslyReorderedEntities = filteredEntities.filter(function (en, index) {
      if (en.modelUUID === entity.modelUUID || // If inserting after don't want to re-order target
      // If we are inserting before then we do need to reorder
      // it as it is pushed out by the re-ordered entity
      en.modelUUID === withRespectTo.modelUUID || !isBetween(entityIndex, withRespectToIndex, index)) {
        return false;
      } // Only re-order items that have been re-ordered client side
      // It's expected this is temporary as once it's saved to the
      // server entities on the client side should be updated with
      // their new sort value


      if (Math.abs(en.get(orderFieldName) - withRespectTo.get(orderFieldName)) >= 1) {
        return false;
      }

      return isInSameList(en, entity);
    }).sortBy(function (e) {
      return e.get(orderFieldName);
    });

    if (previouslyReorderedEntities.size) {
      return nextState.withMutations(function (s) {
        previouslyReorderedEntities.forEach(function (e) {
          var sortKey = e.get(orderFieldName);
          var path = (0, _util.getRecordPath)(state, e);
          s.setIn([].concat((0, _toConsumableArray2["default"])(path), [orderFieldName]), sortKey + offset);
        });
      });
    }

    return nextState;
  } // Otherwise we are not re-ordering against a specific entity - rather
  // we have the values for all orderWithRespectTo fields and either
  // insertStart or insertEnd


  var insertStart = payload.insertStart;
  var sortKey = 0;

  if (filteredEntities.size) {
    sortKey = insertStart ? filteredEntities.first().get(orderFieldName) - 0.001 : filteredEntities.last().get(orderFieldName) + 0.001;
  }

  newData[orderFieldName] = sortKey;
  return state.updateIn(entityPath, function (e) {
    return e.merge(newData);
  });
}), _actionTypes$fetch$ac);

exports["default"] = _default;