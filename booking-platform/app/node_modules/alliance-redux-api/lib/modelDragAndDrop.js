"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modelDropTarget = modelDropTarget;
exports.modelDragSource = modelDragSource;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _reactDom = require("react-dom");

var _reactDnd = require("react-dnd");

var _invariant = _interopRequireDefault(require("invariant"));

var _reactRedux = require("react-redux");

var _redux = require("redux");

var _util = require("./util");

var _actions = require("./actions");

var _Model = require("./Model");

// These are used to connect relevant components to give access
// to state and bound redux actions necessary to handle re-ordering
function mapStateToProps(state) {
  return {
    // Only include Entities, not full app state. This helps PureComponent's
    // only re-render if something in Entities changes vs anything in state
    // Particularly noticeable when using something like redux-form which
    // changes state on every keypress. This could potentially be optimised
    // further, ie. only include entities the DND accepts.
    // TODO: With changes to allow customisation of where sits in redux
    // state tree this is now hard - just use full state
    modelDNDState: state
  };
}

function mapDispatchToProps(dispatch) {
  return {
    modelDNDActions: (0, _redux.bindActionCreators)({
      reorderEntity: _actions.reorderEntity,
      updateEntityOrdering: _actions.updateEntityOrdering
    }, dispatch)
  };
}

var itemTypesCache = {};
/**
 * Generate unique item types for entity model classes
 */

function getItemType(item) {
  if ((0, _typeof2["default"])(item) == 'object' || typeof item == 'function') {
    if (!itemTypesCache[item]) {
      itemTypesCache[item] = "ITEM_".concat(Object.keys(itemTypesCache).length);
    }

    return itemTypesCache[item];
  }

  return item;
}

function isOfModelType(entity, modelClass) {
  var modelId;

  if (typeof modelClass == 'string') {
    modelId = modelClass;
  } else {
    modelId = modelClass[_Model.$modelDefinition].modelId;
  }

  return entity[_Model.$modelDefinition].modelId === modelId;
}
/**
 * Decorate a component so it accepts DND from specified models
 * @param getTarget {Function} function that gets passed the props for the
 * component dropping on and should return the relevant model instance OR
 * object contains relevant fields to specifying group by ordering for
 * dragged entity. For example - if you are dragging a CheckListItem that
 * is ordered by section and the drop target was a section you might return
 * an object that looks like: { sectionId: props.section.id } - this is
 * sufficient to add the CheckListItem to that section (but no more specific
 * ordering than that - this is usually used when there are no other items
 * in that list for you to order against)
 * @param Array {acceptsModelConfig} An array of values where each value is
 * either an ModelRecord class (not an instance) OR a 2-element array where
 * the first element the ModelRecord class and the second is a configuration
 * object. Valid configuration object parameters are:
 * - shallow Boolean if true will only handle drops shallowly (ie. if the
 *   drop target has any children that are also drop targets for the dragged
 *   item it will not do anything)
 * - getGroupByFields Function a function that will be passed the return
 *   value of getTarget and should return an object with keys that match
 *   the model orderWithRespectTo field names with associated values.
 * @return Function function you pass your component to
 */


function modelDropTarget(getTarget, acceptsModelConfig) {
  var spec = {
    hover: function hover(props, monitor, component) {
      var monitorItem = monitor.getItem();
      var draggedEntity = monitorItem.draggedEntity; // TODO: Assumes always vertical re-ordering within a list!
      // (dragging across multiple columns is fine so long as each column
      // is arranged vertically)
      // Determine rectangle on screen

      if (component == null) {
        throw new Error('Component is null - this likely means you are using a stateless component. Convert it to a class that extends React.Component to resolve.');
      }

      var hoverBoundingRect = (0, _reactDom.findDOMNode)(component).getBoundingClientRect(); // Get vertical middle

      var hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2; // Determine mouse position

      var clientOffset = monitor.getClientOffset(); // Get pixels to the top

      var hoverClientY = clientOffset.y - hoverBoundingRect.top;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = acceptsModelConfig[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var modelSpec = _step.value;
          var modelClass = void 0;
          var config = {};

          if (Array.isArray(modelSpec)) {
            modelClass = modelSpec[0];

            if (modelSpec.length > 1) {
              config = modelSpec[1];
            }
          } else {
            modelClass = modelSpec;
          }

          if (isOfModelType(draggedEntity, modelClass)) {
            var _ret = function () {
              if (config.shallow && !monitor.isOver({
                shallow: true
              })) {
                return {
                  v: void 0
                };
              }

              var timeSinceLastReorder = Number.POSITIVE_INFINITY;

              if (monitorItem.lastOverDate) {
                timeSinceLastReorder = new Date() - monitorItem.lastOverDate;
              } // TODO: This may be unnecessary now that check distance below


              if (timeSinceLastReorder < 100) return {
                v: void 0
              }; // This could be an entity, eg a TodoItem, or a object
              // of field values, eg. a ScheduleDay which defines the
              // grouping of TodoItem's.

              var entityOrFields = getTarget(props);
              (0, _invariant["default"])(entityOrFields, 'getTarget did not return an entity or object of fields'); // Fetch latest version of entity as if it has already
              // been re-ordered as part of this drag the data we
              // have stored will be stale

              var path = (0, _util.getRecordPath)(props.modelDNDState, draggedEntity);
              var draggedEntityLatest = props.modelDNDState[path.shift()].getIn(path);

              if (isOfModelType(entityOrFields, modelClass)) {
                // Same entity; order against each other
                if (draggedEntity.modelUUID === entityOrFields.modelUUID) return {
                  v: void 0
                };
                var orderedModel = entityOrFields[_Model.$modelDefinition].orderedModel;
                var _modelDNDActions = props.modelDNDActions;
                var dragIndex = draggedEntityLatest[orderedModel.orderFieldName];
                var targetIndex = entityOrFields[orderedModel.orderFieldName]; // Only perform the move when the mouse has crossed half of the items height
                // When dragging downwards, only move when the cursor is below 50%
                // When dragging upwards, only move when the cursor is above 50%

                monitorItem.dragDirection = dragIndex < targetIndex ? 'Down' : 'Up'; // Dragging downwards

                if (dragIndex < targetIndex && hoverClientY < hoverMiddleY) {
                  return {
                    v: void 0
                  };
                } // Dragging upwards


                if (dragIndex > targetIndex && hoverClientY > hoverMiddleY) {
                  return {
                    v: void 0
                  };
                }

                _modelDNDActions.reorderEntity(draggedEntity, entityOrFields);

                monitorItem.lastOverDate = new Date();
                return {
                  v: void 0
                };
              } // Otherwise reordering to a different grouping


              var fields = config.getGroupByFields(entityOrFields); // Check it doesn't already belong to the list defined by
              // field values in entityOrFields

              var isSame = Object.keys(fields).reduce(function (acc, fieldName) {
                return acc && fields[fieldName] === draggedEntityLatest.get(fieldName);
              }, true);

              if (isSame) {
                return {
                  v: void 0
                };
              }

              var modelDNDActions = props.modelDNDActions;
              modelDNDActions.reorderEntity(draggedEntity, fields);
              monitorItem.lastOverDate = new Date();
            }();

            if ((0, _typeof2["default"])(_ret) === "object") return _ret.v;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  function targetCollect(conn, monitor) {
    return {
      connectDropTarget: conn.dropTarget(),
      draggedItem: monitor.getItem(),
      isDraggedItemOver: monitor.isOver()
    };
  }

  var itemTypes = acceptsModelConfig.map(function (config) {
    if (Array.isArray(config)) {
      return getItemType(config[0]);
    }

    return getItemType(config);
  }); // Returns a function that accepts a component - injects normal
  // React DnD Props (eg. connectDropTarget)

  return (0, _redux.compose)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps), (0, _reactDnd.DropTarget)(itemTypes, spec, targetCollect));
}
/**
 * Decorate a component so it can be dragged and dropped on drop targets (as
 * defined with modelDropTarget)
 * @param modelClassOrType {ModelRecord|String} A model class (not an instance)
 * or string. This is used as the DND type and must match types specified in
 * a modelDropTarget acceptsModelConfig parameter otherwise nothing will happen.
 * @param getFromProps {Function} return the dragged entity from props
 * @return Function function you pass your component to
 */


function modelDragSource(modelClassOrType, getFromProps) {
  var itemSource = {
    beginDrag: function beginDrag(props) {
      return {
        draggedEntity: getFromProps(props)
      };
    },
    endDrag: function endDrag(props, monitor) {
      var item = monitor.getItem();
      props.modelDNDActions.updateEntityOrdering(item.draggedEntity);
    }
  };

  function sourceCollect(conn) {
    return {
      connectDragSource: conn.dragSource(),
      connectDragPreview: conn.dragPreview()
    };
  } // Returns a function that accepts a component - injects normal
  // React DnD Props (eg. connectDragPreview, connectDragSource)


  return (0, _redux.compose)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps), (0, _reactDnd.DragSource)(getItemType(modelClassOrType), itemSource, sourceCollect));
}