# Alliance Redux api

Redux actions & reducers for interacting with REST API's with helpers for
specifying your data model, normalizing data, and setting up live updates.

Aimed at usage with [DRF](http://www.django-rest-framework.org/) but could be
adapted to other RESTful API implementations.

* [Installation](#installation)
  * [Dependencies](#dependencies)
* [How does it work?](#how-does-it-work)
* [Model](#model)
  * [Ordered models](#ordered-models)
  * [Foreign Keys](#foreign-keys)
  * [Serialization](#serialization)
* [API calls](#api-calls)
  * [Fetch](#fetch)
  * [Save data](#save-data)
    * [Create record](#create-record)
    * [Update a record](#update-a-record)
    * [Delete a record](#delete-a-record)
    * [Post file data](#post-file-data)
  * [Custom endpoints](#custom-endpoints)
  * [401 and retries](#401-and-retries)
* [Selectors](#selectors)
* [Live Updates](#live-updates)
* [Model specific reducers](#model-specific-reducers)
* [Drag and drop](#drag-and-drop)
  * [modelDropTarget](#modeldroptarget)
  * [modelDragSource](#modeldragsource)
  * [Advanced](#advanced)
* [TODO](#todo)
* [Changelog](#changelog)

## Installation

TODO: Currently this is just used on TT and is a git submodule. Will eventually
be npm installed

```
# Install peer dependencies
npm install --save typed-immutable redux-api-middleware
```

Include middleware from [redux-api-middleware](https://github.com/agraboso/redux-api-middleware).

Setup reducer:

```
import createModelsReducer from 'alliance-redux-api/createModelsReducer';

// Each parameter here is a [Model](#Model) or reducer created with `createModelReducer`
const Entities = createModelsReducer([StaffMember, Task, Project]);

// Entities can then be used with normal redux setup
```

### Dependencies

- [typed-immutable](https://github.com/typed-immutable/typed-immutable)
  Fully specify state tree and the possible types for each field. Enforces types
  at runtime and handles converting JSON structure to deeply nested immutable
  structure.
- [redux-api-middleware](https://github.com/agraboso/redux-api-middleware)
  Middleware for interacting with API
- [normalizr](https://github.com/paularmstrong/normalizr)
  Handles normalizing nested data returned from API endpoint
- [redux](https://github.com/reactjs/redux)
  Predictable state container for JavaScript app
- [reselect](https://github.com/reactjs/reselect)
  Selector library for Redux

## How does it work?

At it's core alliance-redux-api requires you to setup a few things:

1. Data Model. For each possible model you wish to fetch data for you must fully
specify it's fields and any relations for the purposes of data normalization.

2. Add the models reducer provided by alliance-redux-api

3. Use provided actions to fetch and save data

4. Optionally setup models for live updates

## Model

The `Model` factory creates a typed-immutable Record instance that alliance-redux-api
knows how to fetch and save data for (along with any data normalization).

`Model(descriptor, stateKey, label, options = {})`

**Params**

- descriptor `Object` - map of field name to field type as per typed-immutable Record definitions
- stateKey `String` - the key that data for this model will be added under
- label `String` - a user readable label for this; used for debugging
- options `Object`
  - endpoint `String` - API endpoint URI. Defaults to `stateKey` if not supplied. eg. `forward-planning/allocations`
  - idFieldName `String|Array<String>` - id field name to use. defaults to 'id'. Supply an array of field names for compound keys.
  - liveUpdateModel `String` - if supplied will handle live updates for this django model eg. `dashboard.todo`
  - orderedModel `Object` - if supplied model will have an ordering defined by:
        - orderFieldName `String` name of the field on the model that determines order
        - orderWithRespectTo `Array<String>` - Array of field names to order with respect to (this defines the grouping)
  - cache `FetchCache` - TODO
  - buildSelectors `Function` - function that returns extra selectors to create for this Model. Gets passed array containing selectors details below under [Selectors](#Selectors)

**Returns**: Immutable `Record` instance

**Example**
```
import { Model } from 'alliance-redux-api';
import { Id } from 'alliance-redux-api/lib/fieldTypes';

const fields = {
  id: Maybe(Id),
  title: String,
};
const TodoRecord = Model(fields, 'todos', 'Todo Items');
```

### Ordered models

To make a model ordered specify the `orderedModel` option:

```
export const CheckListItem = Model({
  id: Maybe(Id),
  title: String,
  sectionId: Id,
  description: String(''),
  sortOrder: Number(9999),
}, 'checkListItems', 'CheckListItem', {
  endpoint: 'checklist-items',
  orderedModel: {
    orderFieldName: 'sortOrder',
    orderWithRespectTo: ['sectionId'],
  },
});
```

Here ordering is done on the `sortOrder` field grouped by `sectionId`, ie. CheckListItems
have order only relative to other items in the same section.

On the backend update your model to extend `OrderedModelBase` (depends on [django-ordered-model](https://github.com/bfirsh/django-ordered-model)):

```
from ordered_model.models import OrderedModelBase

class Todo(OrderedModelBase):

    # Your model definition

    # Ordered model details that should match what you defined above
    order_field_name = 'sort_order'
    order_with_respect_to = ('section_id',)
```

Update API ViewSet to include the `ReorderModelMixin`:

```
class CheckListItemViewSet(viewsets.ModelViewSet, ReorderModelMixin):
    serializer_class = CheckListItemSerializer
    queryset = CheckListItem.objects.all()
    permission_required = 'TimeTracker.Task.View'
```

This adds the 'reorder' endpoint that can be used to re-order a record.

You can now use the drag and drop functionality detail below.

### Foreign Keys

Using foreign keys allows automatic normalization of data received from API calls.

```
const User = Model({
    id: Numeric,
    name: String,
}, 'users', 'User');

const Article = Model({
    id: Numeric,
    title: String,
    authorId: ForeignKeyField(User, { schemaFieldName: 'author' }),
    contributorIds: ForeignKeyField(User, { many: true, schemaFieldName: 'contributors' }),
}, 'articles', 'Article');
```

Here we are saying that `Article` has a field called `author` that contains data
that we should treat as a `User` (and store it in the User state tree) and only
store the users ID here in the `authorId` field. Given this response:

```
{
  id: 1,
  title: 'Some Article',
  author: {
    id: 7,
    name: 'Dan',
  },
  contributors: [{
    id: 10,
    name: 'Abe',
  }, {
    id: 15,
    name: 'Fred',
  }],
}
```

We end up with:

```
{
  Article: {
    2: {
      id: 2,
      title: 'A new article',
      authorId: 7,
      contributorIds: [10],
    },
  },
  User: {
    7: {
      id: 7,
      name: 'Dan',
    },
    10: {
      id: 10,
      name: 'Abe',
    },
    15: {
      id: 15,
      name: 'Fred',
    },
  }
}
```

Avoiding duplication by normalizing like this helps prevent stale data from being
displayed in your UI.

### Serialization

## API calls

Usage of these assumes you have a RESTful API endpoint available. Using a DRF ModelViewSet
is sufficient:

```
class TaskViewSet(viewsets.ModelViewSet):
    serializer_class = TaskSerializer
    queryset = Task.objects.all()
    permission_required = 'TimeTracker.Projects.View'
    filter_fields = ('complete', )    
```

### Fetch

Fetching data is done using the `fetchEntities` or `fetchEntity` redux actions. Simply pass
the model your want and either filters (fetchEntities) or the ID of the record (fetchEntity):

```
import { fetchEntities, fetchEntity } from 'alliance-redux-api';
// NOTE: These all must be dispatched as per normal redux usage, omitted here
// Fetch all todos
fetchEntities(TodoRecord);
// Fetch all todos for a staff member (assumes backend API supports this filter)
fetchEntities(TodoRecord, { staffMemberId: 12 })
// Same fetch again won't trigger another API call
fetchEntities(TodoRecord, { staffMemberId: 12 })

// Fetch a specific entity
fetchEntity(TodoRecord, 42);
```

These functions returns promises which you can use to indicate loading status. Alternatively
you can rely entirely on the redux state for rendering (loading status is saved there):

```
function mapStateToProps(state) {
    return {
      todos: TodoRecord.selectors.all(state),
      isFetching: TodoRecord.selectors.isFetching(state),
    };
}
@connect(mapStateToProps, { fetchEntities })
class TodoList extends Component {
  componentDidMount() {
    this.props.fetchEntities(TodoRecord);
  }

  render() {
    if (this.props.isFetching) {
      return <div>Please wait... loading</div>;
    }

    return <TodoList items={this.props.todos} />;
  }
}
```

### Save data

#### Create record

```
import { addEntity, addEntityLocal } from 'alliance-redux-api';

// Save new todo to server
addEntity(TodoRecord, newTodoData);

// Save new todo locally without syncing to server
const localEntity = addEntityLocal(TodoRecord, newTodoData);

// ... then save to server at some point
addEntity(localEntity).catch(error => {
  // Delete local version if sync fails
  this.props.deleteEntityLocal(localEntity);
  throw error;
});
```

Note that you typically pass `addEntity` the class itself as the first parameter and data second as you
rarely have all the data as defined on the model (ie. you don't know the ID yet). This avoids
making fields `Maybe` just for the purpose of handling unsaved records.

#### Update a record
```
import { updateEntity } from 'alliance-redux-api';

// Update existing todo (instance of TodoRecord) with data
updateEntity(todo, data);

// Or do it optimistically so UI reflects changes immediately. Will rollback
// if sync fails.
updateEntity(todo, data, { optimistic: true });
```

#### Delete a record
```
import { deleteEntity, deleteEntityLocal } from 'alliance-redux-api';

// Delete from server
deleteEntity(todo);

// Or if hasn't been sync'd
deleteEntityLocal(localTodo);
```

#### Post file data

The data param passed to `updateEntity` and `addEntity` can be a `FormData` instance.

```
const data = new FormData();
data.append('file', file);
data.append('label', file.name);
data.append('someOtherField', 5);
addEntity(MyEntityModel, data)
```

On the backend, for DRF, you will need to include `MultiPartParser` in your viewset `parser_classes`.

### Custom endpoints

You can add custom endpoints and interact with them using the `customDetailRoute`
action.

```
import { customDetailRoute } from 'alliance-redux-api';
// Perform a PATCH to the 'toggle_delete' endpoint for a task record (id = 123)
customDetailRoute('patch', task, 'toggle_delete');
// Results in call to /api/task/123/toggle_delete
```

This might be implemented on a DRF ViewSet as:

```
@detail_route(methods=('patch', ))
  def reveal(self, request, pk):
      task = self.get_object()
      task.toggle_delete()
      serializer = self.get_serializer(task)
      return Response(serializer.data)
```

### 401 and retries

If an endpoint returns a 401 the API call will be queued and retried once
a successful login occurs. For this to work you need to add middleware:

```
import { apiAuthRetryMiddleware } from 'alliance-redux-api/lib/middleware';
import { apiMiddleware } from 'redux-api-middleware';

const middlewares = [
    apiMiddleware,
    // Pass the middleware the constant of your login success action
    apiAuthRetryMiddleware(ActionTypes.AUTH_LOGIN),
];
let middleware = applyMiddleware(...middlewares);
// ..etc this gets passed to createStore
```

Here `ActionTypes.AUTH_LOGIN` should be the action type from your app that is dispatched when
a successful login occurs. 

When a 401 occurs an action will be dispatched that you can respond to do invalidate the current auth state:

```
import { API_CALL_AUTH_REQUIRED } from 'alliance-redux-api/lib/api';

// This can be whatever is relevant to your app
const AuthStateRecord = Record({
    user: Maybe(User),
    isLoggedIn: Boolean(false),
    sessionId: Maybe(String),
}, 'AuthState');

export default createReducer(AuthState, {

    [ActionTypes.AUTH_LOGIN](state, { payload, error }) {
        if (error) {
            return state;
        }
        return state.merge({
            user: payload.user,
            isLoggedIn: true,
        });
    },

    [API_CALL_AUTH_REQUIRED](state) {
        return state.set('isLoggedIn', false);
    },
});
```

Note that when a [401 Unauthorized](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401) status
is returned it's meant to have a `WWW-Authenticate` header included (if you are using DRF it will include
this when using 'rest_framework.authentication.BasicAuthentication'). Unfortunately the browser will
prompt you with a login box when this occurs which isn't what we want when making calls using ajax.

TODO: It seems common in javascript frameworks to include a `X-Requested-With` header set to XMLHttpRequest -
we could add this and then have custom authentication class that checks for this and excludes the
`WWW-Authenticate` header when present.

For now you can implement something like:

```
from rest_framework.authentication import BasicAuthentication as DefaultBasicAuthentication


class BasicAuthentication(DefaultBasicAuthentication):

    def authenticate_header(self, request):
        # Untested, may need to be string
        return None
```

## Selectors

Selectors are functions that, given the Redux state and props, will return some state slice
or _transformed_ state. They also perform memoization so that expensive selections are
only run when necessary.

Selectors for a model are accessed as a property on the model class itself. Using the
example `TodoRecord` above:

```
// State selector function passed to react-redux connect()
function mapStateToProps(state, props) {
  // Most selectors won't need props
  const todos = TodoRecord.selectors.all(state, props);
  return {
    todo,
  }
}
```

The default selectors are:

* **synced** - Return the `synced` state tree which contains all records that are saved to server
* **local** - Return the `local` state tree which contains only records that aren't saved (eg. records created optimistically)
* **all** - Combined `synced` and `local`
* **meta** - The `meta` state key
* **loading** - The `loading` state which contains `isFetching` (true if data fetch in progress) and `syncingEntityUUIDs` (uuid of any entity currently syncing to server)
* **isFetching** - Selector to `loading.isFetching`
* **syncingEntityUUIDs** - Selector to `loading.syncingEntityUUIDS`
* **groupedByOrderWithRespectTo** - Selector records grouped according to the `orderedModel` definition for this model. Only exists for ordered models.

Custom selectors can be provided using the `buildSelectors` model options:

```
const Article = Model({
    id: Numeric,
    title: String,
}, 'articles', 'Article', {
    buildSelectors: (defaultSelectors) => ({
        first: state => defaultSelectors.all(state).first(),
    }),
});

// Selects the first article
Article.selectors.first(state)
```

## Live Updates

This assumes you are using [django-channels](https://github.com/django/channels) on the backend.

## Model specific reducers

To provide a custom reducer simply create the reducer yourself using `createModelReducer`:

```
import createModelReducer from 'alliance-redux-api/createModelReducer';

// This reducer will handle all alliance-redux-api actions + any custom handlers
// you provide. You can also override the default alliance-redux-api implementations
// (try not to)
export const checkListItemReducer = createModelReducer(CheckListItem, {
  [ActionTypes.SOME_CUSTOM_ACTION](state, action) {
    // ... handle action
  },
});
```

You then use this reducer instead of the model directly with `createModelsReducer`.

```
import createModelsReducer from 'alliance-redux-api/createModelsReducer';

// Each parameter here is a [Model](#Model) or reducer created with `createModelReducer`
const Entities = createModelsReducer([StaffMember, Task, Project, checkListItemReducer]);

// Entities can then be used with normal redux setup
```

## Drag and drop

Some helpers are provided for use with [react-dnd](https://github.com/gaearon/react-dnd) to
do local sorting or your data and handle syncing the data to the server. The below assumes
some familiarity with react-dnd.

### modelDropTarget

A decorator for a component so it accepts drops from specified models

```
class CheckListItemView extends React.Component {
  // Your component definition here
}

CheckListItemView = modelDropTarget(
    // Extracts the target from props (this is a CheckListItem model)
    props => props.item,
    // These are the model types we accept
    [model.CheckListItem]
)(CheckListItemView);
```

In your component you will receive a `connectDropTarget` function which you use
to control what part of the DOM accepts drops (as per react-dnd):

```
render() {
  // Accept drops on whole component
  return connectDropTarget(
    <div>
      <div>{this.props.item.title}</div>
      <div>{this.props.item.description}</div>
    </div>
    )
}
```

### modelDragSource

Decorate a component so it can be dragged and dropped on drop targets (as
defined with modelDropTarget)

```
CheckListItemView = modelDragSource(
    // This is the source type
    model.CheckListItem,
    // This extracts the source item from props
    props => props.item
)(CheckListItemView);
```

In your component you will receive a `connectDragSource` function which you use
to control what part of the DOM acts as a drag 'handle'.

```
render() {
  // Here we can only drag the item on the title DOM element
  return (
    <div>
      {this.props.connectDragSource(<div>{this.props.item.title}</div>)}
      <div>{this.props.item.description}</div>
    </div>
    )
}
```

That's it - so longs as you render from Redux that's all you need to implement
drag-and-drop reordering on models.

### Advanced

Multiple types can be accepted. For example CheckListItem's are grouped by section
so you should be able to drag a CheckListItem onto a CheckListSection and have it
move there:

```
CheckListSection = modelDropTarget(
    // Extract the drop target from props
    props => props.section,
    // These are the types we accept
    [
        model.CheckListSection,
        [model.CheckListItem, {
            // Only accept checklist items shallowly - which means if a lower
            // level drop target exists (eg. CheckListItem) then we don't do
            // anything here
            shallow: true,
            // This gets fields from the target (ie. a section) that are used
            // to specify ordering - in this case CheckListItem's are grouped
            // just by sectionId
            getGroupByFields(section) {
                return {
                    sectionId: section.id,
                };
            },
        }],
    ]
)(CheckListSection);
```

## TODO

- [ ] Paginated responses
- [ ] React helpers for injecting data?


## Changelog
* 2
  * 2.9
    * 2.9.0
        * Fix: Fix bug that meant the partial fields stored on partial field record were sometimes missing (this only really mattered if you were looking at PARTIAL_FIELDS_KEY_FIELD_NAME)
        * Feature: fetchEntities/fetchEntity now support returning extra data along with expected response. This is primarily supported in djrad using DjradEntityresponse. See there for expected shape. 
        * API actions now support passing through `fetchOptions` which get passed straight through to the `fetch` call. This can be used to pass eg. `signal` for use with `AbortController`.
  * 2.8
    * 2.8.1
        * Fix: when using model cache the value now includes the nextPage and previousPage keys
    * 2.8.0
        * Fix: fetchEntity with partialFields and a cache class will now correctly use the cache
        * Fix: fetchEntities with a cache class no longer includes each record indexed by array index on the response object. All records are available on the entities key in the response. This makes it consistent with response returned with a cache miss.
  * 2.7
    * 2.7.0
        * Feature: export normalizeResponseData
    * 2.7.1
        * Fix: partialFields selector now works if you pass 'id' in the field list
        * Fix: partialFields selector now works on boolean fields that had a default value of False
  * 2.6
    * 2.6.0
        * Fix: updateEntity & customDetailRoute previously would not send through undefined values and null values. This meant that in most cases you couldn't unset an optional value after setting it. As of this version only undefined values are removed - null values are passed through.
  * 2.5
    * 2.5.0
        * Feature: you can now specify `optimisticStateKey` along with `optimisticId` in meta for an update to specify which model the optimistic update was for. Useful when an optimistic update occured on a model other than the model endpoint that was called in the update / customDetailRoute
  * 2.4
    * 2.4.0
        * Feature: cache classes now received an extra parameter that fetches the current entity or entities from redux. This allows you to do things like invalidate the cache if new records have been added or existing records deleted.
        * Fix: partial record field names now form part of the cache key
        * Fix: partial record state is now always updated even if no records are returned. Previously you could fetchEntities with partial fields and if no results were returned nothing would be updated in the redux state. This meant that subsequent fetches wouldn't update the partial state tree in these cases.
        * Fix: To be consistent with other selectors partial record selectors will now always return an empty map if nothing exists in redux yet. Previously it would return undefined if either no records had been returned from a fetch or no fetch had been performed.
  * 2.3
    * 2.3.1
        * Fix: deleteEntityLocal properly allows you to delete anything in local
        * Fix: Handle compound keys properly in various places
    * 2.3.0
        * Fix: headers now correctly passed through on fetchEntities
        * Feature: accept meta param on fetchEntities and fetchEntity
        * Feature: support partialFields and custom headers on fetchEntity
        * Feature: export getApiConfigFor and buildHeaders from alliance-redux-api/lib/api
  * 2.2
    * 2.2.0
        * Fix: don't break when multiple entities are returned from backend on a create or update
        * Feature: When using addEntity support 'createdId' field in response to identify which entity out of multiple was created
  * 2.1
    * 2.1.0
        * Breaking Changes
        * fetchEntity was always caching records after initial fetch. It now uses the model cache class same as fetchEntities.
    * 2.1.1
        * Fix: in progress API call tracking to use headers in cache key
    * 2.1.2
        * Feature: extra data returned to fetchEntities will be passed through to callee
    * 2.1.3
        * Fix: optimistic updates now work on partial records
    * 2.1.4
        * Fix: Don't break when fetching data for models with id fields that aren't Id() (String, Number etc)
    * 2.1.5
        * Fix: Include 'record' in return object from customDetailRoute action
    * 2.1.6
        * Fix: customDetailRoute error handling when no record found
  * 2.0
    * 2.0.0
      * Breaking Changes 
        * Parameters to createModelsReducer have changed. You must pass an array of models now as first parameter and optional second parameter is redux state key to use (defaults to 'Entities')
        * API 'del' function now accepts a second parameter for query parameters. Previously second parameter was config, this is now third parameter.
        * Remove disablePagination query parameter and 'paginate' option from fetchEntities. Pagination is determined by backend response entirely now.
      * Enhancements
        * You can now customise where state sits in redux tree
        * addEntity & addEntity include the created or updated entity in the resolved promise now under the 'record' key
        * serialize() on a model now works on deeply nested objects
        * Calling 'get' on the map returned by a models 'all' selector now handles type conversions (so usually passing '5' and 5 will now behave the same)
        * fetchEntities now accepts the 'partialRecordFieldNames' option to partially retrieve data for an entity. This data is kept up to date with any full data you may fetch after the partial data is retrieved.
    * 2.0.1
        * Fix partial fields implementation; now sends through headers so backend can actually handle it
    * 2.0.2
        * Fix deleteEntity not update store
    * 2.0.3
        * Add isApiConfigured function
    * 2.0.4
        * Fix ordered model setup which was broken since 2.0.0
        * fetchEntities will now include nextPage and previousPage in response
    * 2.0.5
        * Add updateOptimistic as standalone action
        * Add react-beautiful-dnd reorder support
    * 2.0.6
        * Fix: don't include null values for serializing entity data
    * 2.0.7
        * Feature: Add customListRoute (like customDetailRoute but not for a specific record)
* 1.5
    * 1.5.0
        * Breaking Changes
            * Default to caching nothing on fetchEntities/fetchEntity by default
    * 1.5.1
        * Fix issue where default config value for `isDefault` was being ignored requiring it to be explicitly set
* 1.4
    * 1.4.0
        * Support for including nested form data. Requires support from backend.
    * 1.4.1
        * Fix customDetailRoute not support multi entities normalization
* 1.3
    * 1.3.0
        * Breaking Changes
            * Calling  addEntity and updateEntity will now serialize data according to fields on model. eg a Date field can specify that it should serialize as 'YYYY-MM-DD' rather than as full date time string.
