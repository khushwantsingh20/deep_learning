import Immutable from 'immutable';
import { List, Typed } from 'typed-immutable';
import get from 'lodash/get';
import invariant from 'invariant';
import { isModel, $modelDefinition, PARTIAL_FIELDS_KEY_FIELD_NAME } from './Model';

/**
 * In an immutable collection find a record
 * @param collection {Immutable.}
 * @param {undefined|[key, value]}
 */
export function findRecordEntryIn(collection, record) {
    invariant(
        isModel(record),
        'findRecordEntryIn can only be used on records defined with the Model function'
    );
    return collection.findEntry(
        value =>
            // Same object
            value === record ||
            // Compare UID that's generated for each entity
            value.get('modelUUID') === record.get('modelUUID') ||
            // Otherwise the entity ID itself
            (value.getId() && value.getId() === record.getId())
    );
}

/**
 * For a given record get the path to that record in the state.
 * Handles both local and sync'd items.
 * @param state {Function|Object} either state object itself or a function that
 * returns state (eg. getState from an action dispatch). State object can be any
 * part of the tree before the entity state. For example, if your state was
 * state = {
 *   Entities: {
 *     articles: { local: ..., synced: ... },
 *   }
 * }
 * You could pass state, state.Entities or state.Entities.articles.
 * @param record {ModelRecord} existing entity record
 * @return {Boolean|Array}
 */
export function getRecordPath(state, record) {
    invariant(
        isModel(record),
        'getRecordPath can only be used on records defined with the Model function'
    );
    const { stateKey, getFullStateKeyPath } = record[$modelDefinition];
    // Accept getState() functions
    if (typeof state === 'function') {
        state = state(); // eslint-disable-line
        invariant(
            record.constructor.selectors.entities(state),
            'You passed a function to getRecordPath but it did not return the expected root ' +
                'state (there is no Entities key). You should pass the getState() function from ' +
                'an action creator.'
        );
    }
    const path = getFullStateKeyPath();
    while (path.length && !get(state, path)) {
        path.shift();
    }
    const entities = path.length ? get(state, path) : state;
    invariant(
        entities.synced && entities.local,
        `Expected one of the root state, the root 'Entities' state or the ${stateKey} state`
    );
    if (record[PARTIAL_FIELDS_KEY_FIELD_NAME]) {
        // This is to handle partial records - we store partial field names on the record itself
        // so we can actually work out where it came from
        const keys = Immutable.Set(record[PARTIAL_FIELDS_KEY_FIELD_NAME]);
        const partialEntities = entities.partialRecords;
        for (const type of ['synced', 'local']) {
            const match = findRecordEntryIn(partialEntities.getIn([type, keys]), record);
            if (match) {
                return [...path, 'partialRecords', type, keys, match[0]];
            }
        }
    } else {
        for (const type of ['synced', 'local']) {
            const match = findRecordEntryIn(entities.get(type), record);
            if (match) {
                return [...path, type, match[0]];
            }
        }
    }
    return false;
}

export function isMaybeType(fieldDef): boolean {
    // No easy way to determine maybe types - only option is to read the typeName
    return !!(fieldDef[Typed.typeName] && fieldDef[Typed.typeName]().startsWith('Maybe('));
}

export function isListType(fieldDef): boolean {
    const a =
        fieldDef.constructor &&
        fieldDef.constructor.prototype[Typed.typeName] &&
        fieldDef.constructor.prototype[Typed.typeName]().startsWith('Typed.List(');
    const b =
        fieldDef.prototype &&
        fieldDef.prototype[Typed.typeName] &&
        fieldDef.prototype[Typed.typeName]().startsWith('Typed.List(');
    const c =
        fieldDef[Typed.typeSignature] && fieldDef[Typed.typeSignature]().startsWith('Typed.List(');
    return a || b || c;
}

export function getListElementType(fieldDef) {
    return fieldDef[Typed.type] || fieldDef.prototype[Typed.type];
}

export function isRecordType(fieldDef): boolean {
    return !!(
        fieldDef[Typed.typeSignature] && fieldDef[Typed.typeSignature]().startsWith('Typed.Record(')
    );
}
