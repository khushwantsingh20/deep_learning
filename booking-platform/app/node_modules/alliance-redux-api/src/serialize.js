// @flow
import * as Immutable from 'immutable';
import { Type, Typed } from 'typed-immutable';

import { isRecordType, isListType, getListElementType, isMaybeType } from './util';
import { isModelInstance, isModel, $modelDefinition } from './Model';
import { $serialize } from './Field';

import type { ModelRecord } from './flowTypes';

/**
 * Serialize supplied data according to the field definitions on modelClass
 * This respects custom fields that supply a serialize method (see Field.js)
 */
export function serializeModelData(
    modelClass: ModelRecord,
    data: {} | Immutable.Iterable<string, any>
): {} {
    // $FlowFixMe
    const modelFieldDefinitions = modelClass[$modelDefinition].structure;
    if (Immutable.Iterable.isIterable(data)) {
        // $FlowFixMe
        data = data.toJS();
    }
    return Object.keys(data).reduce((acc, fieldName) => {
        const fieldDef = modelFieldDefinitions[fieldName];
        // $FlowFixMe: guaranteed to be JS object now due to data.toJS above
        let value = data[fieldName];
        value = fieldDef ? serializeValue(value, fieldDef) : value;
        // undefined indicates no value and we shouldn't include it in the data at all
        // null could indicate the value was removed or explicitly set to no-value - we
        // need to keep this (eg. un-setting a nullable value after it was set)
        if (value !== undefined) {
            acc[fieldName] = value;
        }
        return acc;
    }, {});
}

function getConcreteType(type: Type): Type {
    if (type && typeof type == 'object' && isMaybeType(type) && type[Typed.type]) {
        return type[Typed.type];
    }
    return type;
}

export function serializeValue(value: any, fieldDef: { [typeof $serialize]: (value: any) => any }) {
    if (value == null) {
        return value;
    }
    if (fieldDef[$serialize]) {
        return fieldDef[$serialize](value);
    }
    let concreteFieldDef = getConcreteType(fieldDef);
    if (concreteFieldDef[$serialize]) {
        return concreteFieldDef[$serialize](value);
    }
    if (isModelInstance(value)) {
        return value.serialize();
    }
    if (isModel(concreteFieldDef)) {
        const modelFieldDefinitions = concreteFieldDef[$modelDefinition].structure;
        return serializeFields(value, modelFieldDefinitions);
    }
    if (isRecordType(concreteFieldDef)) {
        return serializeFields(value, concreteFieldDef[Typed.type]);
    }
    if (
        Array.isArray(value) ||
        (value && typeof value === 'object' && Immutable.Iterable.isIterable(value))
    ) {
        if (isListType(concreteFieldDef)) {
            concreteFieldDef = getListElementType(concreteFieldDef);
        }
        const iterableValues = [];
        for (const v of value) {
            iterableValues.push(serializeValue(v, concreteFieldDef));
        }
        return iterableValues;
    }
    return value;
}

export function serializeFields(source: {}, fieldDefs: {}) {
    const data = {};
    Object.keys(fieldDefs).forEach(key => {
        let value = source[key];
        const fieldDef = fieldDefs[key];
        value = serializeValue(value, fieldDef);
        if (value != null) {
            data[key] = value;
        }
    });
    return data;
}
