// @flow
import invariant from 'invariant';
import * as Immutable from 'immutable';
import { List, Typed, Record, Maybe, Any } from 'typed-immutable';
import { typeOf as typedImmutableTypeOf } from 'typed-immutable/lib/typed';
import { Schema, arrayOf } from 'normalizr';

import { serializeFields } from './serialize';
import { isRecord, isMaybeType } from './util';
import { NoCache } from './fetchCache';
import { $serialize, $parse } from './Field';
import { $foreignKey } from './ForeignKeyField';
import type {
    $SymbolSchema,
    ModelDescriptor,
    ForeignKeyDescriptor,
    ModelOptions,
    ModelRecord,
    OrderedModelDefinition,
    LiveUpdateListener,
} from './flowTypes';

import { UUIDType } from './fieldTypes';

// This the name of an actual field on any partial record that contains
export const PARTIAL_FIELDS_KEY_FIELD_NAME = '@@alliance-redux-api/partialFields';
export const $modelDefinition = Symbol.for('@@alliance-redux-api/model');

const $isModel = Symbol.for('@@alliance-redux-api/isModel');
const $isModelInstance = Symbol.for('@@alliance-redux-api/isModelInstance');
const $schemaAssignEntity = Symbol.for('@@alliance-redux-api/schemaAssignEntity');

export function isModel(value: any): boolean {
    return value && (typeof value == 'object' || typeof value == 'function') && value[$isModel];
}

export function isModelInstance(value: any): boolean {
    return (
        value && (typeof value == 'object' || typeof value == 'function') && value[$isModelInstance]
    );
}

function buildModelSchema(
    descriptor: ModelDescriptor,
    schemaName: string,
    idFieldName: string | Array<string>
) {
    const fieldParsers: Array<{ key: string, parse: (value: mixed) => mixed }> = [];
    const assignEntityFieldNameMap = {};
    let idAttribute = idFieldName;
    if (Array.isArray(idFieldName)) {
        // Implementation here must match what ModelRecord.getId specifies
        idAttribute = entity => {
            // Flow needed this in the arrow func otherwise complained
            if (Array.isArray(idFieldName)) {
                return idFieldName.map(fieldName => entity[fieldName]).join('_');
            }
            return idFieldName;
        };
    }
    const schema = new Schema(schemaName, { idAttribute });
    const schemaDefinition: { [key: string]: Normalizr$Schema } = {};
    Object.keys(descriptor).forEach(key => {
        const field = descriptor[key];
        if (field[$parse]) {
            fieldParsers.push({ key, parse: field[$parse] });
        }
        if (field && field.prototype && field.prototype[$foreignKey]) {
            const foreignKey: ForeignKeyDescriptor = field.prototype[$foreignKey];
            const { many = false, schemaFieldName = key } = foreignKey;
            schemaDefinition[schemaFieldName] = foreignKey.target[$modelDefinition].schema;
            if (many) {
                schemaDefinition[schemaFieldName] = arrayOf(schemaDefinition[schemaFieldName]);
            }
            if (schemaFieldName !== key) {
                assignEntityFieldNameMap[schemaFieldName] = key;
            }
        }
    });
    function assignEntity(normalized, key, entity, what, entitySchema) {
        // If this is a nested schema defer to its schema assign implementation
        const nestedAssignEntity = entitySchema[$schemaAssignEntity];
        if (nestedAssignEntity && nestedAssignEntity !== assignEntity) {
            nestedAssignEntity(normalized, key, entity, what, entitySchema);
            return;
        }
        if (assignEntityFieldNameMap[key]) {
            const recordFieldName = assignEntityFieldNameMap[key];
            normalized[recordFieldName] = entity; // eslint-disable-line
        } else {
            normalized[key] = entity; // eslint-disable-line
        }
    }
    schema.define(schemaDefinition);
    // Track assign entity on schema so that we can handle nested foreign
    // keys by deferring to nested schema assignEntity
    // $FlowFixMe
    schema[$schemaAssignEntity] = assignEntity;

    return {
        assignEntity,
        schema,
        fieldParsers,
    };
}

// This is added to by Model() if the liveUpdateModel option is specified
export const liveUpdateModels: { [key: string]: ModelRecord } = {};
export const liveUpdateListeners: Array<LiveUpdateListener> = [];

export const modelClassMap: { [key: string]: ModelRecord } = {};

/**
 *
 * @param stateKey {String} this is the key this model will appear under in the
 * state tree. Used for two things; creating selectors and for normalizing
 * returned data from API.
 */
export default function Model( // eslint-disable-line brace-style
    descriptor: ModelDescriptor,
    stateKey: string,
    label: string,
    options: ModelOptions = {}
): ModelRecord {
    invariant(stateKey, 'stateKey must be provided');
    invariant(label, 'Label must be provided.');

    const {
        idFieldName = 'id',
        endpoint = stateKey,
        modelId = stateKey,
        transformResponse,
        liveUpdateModel,
        sortBy,
        liveUpdateListener,
        orderedModel,
        cache = new NoCache(),
    } = options;
    let IdType;
    if (Array.isArray(idFieldName)) {
        const missingFieldNames = [];
        idFieldName.forEach(fieldName => {
            if (!descriptor[fieldName]) {
                missingFieldNames.push(fieldName);
            }
        });
        IdType = String;
        invariant(
            missingFieldNames.length === 0,
            `You specified a compound id for '${label}' but the following fields were ` +
                `not found in the model descriptor: ${missingFieldNames.join(', ')}\n` +
                'Check for spelling mistakes or missing fields'
        );
    } else {
        invariant(
            descriptor[idFieldName],
            `Model id field of '${idFieldName}' not found on descriptor for '${label}'. ` +
                "You either need to define a field with that name or provide an 'idFieldName' " +
                'option which can be a single field name or a list of field names for compound ids.'
        );
        IdType = descriptor[idFieldName];
    }
    const { schema, fieldParsers, assignEntity } = buildModelSchema(
        descriptor,
        stateKey,
        idFieldName
    );

    let pinnedFieldNames: Immutable.List<string> = Immutable.List(
        Array.isArray(idFieldName) ? idFieldName : [idFieldName]
    );
    if (orderedModel) {
        pinnedFieldNames = pinnedFieldNames.push(orderedModel.orderFieldName);
        if (orderedModel.orderWithRespectTo) {
            pinnedFieldNames = pinnedFieldNames.push(...orderedModel.orderWithRespectTo);
        }
    }

    // Add a field for tracking unique ID against every model instance
    const structure = Object.assign({}, descriptor, { modelUUID: UUIDType });
    function buildModelRecordClass(structure, label) {
        class ModelRecordClass extends Record(structure, label) {
            constructor(data: { [key: string]: mixed }) {
                const transformedData = fieldParsers.reduce(
                    (acc, { key, parse }) => Object.assign(acc, { [key]: parse(data[key]) }),
                    {}
                );
                super(Object.assign({}, data, transformedData));
            }

            getId(): string | number {
                if (Array.isArray(idFieldName)) {
                    // Implementation here must match what buildModelSchema specifies
                    // in the idAttribute function
                    return idFieldName
                        .map(fieldName => {
                            const serialize = descriptor[fieldName][$serialize];
                            const value = this.get(fieldName);
                            if (serialize) {
                                return serialize(value);
                            }
                            return value;
                        })
                        .join('_');
                }
                const serialize = descriptor[idFieldName][$serialize];
                const value = this.get(idFieldName);
                if (serialize) {
                    return serialize(value);
                }
                return value;
            }

            serialize(): { [key: string]: mixed } {
                return serializeFields(this, descriptor);
            }

            isOrderedModel() {
                return !!orderedModel;
            }

            static isOrderedModel() {
                return !!orderedModel;
            }

            getOrderWithRespectToValue() {
                if (!orderedModel) {
                    throw new Error(
                        'getOrderWithRespectToValue is only valid for ' + 'ordered models'
                    );
                }
                if (!orderedModel.orderWithRespectTo) {
                    return null;
                }
                const value = {};
                orderedModel.orderWithRespectTo.forEach(fieldName => {
                    value[fieldName] = this.get(fieldName);
                });
                return value;
            }
        }
        if (orderedModel) {
            invariant(
                descriptor[orderedModel.orderFieldName] !== undefined,
                `Specified orderFieldName ${orderedModel.orderFieldName} does not exist on model`
            );
            if (orderedModel.orderWithRespectTo) {
                orderedModel.orderWithRespectTo.forEach(fieldName =>
                    invariant(
                        descriptor[fieldName] !== undefined,
                        `Specified field ${fieldName} in orderWithRespectTo to does not exist on model`
                    )
                );
            }
        }
        // $FlowFixMe
        ModelRecordClass[$isModel] = ModelRecordClass.prototype[$isModel] = true;
        ModelRecordClass.prototype[$isModelInstance] = true;
        // $FlowFixMe
        ModelRecordClass[$modelDefinition] = ModelRecordClass.prototype[$modelDefinition] = {
            structure,
            modelId,
            cache,
            label,
            IdType,
            stateKey,
            idFieldName,
            transformResponse,
            endpoint: endpoint.replace(/\/$/, ''),
            liveUpdateModel,
            sortBy,
            liveUpdateListener,
            orderedModel,
            schema,
            schemaOptions: {
                assignEntity,
            },
            getFullStateKeyPath() {
                throw new Error('getFullStateKeyPath used before initialized');
            },
            pinnedFieldNames,
        };
        ModelRecordClass.buildSelectors = options.buildSelectors;
        // This will be replaced when createModelsReducer is run
        ModelRecordClass.selectors = null;

        // Proxy this to catch common error of creating model but not registering it
        if (typeof Proxy == 'function') {
            ModelRecordClass.selectors = new Proxy(
                {},
                {
                    get() {
                        console.error(
                            // eslint-disable-line
                            'You tried to use a selector before the selectors were ' +
                                "created. This probably means you haven't added your " +
                                'Model to Redux via the createModelsReducer() function. ' +
                                'See your core/reducers.js or equivalent file. If your selectors ' +
                                'have interdependencies then order matters - avoid this where ' +
                                'possible otherwise ensure parameter order to createModelsReducer is ' +
                                'correct to satisfy these dependencies'
                        );
                    },
                }
            );
        }
        return ModelRecordClass;
    }

    const ModelRecordClass = buildModelRecordClass(structure, label);
    const partialStructure = Object.keys(structure).reduce((acc, fieldName) => {
        acc[fieldName] = structure[fieldName];
        if (
            !isMaybeType(acc[fieldName]) &&
            typedImmutableTypeOf(acc[fieldName]) !== Any &&
            fieldName !== 'modelUUID'
        ) {
            acc[fieldName] = Maybe(acc[fieldName]);
        }
        return acc;
    }, {});
    partialStructure[PARTIAL_FIELDS_KEY_FIELD_NAME] = List(String);
    class PartialModelRecordClass extends buildModelRecordClass(
        partialStructure,
        `${label} (Partial)`
    ) {
        toJS() {
            const values = super.toJS();
            const finalValues = {};
            for (const fieldName of values[PARTIAL_FIELDS_KEY_FIELD_NAME]) {
                finalValues[fieldName] = values[fieldName];
            }
            pinnedFieldNames.forEach(fieldName => {
                finalValues[fieldName] = values[fieldName];
            });
            return finalValues;
        }
    }
    // $FlowFixMe
    ModelRecordClass[$modelDefinition].partialRecordClass = PartialModelRecordClass;

    if (liveUpdateModel) {
        liveUpdateModels[liveUpdateModel] = ModelRecordClass;
    }
    if (liveUpdateListener) {
        liveUpdateListeners.push(liveUpdateListener);
    }

    modelClassMap[modelId] = ModelRecordClass;

    return ModelRecordClass;
}
