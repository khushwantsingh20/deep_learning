import * as Immutable from 'immutable';
import { typeOf, Record, Map as TypedMap, Any, Typed } from 'typed-immutable';
import invariant from 'invariant';
import { createSelector } from 'reselect';
import fromPairs from 'lodash/fromPairs';
import getIn from 'lodash/get';
import memoize from 'lodash/memoize';

import uid from './uid';
import normalize from './normalize';
import createReducer, { stringify } from './createReducer';
import reduceReducers from './reduceReducers';
import createModelReducer, { $modelReducerDefinition } from './createModelReducer';
import createLoadingReducer from './createLoadingReducer';
import { $modelDefinition } from './Model';
import modelReducerHandlers, { entitiesPayloadStateTransition } from './modelReducerHandlers';

const uuidLength = uid.v4().length;

const $isRootEntitiesState = Symbol.for('@alliance-redux-api/rootEntitiesState');

/**
 * Create final models reducer.
 *
 * @param {...ModelRecord|Function} either a ModelRecord (a record created using
 * Model) or a reducer create with createModelReducer.
 */
export default function createModelsReducer(modelReducers, entitiesStateKey = ['Entities']) {
    if (!Array.isArray(entitiesStateKey)) {
        let entitiesStateKey = [entitiesStateKey];
    }
    const stateStructure = {};
    const modelRecordsByKey = {};
    const individualModelReducers = modelReducers.map(reducer => {
        if (reducer[$modelDefinition]) {
            reducer = createModelReducer(reducer); // eslint-disable-line
        }
        const definition = reducer[$modelReducerDefinition];
        invariant(
            definition,
            'All reducers passed to createModelsReducer must be created ' +
                `with createModelReducer. Invalid reducer received: ${stringify(reducer)}`
        );
        invariant(
            !stateStructure[definition.stateKey],
            `Same state key used for 2 Model classes: ${definition.stateKey}`
        );
        stateStructure[definition.stateKey] = definition.modelStateRecord;
        modelRecordsByKey[definition.stateKey] = definition.modelRecord;
        return [definition.stateKey, reducer];
    });

    // Allow selectors to work from Entities root rather than just state root
    const rootSelector = state => {
        invariant(state && state.constructor, 'Invalid state object passed to rootSelector');
        if (state.constructor && state.constructor[$isRootEntitiesState]) {
            return state;
        }
        return getIn(state, entitiesStateKey);
    };
    Object.keys(modelRecordsByKey).forEach(key => {
        const record = modelRecordsByKey[key];
        const {
            stateKey,
            orderedModel,
            structure,
            idFieldName,
            IdType,
            sortBy = entity => {
                return orderedModel ? entity.get(orderedModel.orderFieldName) : entity.getId();
            },
        } = record[$modelDefinition];
        // This is so we can avoid hardcoding the base state key everywhere
        // Allows things to look it up on model
        record[$modelDefinition].getFullStateKeyPath = () => [...entitiesStateKey, stateKey];
        record[$modelDefinition].partialRecordClass[$modelDefinition].getFullStateKeyPath =
            record[$modelDefinition].getFullStateKeyPath;
        const entitySelector = createSelector(
            rootSelector,
            entities => entities.get(key)
        );
        function replaceGetWithTypedGet(mapInstance) {
            // Replace get() so it has same behaviour as typed immutable Map
            // in converting the value of the key if required.
            // This is particularly useful in converting "325" => 325
            const originalGet = mapInstance.get.bind(mapInstance);
            mapInstance.get = (key, ...rest) => {
                let convertedKey = key;
                // Hacky workaround so that items in 'local' - which are indexed
                // by uuid - don't go through the id field read fn.
                if (typeof key == 'string' && key.length !== uuidLength) {
                    convertedKey = typeOf(IdType)[Typed.read](key);
                }
                return originalGet(convertedKey);
            };
            return mapInstance;
        }
        const synced = createSelector(
            entitySelector,
            s => replaceGetWithTypedGet(s.synced.sortBy(sortBy))
        );
        const local = createSelector(
            entitySelector,
            s => replaceGetWithTypedGet(s.local.sortBy(sortBy))
        );
        const loading = createSelector(
            entitySelector,
            s => s.loading
        );
        const partialRecordsSynced = createSelector(
            entitySelector,
            s => s.partialRecords.synced
        );
        const partialRecordsLocal = createSelector(
            entitySelector,
            s => s.partialRecords.local
        );
        const getPartialState = (fields, state) => {
            const invalidFields = fields.filter(fieldName => !(fieldName in structure));
            if (invalidFields.length > 0) {
                throw new Error(
                    `Some field(s) passed to partialFields selector are not valid: ${invalidFields.join(
                        ', '
                    )}`
                );
            }
            const idFieldNames = [].concat(idFieldName);
            const fieldsNoId = fields.filter(fieldName => !idFieldNames.includes(fieldName));
            const fieldsWithId = [...fieldsNoId, ...idFieldNames];
            // For historical reasons we support with or without the id field name(s) - they are equivalent. We always
            // have id even if not explicitly specified so we are guaranteed to always have this data.
            const key1 = new Immutable.Set(fieldsNoId);
            const key2 = new Immutable.Set(fieldsWithId);
            return state.get(key1) || state.get(key2);
        };
        const buildPartialSelector = partialKeySelector =>
            createSelector(
                partialKeySelector,
                state =>
                    memoize(
                        fields => {
                            let values = getPartialState(fields, state);
                            if (!values) {
                                return new Immutable.OrderedMap();
                            }
                            return replaceGetWithTypedGet(values.sortBy(sortBy));
                        },
                        fields => fields.toString()
                    )
            );
        const partialFields = {
            local: buildPartialSelector(partialRecordsLocal),
            synced: buildPartialSelector(partialRecordsSynced),
        };
        partialFields.all = createSelector(
            [partialRecordsSynced, partialRecordsLocal],
            (local, synced) =>
                memoize(
                    fields => {
                        const a = getPartialState(fields, local);
                        const b = getPartialState(fields, synced);
                        if (!a && !b) {
                            return new Immutable.OrderedMap();
                        }
                        if (!b) return replaceGetWithTypedGet(a.toMap().sortBy(sortBy));
                        if (!a) return replaceGetWithTypedGet(b.toMap().sortBy(sortBy));
                        return replaceGetWithTypedGet(
                            a
                                .toMap()
                                .merge(b)
                                .sortBy(sortBy)
                        );
                    },
                    fields => fields.toString()
                )
        );
        const all = createSelector(
            [synced, local],
            (a, b) => {
                // NOTE: This results in a plain typed immutable OrderedMap
                return replaceGetWithTypedGet(
                    a
                        .toMap()
                        .merge(b)
                        .sortBy(sortBy)
                );
            }
        );
        const meta = createSelector(
            entitySelector,
            s => s.meta
        );
        const syncingEntityUUIDs = createSelector(
            loading,
            l => l.syncingEntityUUIDs
        );
        const isFetching = createSelector(
            loading,
            l => l.isFetching
        );
        let groupedByOrderWithRespectTo = () => {
            throw new Error('Model is not ordered or has no orderWithRespectTo fields set');
        };
        if (orderedModel && orderedModel.orderWithRespectTo) {
            const keyStructure = {};
            orderedModel.orderWithRespectTo.forEach(fieldName => {
                keyStructure[fieldName] = structure[fieldName];
            });
            const keyRecord = Record(keyStructure, `${key} Order By Key`);
            // We use Any here rather than a TypedMap(IdType, record) so that
            // we can apply sorting and return an OrderedMap (see groupBy below)
            class GroupedEntitiesMap extends TypedMap(keyRecord, Any) {
                get(keyData) {
                    return super.get(new keyRecord(keyData));
                }
            }
            groupedByOrderWithRespectTo = createSelector(
                all,
                entities =>
                    new GroupedEntitiesMap(
                        entities
                            .groupBy(
                                entity =>
                                    new keyRecord(
                                        fromPairs(
                                            orderedModel.orderWithRespectTo.map(fieldName => [
                                                fieldName,
                                                entity.get(fieldName),
                                            ])
                                        )
                                    )
                            )
                            .map(groupedEntities =>
                                groupedEntities.sortBy(groupedEntity =>
                                    groupedEntity.get(orderedModel.orderFieldName)
                                )
                            )
                    )
            );
        }
        const selectors = {
            synced,
            local,
            all,
            partialFields,
            meta,
            loading,
            isFetching,
            syncingEntityUUIDs,
            groupedByOrderWithRespectTo,
            entities: rootSelector,
        };
        if (record.buildSelectors) {
            const additionalSelectors = record.buildSelectors(selectors);
            invariant(
                additionalSelectors && typeof additionalSelectors == 'object',
                'buildSelectors must return an object of selector name => selector'
            );
            Object.assign(selectors, additionalSelectors);
        }
        record.selectors = record[$modelDefinition].partialRecordClass.selectors = selectors;
    });
    const EntityState = Record(stateStructure, 'Entities');
    EntityState[$isRootEntitiesState] = true;

    const reducer = createReducer(EntityState, modelReducerHandlers, initialState => {
        // This function is only called once when initial data is populate from server
        // Transform each provided entity using normalize
        let transformedData = new EntityState();
        for (const key of Object.keys(initialState)) {
            const recordClass = modelRecordsByKey[key];
            if (!recordClass) {
                console.warn(
                    // eslint-disable-line
                    `Unexpected entity key '${key}' in initial state. Is there a typo?`
                );
                continue;
            }
            const { entities } = normalize(recordClass, initialState[key]);
            transformedData = entitiesPayloadStateTransition(transformedData, {
                payload: { entities },
            });
        }
        return transformedData;
    });

    return reduceReducers(reducer, ...individualModelReducers, createLoadingReducer());
}
