import Immutable from 'immutable';

export class NoCache {
    /**
     * Get a value from cache
     * @param getState {Function} get current redux state
     * @param filters {Object|Number|String} current filter (either object for a fetchEntities call or an id for fetchEntity)
     * @param selectFromRedux {Function} function to select current entity (for fetchEntity) or entities (for fetchEntities)
     * from redux. Can use this to determine if anything in redux has changed since last time (eg. may want to call
     * fetchEntities again if new items have been added as could change pagination).
     * @returns {null}
     */
    get(getState, filters, selectFromRedux) {
        return null;
    }

    /**
     * Set a value in the cache
     * @param getState {Function} get current redux state
     * @param filters {Object|Number|String} current filter (either object for a fetchEntities call or an id for fetchEntity)
     * @param selectFromRedux {Function} function to select current entity (for fetchEntity) or entities (for fetchEntities)
     * from redux. Can use this to determine if anything in redux has changed since last time (eg. may want to cache the
     * return value of this so can compare in `get` to see if new items have been added since last call)
     * @returns {null}
     */
    set(getState, filters, value, selectFromRedux) {
        return null;
    }
}

export class PermanentCache {
    constructor() {
        this.cache = Immutable.Map();
    }

    get(getState, filters) {
        return this.cache.get(Immutable.fromJS(filters));
    }

    set(getState, filters, value) {
        // Using immutable structure as key in a immutable map means lookups
        // use deep equality checks not just reference check so we can safely
        // rely on the same filters passed in resulting in same value coming
        // out
        this.cache = this.cache.set(Immutable.fromJS(filters), value);
    }
}
