// @flow
import type { TypeFunction, SerializeFunction } from './flowTypes';

import { Typed, typeOf } from 'typed-immutable/lib/typed';
export const $serialize = Symbol.for('@@alliance-redux-api/serialize');
export const $parse = Symbol.for('@@alliance-redux-api/parse');

export default function Field(type: TypeFunction, serialize: SerializeFunction): TypeFunction {
    const finalType = typeOf(type);
    // Create a wrapped type so that we aren't modifying one of the core types
    // directly when we assign $serialize below. The typeOf call is because
    // this is what Typed Immutable does underthe hood - in the case of Maybe
    // this is what it uses as the underlying type class. In order to have
    // access to the serialize function in serializeModelData we need to ensure
    // that the serialize function is stored against the final type.
    const wrappedType = typeOf(
        Typed(finalType[Typed.label], value => {
            return finalType[Typed.read](value);
        })
    );
    // This is always on
    wrappedType[$serialize] = serialize; // eslint-disable-line
    return wrappedType;
}
