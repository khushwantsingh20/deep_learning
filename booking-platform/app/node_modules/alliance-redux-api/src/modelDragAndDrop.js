import { findDOMNode } from 'react-dom';
import { DropTarget, DragSource } from 'react-dnd';
import invariant from 'invariant';
import { connect } from 'react-redux';
import { bindActionCreators, compose } from 'redux';
import { getRecordPath } from './util';
import { reorderEntity, updateEntityOrdering } from './actions';
import { $modelDefinition } from './Model';

// These are used to connect relevant components to give access
// to state and bound redux actions necessary to handle re-ordering
function mapStateToProps(state) {
    return {
        // Only include Entities, not full app state. This helps PureComponent's
        // only re-render if something in Entities changes vs anything in state
        // Particularly noticeable when using something like redux-form which
        // changes state on every keypress. This could potentially be optimised
        // further, ie. only include entities the DND accepts.
        // TODO: With changes to allow customisation of where sits in redux
        // state tree this is now hard - just use full state
        modelDNDState: state,
    };
}

function mapDispatchToProps(dispatch) {
    return {
        modelDNDActions: bindActionCreators(
            {
                reorderEntity,
                updateEntityOrdering,
            },
            dispatch
        ),
    };
}

const itemTypesCache = {};
/**
 * Generate unique item types for entity model classes
 */
function getItemType(item) {
    if (typeof item == 'object' || typeof item == 'function') {
        if (!itemTypesCache[item]) {
            itemTypesCache[item] = `ITEM_${Object.keys(itemTypesCache).length}`;
        }
        return itemTypesCache[item];
    }
    return item;
}

function isOfModelType(entity, modelClass) {
    let modelId;
    if (typeof modelClass == 'string') {
        modelId = modelClass;
    } else {
        modelId = modelClass[$modelDefinition].modelId;
    }
    return entity[$modelDefinition].modelId === modelId;
}

/**
 * Decorate a component so it accepts DND from specified models
 * @param getTarget {Function} function that gets passed the props for the
 * component dropping on and should return the relevant model instance OR
 * object contains relevant fields to specifying group by ordering for
 * dragged entity. For example - if you are dragging a CheckListItem that
 * is ordered by section and the drop target was a section you might return
 * an object that looks like: { sectionId: props.section.id } - this is
 * sufficient to add the CheckListItem to that section (but no more specific
 * ordering than that - this is usually used when there are no other items
 * in that list for you to order against)
 * @param Array {acceptsModelConfig} An array of values where each value is
 * either an ModelRecord class (not an instance) OR a 2-element array where
 * the first element the ModelRecord class and the second is a configuration
 * object. Valid configuration object parameters are:
 * - shallow Boolean if true will only handle drops shallowly (ie. if the
 *   drop target has any children that are also drop targets for the dragged
 *   item it will not do anything)
 * - getGroupByFields Function a function that will be passed the return
 *   value of getTarget and should return an object with keys that match
 *   the model orderWithRespectTo field names with associated values.
 * @return Function function you pass your component to
 */
export function modelDropTarget(getTarget, acceptsModelConfig) {
    const spec = {
        hover(props, monitor, component) {
            const monitorItem = monitor.getItem();
            const { draggedEntity } = monitorItem;
            // TODO: Assumes always vertical re-ordering within a list!
            // (dragging across multiple columns is fine so long as each column
            // is arranged vertically)
            // Determine rectangle on screen
            if (component == null) {
                throw new Error(
                    'Component is null - this likely means you are using a stateless component. Convert it to a class that extends React.Component to resolve.'
                );
            }
            const hoverBoundingRect = findDOMNode(component).getBoundingClientRect();
            // Get vertical middle
            const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
            // Determine mouse position
            const clientOffset = monitor.getClientOffset();
            // Get pixels to the top
            const hoverClientY = clientOffset.y - hoverBoundingRect.top;

            for (const modelSpec of acceptsModelConfig) {
                let modelClass;
                let config = {};
                if (Array.isArray(modelSpec)) {
                    modelClass = modelSpec[0];
                    if (modelSpec.length > 1) {
                        config = modelSpec[1];
                    }
                } else {
                    modelClass = modelSpec;
                }
                if (isOfModelType(draggedEntity, modelClass)) {
                    if (config.shallow && !monitor.isOver({ shallow: true })) {
                        return;
                    }
                    let timeSinceLastReorder = Number.POSITIVE_INFINITY;
                    if (monitorItem.lastOverDate) {
                        timeSinceLastReorder = new Date() - monitorItem.lastOverDate;
                    }
                    // TODO: This may be unnecessary now that check distance below
                    if (timeSinceLastReorder < 100) return;
                    // This could be an entity, eg a TodoItem, or a object
                    // of field values, eg. a ScheduleDay which defines the
                    // grouping of TodoItem's.
                    const entityOrFields = getTarget(props);
                    invariant(
                        entityOrFields,
                        'getTarget did not return an entity or object of fields'
                    );

                    // Fetch latest version of entity as if it has already
                    // been re-ordered as part of this drag the data we
                    // have stored will be stale
                    const path = getRecordPath(props.modelDNDState, draggedEntity);
                    const draggedEntityLatest = props.modelDNDState[path.shift()].getIn(path);
                    if (isOfModelType(entityOrFields, modelClass)) {
                        // Same entity; order against each other
                        if (draggedEntity.modelUUID === entityOrFields.modelUUID) return;
                        const { orderedModel } = entityOrFields[$modelDefinition];
                        const { modelDNDActions } = props;
                        const dragIndex = draggedEntityLatest[orderedModel.orderFieldName];
                        const targetIndex = entityOrFields[orderedModel.orderFieldName];
                        // Only perform the move when the mouse has crossed half of the items height
                        // When dragging downwards, only move when the cursor is below 50%
                        // When dragging upwards, only move when the cursor is above 50%
                        monitorItem.dragDirection = dragIndex < targetIndex ? 'Down' : 'Up';
                        // Dragging downwards
                        if (dragIndex < targetIndex && hoverClientY < hoverMiddleY) {
                            return;
                        }
                        // Dragging upwards
                        if (dragIndex > targetIndex && hoverClientY > hoverMiddleY) {
                            return;
                        }
                        modelDNDActions.reorderEntity(draggedEntity, entityOrFields);
                        monitorItem.lastOverDate = new Date();
                        return;
                    }
                    // Otherwise reordering to a different grouping
                    const fields = config.getGroupByFields(entityOrFields);
                    // Check it doesn't already belong to the list defined by
                    // field values in entityOrFields
                    const isSame = Object.keys(fields).reduce(
                        (acc, fieldName) =>
                            acc && fields[fieldName] === draggedEntityLatest.get(fieldName),
                        true
                    );
                    if (isSame) {
                        return;
                    }

                    const { modelDNDActions } = props;
                    modelDNDActions.reorderEntity(draggedEntity, fields);
                    monitorItem.lastOverDate = new Date();
                }
            }
        },
    };

    function targetCollect(conn, monitor) {
        return {
            connectDropTarget: conn.dropTarget(),
            draggedItem: monitor.getItem(),
            isDraggedItemOver: monitor.isOver(),
        };
    }

    const itemTypes = acceptsModelConfig.map(config => {
        if (Array.isArray(config)) {
            return getItemType(config[0]);
        }
        return getItemType(config);
    });
    // Returns a function that accepts a component - injects normal
    // React DnD Props (eg. connectDropTarget)
    return compose(
        connect(
            mapStateToProps,
            mapDispatchToProps
        ),
        DropTarget(itemTypes, spec, targetCollect)
    );
}

/**
 * Decorate a component so it can be dragged and dropped on drop targets (as
 * defined with modelDropTarget)
 * @param modelClassOrType {ModelRecord|String} A model class (not an instance)
 * or string. This is used as the DND type and must match types specified in
 * a modelDropTarget acceptsModelConfig parameter otherwise nothing will happen.
 * @param getFromProps {Function} return the dragged entity from props
 * @return Function function you pass your component to
 */
export function modelDragSource(modelClassOrType, getFromProps) {
    const itemSource = {
        beginDrag(props) {
            return {
                draggedEntity: getFromProps(props),
            };
        },

        endDrag(props, monitor) {
            const item = monitor.getItem();
            props.modelDNDActions.updateEntityOrdering(item.draggedEntity);
        },
    };

    function sourceCollect(conn) {
        return {
            connectDragSource: conn.dragSource(),
            connectDragPreview: conn.dragPreview(),
        };
    }

    // Returns a function that accepts a component - injects normal
    // React DnD Props (eg. connectDragPreview, connectDragSource)
    return compose(
        connect(
            mapStateToProps,
            mapDispatchToProps
        ),
        DragSource(getItemType(modelClassOrType), itemSource, sourceCollect)
    );
}
