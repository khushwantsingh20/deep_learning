import { Set, OrderedMap } from 'immutable';
import { actionTypes } from './actions';
import { $modelDefinition, isModel, PARTIAL_FIELDS_KEY_FIELD_NAME } from './Model';
import { getRecordPath } from './util';

function deleteEntitiesStateTransition(state, stateKey, ids) {
    let nextState = state;
    for (const id of ids) {
        nextState = nextState.deleteIn([stateKey, 'synced', id]);
    }
    // Remove any partial records that might exist as well
    nextState = nextState.updateIn(
        [stateKey, 'partialRecords', 'synced'],
        partialRecordsByFieldNames => {
            return partialRecordsByFieldNames.map((partialRecords, fieldNames) => {
                return partialRecords.withMutations(s => {
                    ids.forEach(id => {
                        s.delete(id);
                    });
                });
            });
        }
    );
    return nextState;
}

/**
 * Transition provided state to next state based on entities payload
 * This is used for both initial data and API calls.
 * @param state {EntitiesState} current state object
 * @param action {Object}
 * @return {EntitiesState} next state
 */
export function entitiesPayloadStateTransition(
    state,
    { payload, error, meta: { partialRecordFieldNames, stateKey: fetchedEntityStateKey } = {} }
) {
    if (error) {
        console.warn(
            // eslint-disable-line
            'Unexpected error doing state transition',
            payload
        );
        return state;
    }
    let nextState = state;
    Object.keys(payload.entities || {}).forEach(stateKey => {
        const entities = Object.assign({}, payload.entities[stateKey]);
        if (nextState.has(stateKey)) {
            if (!partialRecordFieldNames) {
                const entitiesSynced = nextState.getIn([stateKey, 'synced']);
                if (entitiesSynced && entitiesSynced.size) {
                    Object.keys(entities).forEach(id => {
                        // Make sure modelUUID is retained across updates
                        const modelUUID = nextState.getIn([
                            stateKey,
                            'synced',
                            Number(id),
                            'modelUUID',
                        ]);
                        if (modelUUID) {
                            entities[id] = { ...entities[id], modelUUID };
                        }
                    });
                }
                nextState = nextState.mergeIn([stateKey, 'synced'], entities);
                nextState = nextState
                    .getIn([stateKey, 'optimisticUpdates'])
                    .reduce(
                        (s, update) => applyOptimisticUpdate(s, update.statePath, update.data),
                        nextState
                    );
                const ids = Object.keys(entities);
                nextState = nextState.updateIn(
                    [stateKey, 'partialRecords', 'synced'],
                    partialRecordsByFieldNames => {
                        return partialRecordsByFieldNames.map((partialRecords, fieldNames) => {
                            const pinnedFieldNames = partialRecords.getPinnedFieldNames();
                            return partialRecords.withMutations(s => {
                                ids.forEach(id => {
                                    const allValues = entities[id];
                                    const pinnedValues = pinnedFieldNames.reduce(
                                        (acc, fieldName) => {
                                            acc[fieldName] = allValues[fieldName];
                                            return acc;
                                        },
                                        {
                                            [PARTIAL_FIELDS_KEY_FIELD_NAME]: fieldNames.toList(),
                                        }
                                    );
                                    const values = fieldNames.reduce((acc, fieldName) => {
                                        acc[fieldName] = entities[id][fieldName];
                                        return acc;
                                    }, pinnedValues);
                                    s.set(id, values);
                                });
                            });
                        });
                    }
                );
            } else {
                const entitiesSynced = nextState.getIn([stateKey, 'partialRecords', 'synced']);
                const partialFieldsKey = new Set(partialRecordFieldNames);
                if (entitiesSynced && entitiesSynced.size) {
                    Object.keys(entities).forEach(id => {
                        // Make sure modelUUID is retained across updates
                        const modelUUID = nextState.getIn([
                            stateKey,
                            'partialRecords',
                            'synced',
                            partialFieldsKey,
                            Number(id),
                            'modelUUID',
                        ]);
                        const nextData = {
                            ...entities[id],
                            [PARTIAL_FIELDS_KEY_FIELD_NAME]: partialRecordFieldNames,
                        };
                        if (modelUUID) {
                            nextData.modelUUID = modelUUID;
                        }
                        entities[id] = nextData;
                    });
                } else {
                    Object.keys(entities).forEach(id => {
                        entities[id] = {
                            ...entities[id],
                            [PARTIAL_FIELDS_KEY_FIELD_NAME]: partialRecordFieldNames,
                        };
                    });
                }
                nextState = nextState.mergeIn(
                    [stateKey, 'partialRecords', 'synced', partialFieldsKey],
                    entities
                );
            }
        } else {
            console.warn(
                // eslint-disable-line
                `Unknown entity name '${stateKey}' encountered. This should ` +
                    'probably have a key in the entities state. Consider creating ' +
                    'the relevant reducer with createModelReducer and passing ' +
                    'that to createModelsReducer.'
            );
        }
    });
    Object.keys(payload.deletedEntities || {}).forEach(stateKey => {
        if (nextState.has(stateKey)) {
            const ids = payload.deletedEntities[stateKey];
            nextState = deleteEntitiesStateTransition(nextState, stateKey, ids);
        } else {
            console.warn(
                // eslint-disable-line
                `Unknown entity name '${stateKey}' encountered. This should ` +
                    'probably have a key in the entities state. Consider creating ' +
                    'the relevant reducer with createModelReducer and passing ' +
                    'that to createModelsReducer.'
            );
        }
    });
    if (partialRecordFieldNames) {
        // If no records were returned on a partial request still update the redux state with
        // an empty map so that selectors that expect it to have data have it AND so that any
        // subsequent fetchEntities or fetchEntity's on a superset of these fields can update
        // this part of the state.
        const entitiesSynced = nextState.getIn([fetchedEntityStateKey, 'partialRecords', 'synced']);
        const partialFieldsKey = new Set(partialRecordFieldNames);
        if (entitiesSynced.get(partialFieldsKey) == null) {
            nextState = nextState.setIn(
                [fetchedEntityStateKey, 'partialRecords', 'synced', partialFieldsKey],
                {}
            );
        }
    }
    return nextState;
}

/**
 * Use this to reapply optimistic updates after entity has been updated from server
 * This solves issues with multiple optimistic updates being overwritten by an
 * intermediate server response.
 */
function applyOptimisticUpdate(state, stateKey, data) {
    return state.updateIn(stateKey, entity => (entity ? entity.merge(data) : data));
}

function addOrUpdateEntity(state, action) {
    let nextState = entitiesPayloadStateTransition(state, action);
    // Allow specification of optimisticStateKey for cases where the optimistic update
    // is for a different model. Ideally this would be refactored such that optimistic
    // updates are stored at the top level so we could just look them up by id easily.
    // Default behaviour is to treat the optimistic update as coming from same model.
    const {
        meta: { stateKey, optimisticStateKey = stateKey, entity, optimisticId },
    } = action;
    if (entity) {
        // Now that entity has by sync'd remove it from local state key
        nextState = nextState.deleteIn([stateKey, 'local', entity.modelUUID]);
    }
    if (optimisticId) {
        const optimisticIndex = nextState
            .getIn([optimisticStateKey, 'optimisticUpdates'])
            .findIndex(update => update.optimisticId === optimisticId);
        nextState = nextState.deleteIn([optimisticStateKey, 'optimisticUpdates', optimisticIndex]);
    }
    return nextState
        .getIn([stateKey, 'optimisticUpdates'])
        .reduce((s, update) => applyOptimisticUpdate(s, update.statePath, update.data), nextState);
}

export default {
    [actionTypes.fetch]: entitiesPayloadStateTransition,
    [actionTypes.customDetail]: addOrUpdateEntity,
    [actionTypes.customList]: addOrUpdateEntity,
    [actionTypes.add]: addOrUpdateEntity,
    [actionTypes.update]: addOrUpdateEntity,
    [actionTypes.updateOptimistic]: (state, { meta, payload }) => {
        const { stateKey, optimisticId } = meta;
        const { entity, data } = payload;
        const statePath = getRecordPath(state, entity);
        const nextState = applyOptimisticUpdate(state, statePath, data);
        return nextState.updateIn([stateKey, 'optimisticUpdates'], updates =>
            updates.push({
                optimisticId,
                entityId: entity.getId(),
                data,
                statePath,
            })
        );
    },
    [actionTypes.updateOptimisticUndo]: (state, { meta, payload }) => {
        const { stateKey, optimisticId } = meta;
        const { entity } = payload;
        const path = getRecordPath(state, entity);
        const nextState = state.setIn(path, entity);
        const optimisticIndex = nextState
            .getIn([stateKey, 'optimisticUpdates'])
            .findIndex(update => update.optimisticId === optimisticId);
        return nextState.deleteIn([stateKey, 'optimisticUpdates', optimisticIndex]);
    },
    [actionTypes.addLocal]: (state, { payload, meta }) => {
        const { stateKey } = meta;
        const { modelUUID, data } = payload;
        const path = [stateKey, 'local', modelUUID];
        return state.setIn(path, { ...data, modelUUID });
    },
    [actionTypes.deleteLocal]: (state, { payload, meta }) => {
        const { stateKey } = meta;
        const { entity } = payload;
        const path = [stateKey, 'local', entity.modelUUID];
        return state.deleteIn(path);
    },
    [actionTypes.delete]: (state, { payload, meta }) => {
        const { stateKey } = meta;
        if (state.has(stateKey)) {
            // Accept either multiple ids or single id
            const ids = payload.ids || [payload.id];
            return deleteEntitiesStateTransition(state, stateKey, ids);
        }
        console.warn(
            // eslint-disable-line
            `Unknown entity name ${stateKey} encountered. This should ` +
                'probably have a key in the entities state.'
        );
        return state;
    },
    [actionTypes.reorder]: (state, { payload }) => {
        // TODO: This should really be an optimistic update, not updating synced records
        let { entity, withRespectTo } = payload;
        const entityPath = getRecordPath(state, entity);
        let entities;
        if (!entity[PARTIAL_FIELDS_KEY_FIELD_NAME]) {
            entities = entity.constructor.selectors.all(state);
        } else {
            entities = entity.constructor.selectors.partialFields.all(state)(
                entity[PARTIAL_FIELDS_KEY_FIELD_NAME]
            );
        }
        if (!entityPath) {
            throw new Error('Passed entity to re-order was not found in state');
        }
        // Always make sure we use the latest version of entity in case
        // sort value has changed since it was fetched
        entity = state.getIn(entityPath);
        if (isModel(withRespectTo)) {
            const withRespectToPath = getRecordPath(state, withRespectTo);
            if (!withRespectToPath) {
                throw new Error(
                    'Passed entity to re-order with respect to ' + 'was not found in state'
                );
            }
            withRespectTo = state.getIn(withRespectToPath);
        }

        const { orderedModel } = entity[$modelDefinition];
        const { orderWithRespectTo, orderFieldName } = orderedModel;
        // This tracks values to update in entity
        const newData = {};

        const filteredEntities = entities
            .filter(e => {
                if (!orderWithRespectTo) {
                    return true;
                }
                for (const fieldName of orderWithRespectTo) {
                    if (e[fieldName] !== entity[fieldName]) {
                        return false;
                    }
                }
                return true;
            })
            .toList()
            .sortBy(e => e.get(orderFieldName));

        if (orderWithRespectTo) {
            // Copy all fields that are relevant to ordering. For example
            // if you have a todo that is ordered against other todo's
            // on a day then when re-ordering it we must set the day to
            // match it's target day
            orderWithRespectTo.forEach(fieldName => {
                newData[fieldName] = withRespectTo[fieldName];
            });
        }

        // Check if 2 entities are in the same 'list' (ie. they have same values
        // for all orderWithRespectTo fields)
        const isInSameList = (entity1, entity2) => {
            if (!orderWithRespectTo) {
                return true;
            }
            for (const fieldName of orderWithRespectTo) {
                if (entity1[fieldName] !== entity2[fieldName]) {
                    return false;
                }
            }
            return true;
        };

        const entityIndex = filteredEntities.findIndex(en => en.modelUUID === entity.modelUUID);
        const withRespectToIndex = filteredEntities.findIndex(
            en => en.modelUUID === withRespectTo.modelUUID
        );
        const isAdjacent = (i1, i2) => Math.abs(i1 - i2) === 1;
        const isBetween = (bound1, bound2, target) =>
            (target > bound1 && target < bound2) || (target < bound1 && target > bound2);

        if (isModel(withRespectTo)) {
            let { insertAfter } = payload;
            const { insertBefore } = payload;
            if (!(insertBefore || insertAfter)) {
                if (isInSameList(entity, withRespectTo)) {
                    const isBefore = entity.get(orderFieldName) < withRespectTo.get(orderFieldName);
                    const adjacent = isAdjacent(entityIndex, withRespectToIndex);
                    insertAfter = (isBefore && adjacent) || (!isBefore && !adjacent);
                } else {
                    // Default behaviour is to insertAfter if moving lists
                    insertAfter = true;
                }
            }

            const offset = insertAfter ? 0.001 : -0.001;
            newData[orderFieldName] = withRespectTo.get(orderFieldName) + offset;
            const nextState = state.updateIn(entityPath, e => e.merge(newData));
            const previouslyReorderedEntities = filteredEntities
                .filter((en, index) => {
                    if (
                        en.modelUUID === entity.modelUUID ||
                        // If inserting after don't want to re-order target
                        // If we are inserting before then we do need to reorder
                        // it as it is pushed out by the re-ordered entity
                        en.modelUUID === withRespectTo.modelUUID ||
                        !isBetween(entityIndex, withRespectToIndex, index)
                    ) {
                        return false;
                    }
                    // Only re-order items that have been re-ordered client side
                    // It's expected this is temporary as once it's saved to the
                    // server entities on the client side should be updated with
                    // their new sort value
                    if (Math.abs(en.get(orderFieldName) - withRespectTo.get(orderFieldName)) >= 1) {
                        return false;
                    }

                    return isInSameList(en, entity);
                })
                .sortBy(e => e.get(orderFieldName));
            if (previouslyReorderedEntities.size) {
                return nextState.withMutations(s => {
                    previouslyReorderedEntities.forEach(e => {
                        const sortKey = e.get(orderFieldName);
                        const path = getRecordPath(state, e);
                        s.setIn([...path, orderFieldName], sortKey + offset);
                    });
                });
            }
            return nextState;
        }

        // Otherwise we are not re-ordering against a specific entity - rather
        // we have the values for all orderWithRespectTo fields and either
        // insertStart or insertEnd
        const { insertStart } = payload;
        let sortKey = 0;
        if (filteredEntities.size) {
            sortKey = insertStart
                ? filteredEntities.first().get(orderFieldName) - 0.001
                : filteredEntities.last().get(orderFieldName) + 0.001;
        }
        newData[orderFieldName] = sortKey;
        return state.updateIn(entityPath, e => e.merge(newData));
    },
};
