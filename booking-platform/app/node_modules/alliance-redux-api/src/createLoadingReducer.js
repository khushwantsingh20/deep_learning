import { actionTypes } from './actions';
import createReducer from './createReducer';
import { isModelInstance } from './Model';

/**
 * Create reducer that tracks syncing of entities
 * Actual state is defined in createModelReducer under 'loading' state key.
 */
export default function createLoadingReducer() {
    // Tracks a specific entity has started a sync to server
    function entityLoadingStart(state, { payload = {}, meta }) {
        // eslint-disable-line
        if (
            payload.error ||
            !meta.entity ||
            !isModelInstance(meta.entity) ||
            !meta.entity.modelUUID
        ) {
            return state;
        }
        const path = [meta.stateKey, 'loading', 'syncingEntityUUIDs'];
        if (state.getIn(path).contains(meta.entity.modelUUID)) {
            return state;
        }
        return state.updateIn(path, items => items.push(meta.entity.modelUUID));
    }

    // Tracks a specific entity has stopped (either success or fail) syncing to server
    function entityLoadingFinish(state, { payload = {}, meta = {} }) {
        // eslint-disable-line
        if (payload.error || !meta.entity || !meta.entity.modelUUID) {
            return state;
        }
        const index = state
            .getIn([meta.stateKey, 'loading', 'syncingEntityUUIDs'])
            .findIndex(modelUUID => modelUUID === meta.entity.modelUUID);

        if (index === -1) {
            return state;
        }
        return state.deleteIn([meta.stateKey, 'loading', 'syncingEntityUUIDs', index]);
    }

    return createReducer(null, {
        [actionTypes.addStart]: entityLoadingStart,
        [actionTypes.deleteStart]: entityLoadingStart,
        [actionTypes.updateStart]: entityLoadingStart,
        [actionTypes.customDetailStart]: entityLoadingStart,

        [actionTypes.add]: entityLoadingFinish,
        [actionTypes.delete]: entityLoadingFinish,
        [actionTypes.update]: entityLoadingFinish,
        [actionTypes.customDetail]: entityLoadingFinish,

        [actionTypes.addFailure]: entityLoadingFinish,
        [actionTypes.deleteFailure]: entityLoadingFinish,
        [actionTypes.updateFailure]: entityLoadingFinish,
        [actionTypes.customFailure]: entityLoadingFinish,

        [actionTypes.fetchStart](state, { payload = {}, meta }) {
            if (payload.error) {
                return state;
            }
            return state.setIn([meta.stateKey, 'loading', 'isFetching'], true);
        },

        [actionTypes.fetch](state, { meta }) {
            return state.setIn([meta.stateKey, 'loading', 'isFetching'], false);
        },

        [actionTypes.fetchFailure](state, { meta }) {
            return state.setIn([meta.stateKey, 'loading', 'isFetching'], false);
        },
    });
}
