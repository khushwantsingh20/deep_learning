import Immutable from 'immutable';
import { Any, Record, List, Map as TypedMap, Typed } from 'typed-immutable';
import invariant from 'invariant';
import createReducer, { stringify } from './createReducer';

import { $modelDefinition } from './Model';
import type { ModelRecord } from './flowTypes';

export const $modelReducerDefinition = Symbol.for('alliance-redux-api/modelReducerDefinition');

export default function createModelReducer(modelRecord: ModelRecord, handlers = {}) {
    invariant(
        modelRecord[$modelDefinition],
        'model parameter passed to createModelReducer was not created by ' +
            'alliance-redux-api/Model. You cannot pass regular immutable ' +
            `Records - you must use Model. Received: ${stringify(modelRecord)}`
    );
    const {
        pinnedFieldNames,
        label,
        IdType,
        stateKey,
        partialRecordClass,
        idFieldName,
        orderedModel,
    } = modelRecord[$modelDefinition];
    class EntitiesMap extends TypedMap(IdType, modelRecord, `${label} - Synced`) {
        get(keyData) {
            // This makes up for shortcoming in typed-immutable; doesn't properly
            // apply type when you read via key from the map. This is particularly
            // annoying when you have a string from a url, eg "5" but needs to be
            // a number. This will fix that if your type is Id (which handles
            // converting numeric strings to Number's)
            return super.get(this[Typed.type].key[Typed.read](keyData));
        }
    }
    class PartialEntitiesMap extends TypedMap(IdType, partialRecordClass, `${label} - Partial`) {
        get(keyData) {
            // This makes up for shortcoming in typed-immutable; doesn't properly
            // apply type when you read via key from the map. This is particularly
            // annoying when you have a string from a url, eg "5" but needs to be
            // a number. This will fix that if your type is Id (which handles
            // converting numeric strings to Number's)
            return super.get(this[Typed.type].key[Typed.read](keyData));
        }

        /**
         * Pinned field names are just fields that always are included on partial records -
         * eg. id fields and fields used for sorting.
         */
        getPinnedFieldNames() {
            return pinnedFieldNames;
        }
    }

    const ModelState = Record(
        {
            // These have been sync'd to server
            synced: EntitiesMap,
            // Map of unique optimistic update ID to record storing actual update details
            optimisticUpdates: List(
                Record({
                    optimisticId: String,
                    entityId: IdType,
                    statePath: List(Any),
                    data: TypedMap(String, Any),
                })
            ),
            partialRecords: Record({
                synced: TypedMap(Any, PartialEntitiesMap),
                local: TypedMap(
                    Any,
                    TypedMap(String, partialRecordClass, `${label} Partial - Local`)
                ),
            }),
            // These are only in local redux state, not sync'd to server
            local: TypedMap(String, modelRecord, `${label} - Local`),
            // Any extra data - suitable for user extensions
            meta: TypedMap(String, Any, `${label} - Meta`),
            // Used to track whether data is fetching or saving etc
            loading: Record(
                {
                    isFetching: Boolean(false),
                    // This should be a Set, but not supported in typed-immutable
                    syncingEntityUUIDs: List(String),
                },
                `${label} - Loading`
            ),
        },
        label
    );

    const reducer = createReducer(ModelState, handlers);

    reducer[$modelReducerDefinition] = {
        stateKey,
        modelStateRecord: ModelState,
        modelRecord,
    };

    return reducer;
}
