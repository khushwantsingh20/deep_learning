import Immutable from 'immutable';
import invariant from 'invariant';
import { ApiError, getJSON } from 'redux-api-middleware';

import uid from './uid';
import { get, patch, post, del } from './api';
import normalizeData from './normalize';
import { isModel, modelClassMap, $modelDefinition } from './Model';
import { getRecordPath } from './util';
import { serializeModelData } from './serialize';

const apiMethods = { get, patch, post, del, delete: del };

/**
 * Create a pagination record that is returned for paginated API responses.
 *
 * This is the structure consumed by users of fetchEntities and related API
 * endpoints.
 *
 * @param page {Number} the page number requested
 * @param pageSize {Number} the size of the page that was requested
 * @param ids {Array<number|string>} the ids of the records returned
 * @param count {Number} the total number of records available from the API
 * @returns {{paginated: boolean, previousPage: *, nextPage: *, count: *, ids: *, pageSize: *, page: *}}
 */
function createPaginationRecord(page, pageSize, ids, count) {
    // There's no way to know what the page / pageSize was from the response
    // returned by the default DRF pagination classes. As such the page and pageSize
    // need to be extracted at the time of the request and passed in to this function.
    // Unfortunately this isn't always set (in most new code it is, but not required).
    // As such we have to set some defaults if not specified.
    // TODO: This is fragile in that if the backend defaults
    // don't match our defaults and page/pageSize aren't explicitly
    // passed then things won't match.... but backwards compat :(
    pageSize = Number(pageSize || 20);
    page = Number(page || 1);
    const offset = (page - 1) * pageSize;
    const nextPage = offset + pageSize < count ? page + 1 : null;
    const previousPage = page > 1 ? page - 1 : null;
    return {
        ids,
        count,
        paginated: true,
        nextPage,
        previousPage,
        pageSize,
        page,
    };
}

/**
 * Handle normalizing data that may be for a single entity OR may be
 * structured as:
 * {
 *    entities: {
 *       someModelId: [...list of updated records...]
 *    }
 * }
 * Where 'someModelId' is the model ID as determined by the backend. This
 * must match your Model's modelId which can be specified when you create
 * the model as an optional parameter. This allows multiple records be
 * returned in a single response without requiring they be a foreign key
 * from the main object. Use cases for this are if you are creating associated
 * records with a main record but they aren't specified as relationships
 * on the main record so aren't serialized as part of the base record.
 * @param {*} entity entity class or entity instance
 * @param {*} data  data from API call
 */
export function normalizeResponseData(entity, data, { page, pageSize } = {}) {
    const { stateKey } = entity[$modelDefinition];
    if (data.entities || data.deletedEntities || data.paginatedEntity) {
        const deletedEntities = Object.keys(data.deletedEntities || {}).reduce((acc, modelId) => {
            const modelData = data.deletedEntities[modelId];
            const modelClass = modelClassMap[modelId];
            if (modelClass) {
                const { stateKey } = modelClass[$modelDefinition];
                const ids = Array.isArray(modelData) ? modelData : [modelData];
                if (!acc[stateKey]) {
                    acc[stateKey] = [];
                }
                acc[stateKey].push(...ids);
                return acc;
            }
            console.warn(
                `Response included data for unknown model ${modelId}. If this isn't intenitional ensure your Model was created and specified a 'modelId' of '${modelId}'.`
            );
            return acc;
        }, {});
        const normalizedData = Object.keys(data.entities || {}).reduce(
            (acc, modelId) => {
                const modelData = data.entities[modelId];
                const modelClass = modelClassMap[modelId];
                if (modelClass) {
                    const { entities, result } = normalizeData(modelClass, modelData);
                    Object.keys(entities).forEach(entitiesStateKey => {
                        if (!acc.entities[entitiesStateKey]) {
                            acc.entities[entitiesStateKey] = {};
                        }
                        Object.keys(entities[entitiesStateKey]).forEach(entityId => {
                            acc.entities[entitiesStateKey][entityId] =
                                entities[entitiesStateKey][entityId];
                        });
                    });
                    // For the main model set result which contains the relevant id(s)
                    if (modelClass[$modelDefinition].stateKey === stateKey) {
                        acc.result = result;
                    }
                    return acc;
                }
                console.warn(
                    `Response included data for unknown model ${modelId}. If this isn't intenitional ensure your Model was created and specified a 'modelId' of '${modelId}'.`
                );
                return acc;
            },
            {
                // Include any extra data from the payload. This can include the 'createdId'
                // field to indicate id of record that was created when returning multiple entities
                ...data,
                entities: {},
                result: [],
                deletedEntities,
                // This is included so that things that use the response know what
                // the calling entity was.
                entityClass: entity,
            }
        );
        // Backwards compat - some stuff uses result others ids; they mean the same thing
        normalizedData.ids = normalizedData.result;
        if (data.paginatedEntity) {
            // A paginated entity can be returned nested in `data` for cases where
            // extra data is being returned in addition to the regular paginated
            // response. On the backend you would do this like:
            // ```
            // return DjradEntityResponse(
            //    self.get_serializer(request.user),
            //    AdminProfileSerializer(AdminProfile.objects.all(), many=True),
            //    paginated_response=self.get_paginated_response(serializer.data),
            //    data={"someExtraData": 5},
            // )
            // ```
            // In this example the current user would be returned, a list of
            // admin profiles would be returned (and available in `data.entities`,
            // the paginated response for the API in question (users) would be
            // returned and finally some extra data is also included.
            // Here we take the data extracted from `paginated_response` and we
            // transform that into the `entities` object. So in the example above
            // the `entities` object might look like:
            // {
            //    // Data from the paginated response and serialized current user
            //    users: { ... },
            //    // The data from AdminProfileSerializer
            //    adminprofile: { ... },
            // }
            // And `data.results` will be the list of id's returned in
            // `paginated_response`. The pagination data (as returned by
            // `createPaginationRecord`) is included as well so the final
            // normalized data looks something like:
            // ```
            // {
            //   entities: {...},
            //   results: [1,2,3,4,5],
            //   ids: [1,2,3,4,5],
            //   count: 5,
            //   paginated: true,
            //   nextPage: null,
            //   previousPage: null,
            //   page: 1,
            //   pageSize: 10,
            //   someExtraData: 5 ,
            // }
            // ```
            // There is some duplication here (eg. results and ids) - this whole
            // structure is basically for backwards compatibility. It could be
            // represented _much_ better... but at this stage a lot of things
            // depend on it.
            delete normalizedData.paginatedEntity;
            if (!normalizedData.entities[stateKey]) {
                normalizedData.entities[stateKey] = {};
            }
            const { results: paginatedResults, ...pagination } = data.paginatedEntity;
            const { entities, result } = normalizeData(entity, paginatedResults);
            Object.keys(entities).forEach(key => {
                Object.assign(normalizedData.entities[key], entities[key]);
            });
            normalizedData.result = result;
            normalizedData.ids = result;
            normalizedData.paginated = true;
            Object.assign(
                normalizedData,
                createPaginationRecord(page, pageSize, result, pagination.count)
            );
        }
        return normalizedData;
    }
    const normalizedData = normalizeData(entity, data);
    // Backwards compat - some stuff uses result others ids; they mean the same thing
    normalizedData.ids = normalizedData.result;
    return normalizedData;
}

export const actionTypes = {
    fetch: '@alliance-redux-api/fetch',
    fetchStart: '@alliance-redux-api/fetch.start',
    fetchFailure: '@alliance-redux-api/fetch.failure',
    customDetail: '@alliance-redux-api/customDetail',
    customDetailStart: '@alliance-redux-api/customDetail.start',
    customDetailFailure: '@alliance-redux-api/customDetail.failure',
    customList: '@alliance-redux-api/customList',
    customListStart: '@alliance-redux-api/customList.start',
    customListFailure: '@alliance-redux-api/customList.failure',
    add: '@alliance-redux-api/add',
    addStart: '@alliance-redux-api/add.start',
    addFailure: '@alliance-redux-api/add.failure',
    update: '@alliance-redux-api/update',
    updateStart: '@alliance-redux-api/update.start',
    updateFailure: '@alliance-redux-api/update.failure',
    updateOptimistic: '@alliance-redux-api/updateOptimistic',
    updateOptimisticUndo: '@alliance-redux-api/updateOptimisticUndo',
    addLocal: '@alliance-redux-api/addLocal',
    deleteLocal: '@alliance-redux-api/deleteLocal',
    delete: '@alliance-redux-api/delete',
    deleteStart: '@alliance-redux-api/delete.start',
    deleteFailure: '@alliance-redux-api/delete.failure',
    reorder: '@alliance-redux-api/reorder',
};

const endpointDoesNotSupportPagination = {};

/**
 * Fetch entities from API endpoint. Dispatches a ENTITY_FETCH action with
 * payload patching normalizr.normalize result:
 * {
 *   // Entities are defined by schema, eg. if tasks was the schema and it
 *   // had a relationship on subProject the result may look like: (indexed by id)
 *   entities: { tasks: {...}, subProject: {...} },
 *   // List of id's in the order recieved from API
 *   result: [...],
 * }
 *
 * You can call this multiple times before it resolves and it will only generated
 * a single request (see get() in api/actions).
 *
 * Multiple calls to fetch the same entities (based on filter values) will only
 * trigger one request by default. Subsequent calls will not trigger a XHR
 * request and will resolve the promise with the records fetched originally.
 *
 * Pass options.nocache = true to opt out.
 *
 * @param {String} entityName the name of entity, should match API endpoint, eg.
 * if endpoint is /api/tasks the entity name is tasks
 * @param {Schema} singleEntitySchema a normalizr schema for a single entity,
 * will automatically convert it to arrayOf
 * @param {Object} filters any filters to apply - this get converted to query
 * parameters
 * @param {Object} options
 * @param {Bool} options.nocache set to true to bypass fetch caching and always
 * perform an server request.
 * @return Promise<List<entityClass>> resolves to a list of records fetched
 */
export function fetchEntities(modelClass, filters = {}, options = {}, meta = {}) {
    return (dispatch, getState) => {
        // validateEntityClass(entityClass);
        const { stateKey, cache, transformResponse = x => x } = modelClass[$modelDefinition];
        const endpoint = options.endpoint || modelClass[$modelDefinition].endpoint;
        // The forcePagination exists for historical reasons; original usage of this module
        // was on a site where we did not paginate and so option here was actually to opt
        // in to pagination with option to fake the pagination locally if endpoint didn't
        // support pagination. I've left the logic in place for this but the default is now
        // to always paginate and you can't control it from the front end - the backend
        // has full control over whether pagination is in place or not.
        const {
            forcePagination = false,
            partialRecordFieldNames,
            headers = {},
            fetchOptions = {},
        } = options;
        const finalMeta = {
            ...meta,
            stateKey,
            filters,
            partialRecordFieldNames,
        };
        const finalHeaders = { ...headers };
        if (partialRecordFieldNames) {
            finalHeaders['X-Djradfields'] = partialRecordFieldNames.join(' ');
        }
        const selectEntities = () => {
            if (partialRecordFieldNames) {
                return modelClass.selectors.partialFields.synced(getState())(
                    partialRecordFieldNames
                );
            }
            return modelClass.selectors.synced(getState());
        };
        const getResultingEntities = ids => {
            const allEntities = selectEntities();
            return Immutable.List(ids.map(id => allEntities.get(id)));
        };
        const finalFilters = {
            ...filters,
        };
        const endpointSupportPagination = !endpointDoesNotSupportPagination[modelClass];
        const cacheKey = { ...finalFilters, endpoint, partialRecordFieldNames };
        if (!endpointSupportPagination) {
            delete cacheKey.pageSize;
            delete cacheKey.page;
        }
        if (!options.nocache) {
            const cachedValue = cache.get(getState, cacheKey, selectEntities);
            if (cachedValue) {
                let { ids } = cachedValue;
                if (forcePagination && !endpointSupportPagination) {
                    const { page = 1, pageSize = 20 } = filters;
                    const offset = (page - 1) * pageSize;
                    ids = ids.slice(offset, offset + pageSize);
                }
                return Promise.resolve({
                    ...cachedValue,
                    entities: getResultingEntities(ids),
                    entityClass: modelClass,
                });
            }
        }
        return dispatch(
            get(`${endpoint}/`, finalFilters, {
                headers: finalHeaders,
                fetchOptions,
                requestType: {
                    type: actionTypes.fetchStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.fetch,
                    payload: (action, state, response) =>
                        getJSON(response).then(json => {
                            invariant(
                                json,
                                `Expected JSON Content-Type on API call to the endpoint '${endpoint}'. ` +
                                    'Does the endpoint exist? Do you need to customise the endpoint on the Model?'
                            );
                            const { page, pageSize } = filters;
                            const data = transformResponse(json);
                            if (data.count != null && data.results) {
                                const { results, count, next, previous, ...rest } = data;
                                return normalizeResponseData(
                                    modelClass,
                                    {
                                        entities: {},
                                        paginatedEntity: { results, count, next, previous },
                                        ...rest,
                                    },
                                    { page, pageSize }
                                );
                            }
                            if (forcePagination) {
                                endpointDoesNotSupportPagination[modelClass] = true;
                            }
                            return normalizeResponseData(modelClass, data, { page, pageSize });
                        }),
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.fetchFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                // This will be an ApiError object from redux-api-middleware
                throw payload;
            }
            const cacheValue = {
                ...payload,
                entityClass: modelClass,
            };
            let { ids } = payload;
            if (forcePagination && endpointDoesNotSupportPagination[modelClass]) {
                // If the endpoint doesn't actually support pagination we
                // just do it locally. As such store all id's then paginate
                // them when we retrieve from cache. Also note the cacheKey
                // excludes pagination related values so that subsequent
                // requests for a different page don't trigger a refetch
                const { offset, pageSize } = payload;
                cacheValue.ids = ids;
                ids = ids.slice(offset, offset + pageSize);
                delete cacheKey.pageSize;
                delete cacheKey.page;
            }
            cache.set(getState, cacheKey, cacheValue, selectEntities);
            return {
                // Include any other extra data included in response
                ...cacheValue,
                paginated: cacheValue.paginated || forcePagination,
                entities: getResultingEntities(ids),
            };
        });
    };
}

export function fetchEntitiesPaginated(modelClass, filters = {}, options = {}, meta = {}) {
    return fetchEntities(modelClass, filters, { ...options, paginate: true }, meta);
}

/**
 * Get a single record from the backend. This assumes your backend viewset
 * has support as described below.
 *
 * When passing an ID return a single record (DRF RetrieveModelMixin):
 *
 * ```
 * /api/user/5/
 * ```
 *
 * When passing a filter object support for listing records (DRF ListModelMixin):
 *
 * ```
 * /api/users/?userId=5&projectId=2
 * ```
 *
 * Your backend must also apply the filters for `userId` and `projectId` in this
 * case (eg. using a `filterset_class` on your viewset).
 *
 * @param {ModelRecord} modelClass The model class to fetch record from
 * @param {Number|Object} id either the id of the entity to fetch or a filter object
 * that should result in a single record being returned. This is useful when you
 * have a unique constraint on a record that you want to use to identify a record.
 * When the filter object is passed the API call is to the list view and passes
 * the filter as query parameters. For example if you pass `{ userId: 5, projectId: 2 }`
 * you might get:
 * ```
 * /api/users/?userId=5&projectId2
 * ```
 * Your backend must handle those query parameters such that a single record is returned.
 * If multiple records are returned a ApiError will be raised with a status of 400.
 * @param {Object} options
 * @param {Array<string>} options.partialRecordFieldNames An optional list of field
 * names to fetch. If provided it's expected the backend will only return these
 * fields. This can be used to reduce the size of the return payload or optimise
 * the queries used on the backend.
 * @param {Object} options.headers Any extra headers to pass through to the backend
 * @param {Object} options.fetchOptions Extra options to pass through to the
 * [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) call.
 * @param {Boolean} options.nocache set to true to bypass fetch caching and always
 * perform an server request.
 * @return Promise
 */
export function fetchEntity(modelClass, id, options = {}, meta = {}) {
    return async (dispatch, getState) => {
        const { stateKey, endpoint, cache } = modelClass[$modelDefinition];
        const { partialRecordFieldNames, headers = {}, fetchOptions } = options;
        const selectEntities = () => {
            if (partialRecordFieldNames) {
                return modelClass.selectors.partialFields.synced(getState())(
                    partialRecordFieldNames
                );
            }
            return modelClass.selectors.synced(getState());
        };
        if (!options.nocache) {
            const cachedValue = cache.get(getState, id, selectEntities);
            const entity = selectEntities().get(cachedValue);
            if (entity) {
                return Promise.resolve(entity);
            }
        }
        function generateReturnValue(id) {
            cache.set(getState, id, id, selectEntities);
            let allEntities;
            if (partialRecordFieldNames) {
                allEntities = modelClass.selectors.partialFields.synced(getState())(
                    partialRecordFieldNames
                );
            } else {
                allEntities = modelClass.selectors.synced(getState());
            }
            return allEntities.get(id);
        }
        if (id && typeof id == 'object') {
            return dispatch(fetchEntities(modelClass, id, options, meta)).then(({ ids }) => {
                if (ids.length === 0) {
                    throw new ApiError(404, 'Not found');
                }
                if (ids.length > 1) {
                    // eslint-disable-next-line no-console
                    console.warn(
                        `Expected only one result from endpoint, received ${
                            ids.length
                        }. Make sure endpoint applies filters on '${Object.keys(id).join(
                            ', '
                        )}' such that only one result is returned`
                    );
                    throw new ApiError(400, 'Multiple objects returned');
                }
                return generateReturnValue(ids[0]);
            });
        }
        const finalHeaders = { ...headers };
        if (partialRecordFieldNames) {
            finalHeaders['X-Djradfields'] = partialRecordFieldNames.join(' ');
        }
        const finalMeta = {
            ...meta,
            stateKey,
            partialRecordFieldNames,
        };
        return dispatch(
            get(`${endpoint}/${id}/`, null, {
                headers: finalHeaders,
                fetchOptions,
                requestType: {
                    type: actionTypes.fetchStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.fetch,
                    payload: (action, state, response) =>
                        getJSON(response).then(json => {
                            if (json.entities) {
                                // This means our API endpoint returned the record
                                // we care about + some extra data. In that case
                                // we need to handle it slightly different... we
                                // set isSimpleResponse here and then look for that
                                // in the final `then` below. It's difficult to do
                                // this check below as both `normalizeData` and
                                // `normalizeResponseData` will generate a structure
                                // that can look the same depending on the response
                                // data returned from the backend (ie. we can't
                                // necessarily differentiated between them after
                                // these calls are made).
                                return {
                                    ...normalizeResponseData(modelClass, json),
                                    isSimpleResponse: false,
                                };
                            }
                            return {
                                ...normalizeData(modelClass, json),
                                isSimpleResponse: true,
                            };
                        }),
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.fetchFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                // This will be an ApiError object from redux-api-middleware
                throw payload;
            }
            const record = generateReturnValue(id);
            const { isSimpleResponse, ...rest } = payload;
            if (payload.isSimpleResponse) {
                // If it's a simple response we only return a record - there's no
                // access to anything from the response (which is fine, as the response
                // only contained the record data itself).
                return record;
            }
            // If it's not a simple record response we return the record as a key
            // on an object and all the rest of the data as returned by
            // `normalizeResponseData`. This is for more advanced use cases where
            // you want to fetch a record and at the same time fetch some extra
            // info in the same API call.
            return {
                ...rest,
                record,
            };
        });
    };
}

/**
 * Update an existing entity
 * @param {Record} entity to update
 * @param {Object} data extra data fields to apply to entity
 * @param {Object} extra options. Set optimistic to true to apply updates
 * immediately before waiting for server to respond.
 * @param {Object} meta
 * @return {Promise}
 */
export function updateEntity(entity, data, options = {}, meta = {}) {
    // validateEntityInstance(entity);
    const { stateKey, modelId } = entity[$modelDefinition];
    let endpoint = options.endpoint || entity[$modelDefinition].endpoint;
    if (options.endpointAppend) {
        endpoint = `${endpoint}/${options.endpointAppend}`;
    }
    data = serializeModelData(entity, data);
    const finalMeta = {
        ...meta,
        entity,
        stateKey,
    };
    invariant(
        entity.getId() != null,
        `You called updateEntity for state key '${stateKey}' with entity ` +
            "instance that has no 'id' field set. This is required."
    );
    const { selectors } = entity.constructor;
    return (dispatch, getState) => {
        let undoOptimistic;
        if (options.optimistic) {
            const optimisticId = uid.v4();
            finalMeta.optimisticId = optimisticId;
            const state = getState();
            const path = getRecordPath(state, entity);
            const entitiesRoot = state[path.shift()];
            const existingEntity = entitiesRoot.getIn(path);
            undoOptimistic = () => {
                dispatch({
                    type: actionTypes.updateOptimisticUndo,
                    meta: finalMeta,
                    payload: {
                        entity: existingEntity,
                        data,
                    },
                });
            };
            dispatch({
                type: actionTypes.updateOptimistic,
                meta: finalMeta,
                payload: {
                    entity,
                    data,
                },
            });
        }
        return dispatch(
            patch(`${endpoint}/${entity.getId()}/`, data, {
                headers: options.headers,
                fetchOptions: options.fetchOptions,
                requestType: {
                    type: actionTypes.updateStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.update,
                    payload: (action, state, response) =>
                        getJSON(response).then(json => normalizeResponseData(entity, json)),
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.updateFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                if (undoOptimistic) {
                    undoOptimistic();
                }
                // This will be an ApiError object from redux-api-middleware
                throw payload;
            }
            // For an update we always know the original id so can use entity.getId() rather than payload.result
            const record = selectors.synced(getState()).get(entity.getId());
            if (!record) {
                console.warn(
                    `Expected response to to include the updated record but it did not. If the record did update on the backend your local cache is now out of sync.`
                );
                return payload;
            }
            return {
                ...payload,
                record,
            };
        });
    };
}

/**
 * Add a new entity
 */
export function addEntity(entity, data = null, options = {}, meta = {}) {
    return (dispatch, getState) => {
        // validateEntityInstance(entity);
        const { stateKey } = entity[$modelDefinition];
        let endpoint = options.endpoint || entity[$modelDefinition].endpoint;
        if (options.endpointAppend) {
            endpoint = `${endpoint}/${options.endpointAppend}`;
        }
        const finalMeta = {
            ...meta,
            stateKey,
            entity,
        };
        if (!data) {
            data = entity.serialize(); // eslint-disable-line
        } else {
            data = serializeModelData(entity, data);
        }
        invariant(
            entity.id == null,
            `You called addEntity for entity name '${stateKey}' with data ` +
                "that has an 'id' field set. To update records call updateEntity."
        );
        return dispatch(
            post(`${endpoint}/`, data, {
                headers: options.headers,
                fetchOptions: options.fetchOptions,
                requestType: {
                    type: actionTypes.addStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.add,
                    payload: (action, state, response) =>
                        getJSON(response).then(json => normalizeResponseData(entity, json)),
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.addFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                throw payload;
            }
            // payload.result will contain an id if a single record is returned from the endpoint.
            // in the case of multiple entities using the { entities: { ... } } structure result will
            // be an array of id's but with no indication as to which entity was created. The 'createdId'
            // field can be returned from the API to indicate the ID of the created entity.
            const id = payload.createdId || payload.result;
            const record = entity.selectors.synced(getState()).get(id);
            if (!record) {
                console.warn(
                    'Expected response to include the created record but it did not. If the record did ' +
                        'create on the backend your local cache is now out of sync. If you are returning multiple ' +
                        "records from the backend specify which is the created record with the 'createdId' field."
                );
                return payload;
            }
            return {
                ...payload,
                record,
            };
        });
    };
}

/**
 * Add an entity to the local cache but don't persist it to the server
 *
 * The entity created is returned.
 */
export function addEntityLocal(entityClass, data, meta = {}) {
    const { stateKey } = entityClass[$modelDefinition];
    data = serializeModelData(entityClass, data);
    invariant(
        data.id == null,
        `You called addEntityLocal for entity name '${stateKey}' with data ` +
            "that has an 'id' field set. To update existing records saved on backend " +
            'call updateEntity.'
    );
    const finalMeta = {
        ...meta,
        stateKey,
    };
    return (dispatch, getState) => {
        // Generate ID here; reducer expects this. This is so we can fetch the
        // created entity from the state.
        const modelUUID = uid.v4();
        dispatch({
            type: actionTypes.addLocal,
            payload: {
                data,
                modelUUID,
            },
            meta: finalMeta,
        });
        return entityClass.selectors.entities(getState()).getIn([stateKey, 'local', modelUUID]);
    };
}

/**
 * Delete an entity that was added with addEntityLocal
 */
export function deleteEntityLocal(entity, meta = {}) {
    // validateEntityInstance(entity);
    const { stateKey } = entity[$modelDefinition];
    const finalMeta = {
        ...meta,
        stateKey,
    };
    return dispatch => {
        dispatch({
            type: actionTypes.deleteLocal,
            payload: {
                entity,
            },
            meta: finalMeta,
        });
    };
}

/**
 * Delete an entity. On completion reducer will remove item from state.
 */
export function deleteEntity(entity, queryParams = {}, meta = {}) {
    return dispatch => {
        // validateEntityInstance(entity);
        const { stateKey, endpoint } = entity[$modelDefinition];
        // NOTE: to be consistent with other methods there really should be a
        // 'options' param to this function... hard to add now because of backwards
        // compatibility
        const { fetchOptions, headers, ...restMeta } = meta;
        const finalMeta = {
            ...restMeta,
            stateKey,
            entity,
        };
        invariant(
            entity.getId() != null,
            `You called deleteEntity for entity name '${stateKey}' with entity ` +
                "that has no 'id' field set. This is required."
        );
        return dispatch(
            del(`${endpoint}/${entity.getId()}/`, queryParams, {
                headers,
                fetchOptions,
                requestType: {
                    type: actionTypes.deleteStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.delete,
                    payload: { id: entity.getId() },
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.deleteFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                // This will be an ApiError object from redux-api-middleware
                throw payload;
            }
            return payload;
        });
    };
}

/**
 * Helper to perform a request on a particular detail route for an entity, eg.
 * /todos/123/reorder
 * The response from the server should contain entities that can be normalized
 * according to singleEntitySchema. eg. Patching /todos/123/reorder could reorder
 * items and the response might be all todo's that had their sortKey updated
 * @param method {String} one of post, patch, get
 * @param entityName {String} name of entity
 * @param singleEntitySchema {Schema} schema for entity
 * @param entity {Object} instance of entity; should have id field
 * @param uri {String} uri to be appended after entities URI (eg. 'reorder' in example above)
 * @param data {?Object} data to be passed through to endpoint
 * @returns {*}
 */
export function customDetailRoute(method, entity, uri, data = null, meta = {}) {
    return (dispatch, getState) => {
        // validateEntityInstance(entity);
        const { stateKey, endpoint } = entity[$modelDefinition];
        // NOTE: to be consistent with other methods there really should be a
        // 'options' param to this function... hard to add now because of backwards
        // compatibility
        const { fetchOptions, headers, ...restMeta } = meta;
        invariant(
            entity.getId() != null,
            `You called customDetailRoute for entity name '${stateKey}' with entity ` +
                "that has no 'id' field set. This is required."
        );
        const methodFn = apiMethods[method];
        invariant(
            methodFn,
            `${method} is not a valid method. Should be one of ${Object.keys(apiMethods).join(
                ', '
            )}`
        );
        const finalMeta = {
            ...restMeta,
            stateKey,
            entity,
            patchEntityUri: uri,
        };
        const url = `${endpoint}/${entity.getId()}/${uri}/`;
        const { selectors } = entity.constructor;
        return dispatch(
            methodFn(url, data, {
                fetchOptions,
                headers,
                requestType: {
                    type: actionTypes.customDetailStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.customDetail,
                    payload: (action, state, response) =>
                        getJSON(response).then(json => normalizeResponseData(entity, json)),
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.customDetailFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                // This will be an ApiError object from redux-api-middleware
                return Promise.reject(payload);
            }
            const record = selectors.synced(getState()).get(entity.getId());
            if (!record) {
                console.warn(
                    `Expected response to contain updated record but it did not. If the record did update on the backend your local cache is now out of sync.`
                );
                return payload;
            }
            return {
                ...payload,
                record,
            };

            return payload;
        });
    };
}

export function customListRoute(method, entity, uri, data = null, meta = {}) {
    return dispatch => {
        // validateEntityInstance(entity);
        const { stateKey, endpoint } = entity[$modelDefinition];
        // NOTE: to be consistent with other methods there really should be a
        // 'options' param to this function... hard to add now because of backwards
        // compatibility
        const { fetchOptions, headers, ...restMeta } = meta;
        const methodFn = apiMethods[method];
        invariant(
            methodFn,
            `${method} is not a valid method. Should be one of ${Object.keys(apiMethods).join(
                ', '
            )}`
        );
        const finalMeta = {
            ...restMeta,
            stateKey,
            entity,
        };
        const url = `${endpoint}/${uri}/`;
        return dispatch(
            methodFn(url, data, {
                headers,
                fetchOptions,
                requestType: {
                    type: actionTypes.customListStart,
                    meta: finalMeta,
                },
                successType: {
                    type: actionTypes.customList,
                    payload: (action, state, response) => {
                        // There's no way to know what the page / pageSize was
                        // apart from extracting it from the data we pass to the
                        // backend.
                        // TODO: This is fragile in that if the backend defaults
                        // don't match our defaults and page/pageSize aren't explicitly
                        // passed then things won't match.... but backwards compat :(
                        const { page, pageSize } = data || {};
                        return getJSON(response).then(json =>
                            normalizeResponseData(entity, json, { page, pageSize })
                        );
                    },
                    meta: finalMeta,
                },
                failureType: {
                    type: actionTypes.customListFailure,
                    meta: finalMeta,
                },
            })
        ).then(({ payload, error }) => {
            if (error) {
                // This will be an ApiError object from redux-api-middleware
                return Promise.reject(payload);
            }
            return payload;
        });
    };
}

/**
 * Reorder an entity locally
 * @param entity {ModelRecord} the entity to move
 * @param withRespectTo {ModelRecord|Object} either another entity to re-order
 * against OR an object that specifies values for all fields in the models
 * orderWithRespectTo field list. You typically use ModelRecord if you have a
 * record to re-order against and the Object notation if you are moving an entity
 * to a new 'list'. The default behaviour when a ModelRecord is specified is to
 * swap positions if adjacent and otherwise move adjacent to withRespectTo
 * with the minimum amount of changes. eg.
 *   [1, 2, 3, 4]
 * Re-ordering 1 and 3 would result in: [2, 1, 3, 4]
 * Re-ordering 1 and 2 would result in the same.
 * Re-ordering 4 and 3 would result in: [1, 2, 4, 3]
 * Re-ordering 4 and 2 would result in the same.
 * To change the default behaviour you can specifiy insertAfter or insertBefore.
 * You should rarely need this and keep in mind it would sometime result in NO
 * change.
 * When re-ordering using an object of field values the default behaviour is
 * to add it to the end of the list. To change this behaviour supply the
 * insertStart option.
 * @param options {Object}
 * @param options.insertAfter {Boolean = false} only relevant if withRespectTo is a
 * ModelRecord. Force entity to be inserted after withRespectTo if true.
 * @param options.insertBefore {Boolean = false} only relevant if withRespectTo is a
 * ModelRecord. Force entity to be inserted before withRespectTo if true.
 * @param options.insertStart {Boolean = false} only relevant if withRespectTo is a
 * Object of field values. Force entity to be inserted at start of 'list'.
 * NOTE: You MUST save the entity manually when ready, ie. all changes here
 * are only local. This is because you can have lots of changes when dragging
 * which you wouldn't want to save in most situations (would trigger lots of
 * changes as entities get new sort keys and also trigger updates on other
 * connected clients for live updates)
 */
export function reorderEntity(entity, withRespectTo, options = {}) {
    let payload = { entity, withRespectTo };
    const { orderedModel } = entity[$modelDefinition];
    invariant(
        orderedModel,
        'You can only call reorderEntity on a model class ' +
            'that was created with the orderedModel option'
    );

    if (isModel(withRespectTo)) {
        invariant(
            entity.prototype === withRespectTo.prototype,
            'Entity and item to order against should be of same type'
        );
        const { insertAfter = false, insertBefore = false } = options;
        invariant(
            !(insertAfter && insertBefore),
            'insertAfter and insertBefore cannot both be true'
        );
        payload = { ...payload, insertAfter, insertBefore };
    } else {
        const { orderWithRespectTo } = orderedModel;
        invariant(
            orderWithRespectTo,
            'Calling reorderEntity passing withRespectTo as an object of field values is ' +
                'only valid if your model specifies orderedWithRespectTo'
        );
        orderWithRespectTo.forEach(fieldName => {
            invariant(
                withRespectTo[fieldName],
                'If calling reorderEntity passing withRespectTo as an object of field values ' +
                    `that object must contain all fields: ${orderWithRespectTo.join(', ')} \n` +
                    `Missing: ${fieldName}`
            );
        });
        let { insertEnd } = options;
        const { insertStart } = options;
        if (!insertStart && insertEnd == null) {
            insertEnd = true;
        }
        invariant(
            insertStart ^ insertEnd,
            'When calling reorderEntity passing withRespectTo as an object ' +
                'you must also specify one of insertStart or insertEnd as true'
        );
        payload = { ...payload, insertStart, insertEnd };
    }
    return {
        type: actionTypes.reorder,
        payload,
    };
}

type ReorderEntityPayload =
    | {
          reorderRelativeTo: number | string,
          insertAfter?: boolean,
      }
    | { [key: string]: any };

/**
 * Helper to get re-order payload used for syncing to server
 * @param entity {ModelRecord} entity to fetch re-order data for
 * @param {Object} object containing either reorderRelativeTo
 */
export function getReorderPayload(state, entity): ReorderEntityPayload {
    // First re-fetch entity in case an old version is being used
    const path = getRecordPath(state, entity);
    invariant(path, 'Could not find entity');
    // Root state is just an object, not immutable so fetch entities root
    const entitiesRoot = state[path.shift()];
    // ... which is immutable so can use getIn
    entity = entitiesRoot.getIn(path); // eslint-disable-line

    // Will be null if not ordered with respect to anything
    const groupKey = entity.getOrderWithRespectToValue();
    let entities;
    if (groupKey) {
        entities = entity.constructor.selectors.groupedByOrderWithRespectTo(state).get(groupKey);
        if (!entities || entities.size === 1) {
            // Only exists by itself (or not at all) - just specify the group
            // data as it's the only item in the group
            return groupKey;
        }
    } else {
        const { orderedModel } = entity[$modelDefinition];
        entities = entitiesRoot
            .getIn(path.slice(0, -1))
            .toList()
            .sortBy(entity => entity.get(orderedModel.orderFieldName));
    }
    // Otherwise find the item it's relative to
    const list = entities.toList();
    const index = list.findIndex(record => record.modelUUID === entity.modelUUID);
    if (index === -1) {
        if (groupKey) {
            return groupKey;
        }
        return {
            reorderRelativeTo: list.last().getId(),
            insertAfter: true,
        };
    }
    if (index === 0) {
        return {
            reorderRelativeTo: list.get(1).getId(),
        };
    }
    return {
        reorderRelativeTo: list.get(index - 1).getId(),
        insertAfter: true,
    };
}

export function updateEntityOrdering(entity) {
    return (dispatch, getState) => {
        const data = getReorderPayload(getState(), entity);
        return dispatch(customDetailRoute('patch', entity, 'reorder', data));
    };
}

export function updateOptimistic(entity, data, meta = {}) {
    const { stateKey } = entity[$modelDefinition];
    const finalMeta = {
        ...meta,
        entity,
        stateKey,
    };
    invariant(
        entity.getId() != null,
        `You called updateEntity for state key '${stateKey}' with entity ` +
            "instance that has no 'id' field set. This is required."
    );
    const { selectors } = entity.constructor;
    return (dispatch, getState) => {
        let undoOptimistic;
        const optimisticId = uid.v4();
        finalMeta.optimisticId = optimisticId;
        const existingEntity = selectors
            .entities(getState())
            .getIn([stateKey, 'synced', entity.getId()]);
        undoOptimistic = () => {
            dispatch({
                type: actionTypes.updateOptimisticUndo,
                meta: finalMeta,
                payload: {
                    entity: existingEntity,
                    data,
                },
            });
        };
        dispatch({
            type: actionTypes.updateOptimistic,
            meta: finalMeta,
            payload: {
                entity,
                data,
            },
        });
        return { optimisticId, undoOptimistic };
    };
}
