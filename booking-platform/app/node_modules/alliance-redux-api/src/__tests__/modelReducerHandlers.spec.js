import { Set, OrderedMap } from 'immutable';
import { combineReducers } from 'redux';
import Model, { $modelDefinition } from '../Model';
import createModelsReducer from '../createModelsReducer';
import { Id } from '../fieldTypes';
import { actionTypes, reorderEntity, getReorderPayload, updateEntity } from '../actions';

const todos = [
    { id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 },
    { id: 2, title: 'Todo02', date: '2016-01-01', staffMemberId: 1, sortKey: 2 },
    { id: 3, title: 'Todo03', date: '2016-01-01', staffMemberId: 1, sortKey: 3 },
    { id: 4, title: 'Todo04', date: '2016-01-01', staffMemberId: 1, sortKey: 4 },
    { id: 5, title: 'Todo05', date: '2016-01-01', staffMemberId: 2, sortKey: 1 },
    { id: 6, title: 'Todo06', date: '2016-01-01', staffMemberId: 2, sortKey: 2 },
    { id: 7, title: 'Todo07', date: '2016-01-02', staffMemberId: 1, sortKey: 1 },
    { id: 8, title: 'Todo08', date: '2016-01-02', staffMemberId: 1, sortKey: 2 },
];

const data = {
    Entities: {
        todos,
        unorderedTodos: todos,
    },
};

const SimpleTodo = Model(
    {
        id: Id,
        title: String,
        date: String,
        staffMemberId: Number,
        sortKey: Number,
    },
    'unorderedTodos',
    'UnorderedTodo'
);

const Todo = Model(
    {
        id: Id,
        title: String,
        date: String,
        isArchived: Boolean(false),
        staffMemberId: Number,
        sortKey: Number,
    },
    'todos',
    'Todo',
    {
        orderedModel: {
            orderFieldName: 'sortKey',
            orderWithRespectTo: ['date', 'staffMemberId'],
        },
    }
);

const reducers = {
    Entities: createModelsReducer([Todo, SimpleTodo]),
};

const reducer = combineReducers(reducers);
const initialState = reducer(data, {});
const makeTodoFilter = (staffMemberId, date) => todo =>
    todo.staffMemberId === staffMemberId && todo.date === date;
const filteredTodoIds = (staffMemberId, date, state) =>
    Todo.selectors
        .all(state)
        .filter(makeTodoFilter(staffMemberId, date))
        .toList()
        .sortBy(todo => [todo.sortKey, todo.title])
        .map(todo => todo.id)
        .toJS();

function updateOptimistic(entity, data, optimisticId) {
    const { stateKey } = entity[$modelDefinition];
    return {
        type: actionTypes.updateOptimistic,
        meta: {
            stateKey,
            optimisticId: optimisticId.toString(),
        },
        payload: {
            entity,
            data,
        },
    };
}

function update(entity, updatedFields, optimisticId) {
    const { stateKey } = entity[$modelDefinition];
    const data = { ...entity.toJS(), ...updatedFields };
    const serverResponse = {
        entities: {
            [stateKey]: {
                [entity.id]: data,
            },
        },
        result: entity.id,
    };
    return {
        type: actionTypes.update,
        meta: {
            stateKey,
            optimisticId: optimisticId.toString(),
        },
        payload: serverResponse,
    };
}

test('re-order with respect to other entities', () => {
    let state = initialState;
    const getTodo = () => Todo.selectors.all(state).get(1);
    const originalTodo = getTodo();
    state = reducer(initialState, updateOptimistic(getTodo(), { sortKey: 666 }, 1));
    state = reducer(state, updateOptimistic(getTodo(), { title: 'Haha' }, 2));
    expect(getTodo().sortKey).toEqual(666);
    expect(getTodo().title).toEqual('Haha');
    state = reducer(state, update(originalTodo, { title: 'Haha' }, 2));
    expect(getTodo().sortKey).toEqual(666);
    expect(getTodo().title).toEqual('Haha');
});

function getTodos(cls, data, partialRecordFieldNames) {
    const { stateKey } = cls[$modelDefinition];
    const serverResponse = data;
    return {
        type: actionTypes.fetch,
        meta: {
            stateKey,
            partialRecordFieldNames,
        },
        payload: {
            entities: {
                [stateKey]: data.reduce((acc, record) => ({ ...acc, [record.id]: record }), {}),
            },
        },
    };
}

test('fetch entities', () => {
    let state = initialState;
    state = reducer(
        state,
        getTodos(SimpleTodo, [
            { id: 12, title: 'Todo 12', date: '2017-01-01', staffMemberId: 1, sortKey: 1 },
        ])
    );
    expect(SimpleTodo.selectors.all(state).size).toBe(todos.length + 1);
    expect(SimpleTodo.selectors.all(state).get(12).sortKey).toBe(1);
    state = reducer(
        state,
        getTodos(SimpleTodo, [
            { id: 12, title: 'Todo 12', date: '2017-01-01', staffMemberId: 1, sortKey: 5 },
        ])
    );
    expect(SimpleTodo.selectors.all(state).size).toBe(todos.length + 1);
    expect(SimpleTodo.selectors.all(state).get(12).sortKey).toBe(5);
});

test('fetch entities partial', () => {
    let state = initialState;
    state = reducer(state, getTodos(SimpleTodo, [{ id: 13, title: 'Todo 13' }], ['title']));
    expect(SimpleTodo.selectors.all(state).size).toBe(todos.length);
    expect(SimpleTodo.selectors.partialFields.all(state)(['title']).size).toBe(1);
    state = reducer(
        state,
        getTodos(SimpleTodo, [{ id: 14, title: 'Todo 14', sortKey: 4 }], ['title', 'sortKey'])
    );
    expect(SimpleTodo.selectors.all(state).size).toBe(todos.length);
    expect(SimpleTodo.selectors.partialFields.all(state)(['title']).size).toBe(1);
    expect(SimpleTodo.selectors.partialFields.all(state)(['title', 'sortKey']).size).toBe(1);
    expect(SimpleTodo.selectors.partialFields.all(state)(['title', 'sortKey']).size).toBe(1);
    state = reducer(
        state,
        getTodos(SimpleTodo, [{ id: 13, title: 'Todo 13', sortKey: 4 }], ['title', 'sortKey'])
    );

    // If we do a full fetch then all partial entries should be updated
    const fullTodo = {
        id: 13,
        title: 'Should change',
        date: '2017-03-02',
        staffMemberId: 1,
        sortKey: 5,
    };
    state = reducer(state, getTodos(SimpleTodo, [fullTodo]));
    expect(SimpleTodo.selectors.all(state).size).toBe(todos.length + 1);
    expect(
        SimpleTodo.selectors.partialFields
            .all(state)(['title'])
            .get(13).title
    ).toBe('Should change');
    let todo13 = SimpleTodo.selectors.partialFields
        .all(state)(['title', 'sortKey'])
        .get(13);
    expect(todo13.title).toBe('Should change');
    expect(todo13.sortKey).toBe(5);
    expect(todo13.date).toBe(null);
    state = reducer(state, update(SimpleTodo.selectors.all(state).get(13), { title: 'Haha' }, 2));
    todo13 = SimpleTodo.selectors.partialFields
        .all(state)(['title', 'sortKey'])
        .get(13);
    expect(todo13.title).toBe('Haha');
    expect(todo13.sortKey).toBe(5);
    expect(todo13.date).toBe(null);
    expect(todo13.toJS()).toEqual({
        id: 13,
        title: 'Haha',
        sortKey: 5,
    });
});

test('fetch entities partial - ordered', () => {
    // On the ordered model we also retain fields used for sorting even
    // if those fields aren't explicitly specified in the partial list
    // of field names
    let state = initialState;
    state = reducer(state, getTodos(Todo, [{ id: 13, title: 'Todo 13' }], ['title']));
    expect(Todo.selectors.all(state).size).toBe(todos.length);
    expect(Todo.selectors.partialFields.all(state)(['title']).size).toBe(1);
    state = reducer(
        state,
        getTodos(Todo, [{ id: 14, title: 'Todo 14', sortKey: 4 }], ['title', 'sortKey'])
    );
    expect(Todo.selectors.all(state).size).toBe(todos.length);
    expect(Todo.selectors.partialFields.all(state)(['title']).size).toBe(1);
    expect(Todo.selectors.partialFields.all(state)(['title', 'sortKey']).size).toBe(1);
    expect(Todo.selectors.partialFields.all(state)(['title', 'sortKey']).size).toBe(1);
    state = reducer(
        state,
        getTodos(Todo, [{ id: 13, title: 'Todo 13', sortKey: 4 }], ['title', 'sortKey'])
    );

    // If we do a full fetch then all partial entries should be updated
    const fullTodo = {
        id: 13,
        title: 'Should change',
        date: '2017-03-02',
        staffMemberId: 1,
        sortKey: 5,
    };
    state = reducer(state, getTodos(Todo, [fullTodo]));
    expect(Todo.selectors.all(state).size).toBe(todos.length + 1);
    expect(
        Todo.selectors.partialFields
            .all(state)(['title'])
            .get(13).title
    ).toBe('Should change');
    let todo13 = Todo.selectors.partialFields
        .all(state)(['title', 'sortKey'])
        .get(13);
    expect(todo13.title).toBe('Should change');
    expect(todo13.sortKey).toBe(5);
    expect(todo13.date).toBe('2017-03-02');
    state = reducer(state, update(Todo.selectors.all(state).get(13), { title: 'Haha' }, 2));
    todo13 = Todo.selectors.partialFields
        .all(state)(['title', 'sortKey'])
        .get(13);
    expect(todo13.title).toBe('Haha');
    expect(todo13.sortKey).toBe(5);
    expect(todo13.date).toBe('2017-03-02');
    expect(todo13.toJS()).toEqual({
        id: 13,
        title: 'Haha',
        sortKey: 5,
        date: '2017-03-02',
        staffMemberId: 1,
    });
});

test('partialFields should get updated even if no results', () => {
    let state = initialState;
    expect(
        state.Entities.getIn(['todos', 'partialRecords', 'synced', new Set(['title'])])
    ).toBeUndefined();
    state = reducer(state, getTodos(Todo, [], ['title']));
    expect(
        state.Entities.getIn(['todos', 'partialRecords', 'synced', new Set(['title'])])
    ).not.toBeUndefined();
    expect(
        state.Entities.getIn(['todos', 'partialRecords', 'synced', new Set(['title'])]).toJS()
    ).toEqual({});
});

test('partialField selectors should return empty map if no results', () => {
    const state = initialState;
    expect(SimpleTodo.selectors.partialFields.all(state)(['title']).size).toBe(0);
    expect(SimpleTodo.selectors.partialFields.synced(state)(['title']).size).toBe(0);
    expect(SimpleTodo.selectors.partialFields.local(state)(['title']).size).toBe(0);
});

test('partialField selectors should throw on invalid field names', () => {
    const state = initialState;
    expect(() => SimpleTodo.selectors.partialFields.all(state)(['invalid_field'])).toThrowError(
        'Some field(s) passed to partialFields selector are not valid: invalid_field'
    );
    expect(() =>
        SimpleTodo.selectors.partialFields.all(state)(['title', 'invalid_field1', 'invalid_field2'])
    ).toThrowError(
        'Some field(s) passed to partialFields selector are not valid: invalid_field1, invalid_field2'
    );
});

test('partialField selectors should work if you specify id', () => {
    // There were special cases on 'id' that meant this specific case broke
    let state = {};
    const partialRecordFieldNames = ['id', 'title'];
    state = reducer(state, getTodos(Todo, [{ id: 13, title: 'Todo 13' }], partialRecordFieldNames));
    expect(Todo.selectors.partialFields.all(state)(partialRecordFieldNames).size).toBe(1);
    // For historical reasons with or without 'id' is the same
    expect(Todo.selectors.partialFields.all(state)(partialRecordFieldNames)).toEqual(
        Todo.selectors.partialFields.all(state)(['title'])
    );
});

test('partialField selectors should work if you specify a boolean field with a default', () => {
    let state = {};
    const partialRecordFieldNames = ['title', 'isArchived'];
    state = reducer(
        state,
        getTodos(Todo, [{ id: 13, title: 'Todo 13', isArchived: false }], partialRecordFieldNames)
    );
    expect(Todo.selectors.partialFields.all(state)(partialRecordFieldNames).size).toBe(1);
});
