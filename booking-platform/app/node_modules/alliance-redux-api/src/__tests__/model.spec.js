import { Maybe, Record, List, Typed } from 'typed-immutable';
import Model, { $modelDefinition } from '../Model';
import { combineReducers } from 'redux';
import createModelsReducer from '../createModelsReducer';
import createModelReducer from '../createModelReducer';
import Field from '../Field';
import { Id } from '../fieldTypes';

const DateField = Field(Date, value => value.toDateString());

const FileType = Field(Typed.String, value => {
    if (typeof value == 'string') {
        return undefined;
    }
    return value;
});

test('serialize model', () => {
    const Person = Model(
        {
            id: Number,
            name: String,
            dob: DateField,
            file: FileType,
        },
        'person',
        'Person'
    );

    const value = new Person({
        id: 1,
        name: 'Test',
        dob: '2016-09-01',
        file: 'should be removed',
    });

    expect(value.modelUUID).toBeDefined();
    expect(value.serialize()).toEqual({
        id: 1,
        name: 'Test',
        dob: 'Thu Sep 01 2016',
    });
});

test('serialize model nested', () => {
    const PictureOfMyPicture = Record(
        {
            id: Number,
            file: FileType,
        },
        'Picture o my Picture'
    );
    const Pictures = Model(
        {
            id: Number,
            label: String,
            file: FileType,
            morePictures: Maybe(List(PictureOfMyPicture)),
            fav: Maybe(PictureOfMyPicture),
        },
        'pictures',
        'Pictures'
    );
    const Person = Model(
        {
            id: Number,
            name: String,
            dob: DateField,
            pictures: List(Pictures),
        },
        'person',
        'Person'
    );

    let value = new Person({
        id: 1,
        name: 'Test',
        dob: '2016-09-01',
        pictures: [{ id: 1, label: 'item1', file: 'should be removed' }],
    });
    expect(value.serialize()).toEqual({
        id: 1,
        name: 'Test',
        dob: 'Thu Sep 01 2016',
        pictures: [{ id: 1, label: 'item1' }],
    });
    value = new Person({
        id: 1,
        name: 'Test',
        dob: '2016-09-01',
        pictures: [
            {
                id: 1,
                label: 'item1',
                file: 'should be removed',
                morePictures: [{ id: 1, file: 'also gone' }],
                fav: { id: 2, file: 'no more' },
            },
        ],
    });
    expect(value.serialize()).toEqual({
        id: 1,
        name: 'Test',
        dob: 'Thu Sep 01 2016',
        pictures: [{ id: 1, label: 'item1', morePictures: [{ id: 1 }], fav: { id: 2 } }],
    });
});

test('handle compound keys', () => {
    const TimeWorked = Model(
        {
            date: DateField,
            staffMemberId: Number,
            hours: Number,
        },
        'time-worked',
        'TimeWorked',
        { idFieldName: ['date', 'staffMemberId'] }
    );
    const value = new TimeWorked({
        date: '2016-09-01',
        staffMemberId: 1,
        hours: 1,
    });
    const id = value.getId();
    expect(id).toBe('Thu Sep 01 2016_1');
});

test('sortable model definition', () => {
    expect(() =>
        Model(
            {
                id: Number,
                date: DateField,
                staffMemberId: Number,
            },
            'todo',
            'Todo',
            {
                orderedModel: {
                    orderFieldName: 'sortKey',
                    orderWithRespectTo: ['date', 'staffMember'],
                },
            }
        )
    ).toThrow(/Specified orderFieldName sortKey does not exist/);

    expect(() =>
        Model(
            {
                id: Number,
                date: DateField,
                staffMemberId: Number,
                sortKey: Number,
            },
            'todo',
            'Todo',
            {
                orderedModel: {
                    orderFieldName: 'sortKey',
                    orderWithRespectTo: ['date', 'staffMember'],
                },
            }
        )
    ).toThrow(/Specified field staffMember in orderWithRespectTo/);
});

test('string id fields', () => {
    const ModelWithStringId = Model(
        {
            id: String,
            name: String,
        },
        'model',
        'ModelWithStringId'
    );
    const reducers = {
        Entities: createModelsReducer([ModelWithStringId]),
    };
    const reducer = combineReducers(reducers);
    const s = reducer(
        {
            Entities: {
                model: [{ id: 'item1', name: 'Item 1' }, { id: 'item2', name: 'Item 2' }],
            },
        },
        {}
    );
    expect(ModelWithStringId.selectors.all(s.Entities).get('item1').name).toEqual('Item 1');
    expect(ModelWithStringId.selectors.all(s.Entities).get('item2').name).toEqual('Item 2');
    expect(ModelWithStringId.selectors.all(s.Entities).get('item3')).toBe(undefined);
});
