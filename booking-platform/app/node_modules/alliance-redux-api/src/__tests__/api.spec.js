import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import fetchMock from 'fetch-mock';
import { apiMiddleware } from 'redux-api-middleware';

const middlewares = [thunk, apiMiddleware];
const mockStore = configureMockStore(middlewares);

import { configureApi, get } from '../api';
import { abortSignalError } from '../testUtils';

beforeEach(() => {
    global.FormData = jest.fn(() => ({
        append(key, value) {
            this[key] = value;
        },
    }));
    global.File = jest.fn();
    global.document.cookie = 'csrftoken=abc123';
});

afterEach(() => {
    fetchMock.reset();
    fetchMock.restore();
});

configureApi('http://localhost/');

test('encode get parameters scalar', async () => {
    // For this case don't care about what fetch returns
    fetchMock.get('*', {});

    const store = mockStore({ todos: [] });
    await store.dispatch(
        get('/test', {
            name: 'sam',
        })
    );
    let actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?name=sam');
    store.clearActions();
    await store.dispatch(
        get('/test', {
            name: '',
        })
    );
    actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?name=');
});

test('encode get parameters list', async () => {
    // For this case don't care about what fetch returns
    fetchMock.get('*', {});

    const store = mockStore({ todos: [] });
    await store.dispatch(
        get('/test', {
            names: ['sam', 'frodo', 'gandalf'],
        })
    );
    let actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe(
        'http://localhost/test/?names=sam&names=frodo&names=gandalf'
    );
    store.clearActions();
    await store.dispatch(
        get('/test', {
            names: ['sam'],
        })
    );
    actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?names=sam');
    store.clearActions();
    await store.dispatch(
        get('/test', {
            names: [],
        })
    );
    actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?names=');
});

test('encode get parameters - django value conversion', async () => {
    // For this case don't care about what fetch returns
    fetchMock.get('*', {});

    const store = mockStore({ todos: [] });
    await store.dispatch(
        get('/test', {
            checked: true,
        })
    );
    let actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?checked=True');
    store.clearActions();
    await store.dispatch(
        get('/test', {
            checked: false,
        })
    );
    actions = store.getActions();
    expect(actions[0].meta.endpoint).toBe('http://localhost/test/?checked=False');
});

test('support abort signal', async () => {
    fetchMock.get('*', {});

    const store = mockStore();
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(
        store.dispatch(
            get(
                '/test',
                {},
                {
                    fetchOptions: {
                        signal,
                    },
                }
            )
        )
    ).resolves.toEqual(
        expect.objectContaining({
            error: true,
            payload: abortSignalError,
        })
    );
});
