import Immutable from 'immutable';
import { combineReducers, createStore, applyMiddleware } from 'redux';
import { Maybe } from 'typed-immutable';
import thunk from 'redux-thunk';
import { apiMiddleware } from 'redux-api-middleware';
import fetchMock from 'fetch-mock';

import Model from '../Model';
import { Id } from '../fieldTypes';
import createModelsReducer from '../createModelsReducer';
import { configureApi } from '../api';
import {
    customDetailRoute,
    customListRoute,
    deleteEntity,
    addEntity,
    updateEntity,
    fetchEntities,
    fetchEntity,
} from '../actions';
import { abortSignalError, parseJsonMatch } from '../testUtils';

export class TemporaryCache {
    constructor() {
        this.cache = Immutable.Map();
        this.fetchedDateFormat = 'YYYY-MM-DD HH:mm:ss';
        this.lifetime = {
            unit: 'hours',
            amount: 1,
        };
    }

    clear() {
        this.cache = Immutable.Map();
    }

    get(getState, filters, selectFromRedux) {
        const data = this.cache.get(Immutable.fromJS(filters));
        if (data) {
            // filters is an object when dealing with a listModel call and an id when dealing with getModel call
            // For list calls check if the known records for this model has changed - if it has we should not use
            // the cached values as may incorrectly exclude added values (eg. when using pagination on a list view)
            if (typeof filters === 'object') {
                const keys = selectFromRedux()
                    .keySeq()
                    .toSet();
                if (keys.equals(data.keys)) {
                    return data.value;
                }
            } else {
                return data.value;
            }
        }

        return null;
    }

    set(getState, filters, value, selectFromRedux) {
        const fetchedDate = new Date();
        let keys;
        // When dealing with a list call cache the current known keys (which are the record ids) so we can compare
        // then in `get` and see if new records have been added/removed
        if (typeof filters == 'object') {
            keys = selectFromRedux()
                .keySeq()
                .toSet();
        }
        this.cache = this.cache.set(Immutable.fromJS(filters), { keys, fetchedDate, value });
    }
}

const middlewares = [thunk, apiMiddleware];

const todos = [{ id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 }];

const initialState = {
    Entities: {
        todos,
    },
};

const Todo = Model(
    {
        id: Id,
        title: String,
        date: String,
        staffMemberId: Maybe(Number),
        sortKey: Number,
    },
    'todos',
    'Todo',
    {
        orderedModel: {
            orderFieldName: 'sortKey',
            orderWithRespectTo: ['date', 'staffMemberId'],
        },
    }
);

const TodoWithCache = Model(
    {
        id: Id,
        title: String,
        date: String,
        staffMemberId: Maybe(Number),
        sortKey: Number,
    },
    'todosWithCaching',
    'Todo',
    {
        orderedModel: {
            orderFieldName: 'sortKey',
            orderWithRespectTo: ['date', 'staffMemberId'],
        },
        cache: new TemporaryCache(),
    }
);

const reducers = {
    Entities: createModelsReducer([Todo, TodoWithCache]),
};

const reducer = combineReducers(reducers);

beforeEach(() => {
    global.document.cookie = 'csrftoken=abc123';
});
afterEach(() => {
    fetchMock.reset();
    fetchMock.restore();
});

configureApi('http://localhost/');

test('updateEntity should pass through null values', async () => {
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    const todo = Todo.selectors.all(store.getState()).get(1);
    // We don't particularly care what the fetch returns just needs to be valid for updateEntity.
    // For this test we just need to make sure it gets passed the expected data.
    global.fetch = jest.fn((url, data) =>
        Promise.resolve({
            ok: true,
            headers: new Map([['Content-Type', 'application/json']]),
            async json() {
                return {
                    ...todo.toJS(),
                    ...data.body,
                };
            },
        })
    );
    await store.dispatch(updateEntity(todo, { staffMemberId: null, title: 'blah' }));
    expect(global.fetch).toHaveBeenCalledWith(
        'http://localhost/todos/1/',
        expect.objectContaining({
            method: 'PATCH',
            body: parseJsonMatch({
                title: 'blah',
                staffMemberId: null,
            }),
        })
    );
    await store.dispatch(updateEntity(todo, { staffMemberId: undefined, title: 'blah2' }));
    expect(global.fetch).toHaveBeenLastCalledWith(
        'http://localhost/todos/1/',
        expect.objectContaining({
            method: 'PATCH',
            body: parseJsonMatch({
                title: 'blah2',
            }),
        })
    );
});

test('fetchEntities cache results', async () => {
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    // We don't particularly care what the fetch returns just needs to be valid for updateEntity.
    // For this test we just need to make sure it gets passed the expected data.
    const todos = [
        { id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 },
        { id: 2, title: 'Todo02', date: '2016-02-02', staffMemberId: 2, sortKey: 2 },
        { id: 3, title: 'Todo03', date: '2016-03-03', staffMemberId: 3, sortKey: 3 },
    ];
    global.fetch = jest.fn((url, data) =>
        Promise.resolve({
            ok: true,
            headers: new Map([['Content-Type', 'application/json']]),
            async json() {
                return todos;
            },
        })
    );
    const response = await store.dispatch(fetchEntities(TodoWithCache));
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(
        TodoWithCache.selectors
            .all(store.getState())
            .toList()
            .toJS()
    ).toEqual(todos.map(expect.objectContaining));
    const response2 = await store.dispatch(fetchEntities(TodoWithCache));
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(response.entities).toEqual(response2.entities);
    expect(response.ids).toEqual(response2.ids);
    expect(response.count).toEqual(response2.count);
});

test('fetchEntities with partialRecordFields cache results', async () => {
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    // We don't particularly care what the fetch returns just needs to be valid for updateEntity.
    // For this test we just need to make sure it gets passed the expected data.
    const todos = [
        { id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 },
        { id: 2, title: 'Todo02', date: '2016-02-02', staffMemberId: 2, sortKey: 2 },
        { id: 3, title: 'Todo03', date: '2016-03-03', staffMemberId: 3, sortKey: 3 },
    ];
    const partialRecordFieldNames = ['id', 'title', 'date'];
    const partialTodos = todos.map(todo =>
        ['id', ...partialRecordFieldNames].reduce((obj, fieldName) => {
            obj[fieldName] = todo[fieldName];
            return obj;
        }, {})
    );
    global.fetch = jest.fn((url, data) =>
        Promise.resolve({
            ok: true,
            headers: new Map([['Content-Type', 'application/json']]),
            async json() {
                return partialTodos;
            },
        })
    );
    const response = await store.dispatch(
        fetchEntities(TodoWithCache, {}, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(
        TodoWithCache.selectors.partialFields
            .all(store.getState())(partialRecordFieldNames)
            .toList()
            .toJS()
    ).toEqual(partialTodos.map(expect.objectContaining));
    const response2 = await store.dispatch(
        fetchEntities(TodoWithCache, {}, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(response.entities).toEqual(response2.entities);
    expect(response.ids).toEqual(response2.ids);
    expect(response.count).toEqual(response2.count);
});

test('fetchEntity with partialRecordFields cache results', async () => {
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    // We don't particularly care what the fetch returns just needs to be valid for updateEntity.
    // For this test we just need to make sure it gets passed the expected data.
    const todos = [
        { id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 },
        { id: 2, title: 'Todo02', date: '2016-02-02', staffMemberId: 2, sortKey: 2 },
        { id: 3, title: 'Todo03', date: '2016-03-03', staffMemberId: 3, sortKey: 3 },
    ];
    const partialRecordFieldNames = ['id', 'title', 'date'];
    const partialTodos = todos.map(todo =>
        ['id', ...partialRecordFieldNames].reduce((obj, fieldName) => {
            obj[fieldName] = todo[fieldName];
            return obj;
        }, {})
    );
    global.fetch = jest.fn((url, data) =>
        Promise.resolve({
            ok: true,
            headers: new Map([['Content-Type', 'application/json']]),
            async json() {
                const id = Number(
                    url
                        .split('/')
                        .filter(Boolean)
                        .pop()
                );
                const todo = partialTodos.filter(todo => todo.id === id)[0];
                return todo;
            },
        })
    );
    const response = await store.dispatch(
        fetchEntity(TodoWithCache, 1, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(
        TodoWithCache.selectors.partialFields
            .all(store.getState())(partialRecordFieldNames)
            .first()
            .toJS()
    ).toEqual(expect.objectContaining(partialTodos[0]));
    const response2 = await store.dispatch(
        fetchEntity(TodoWithCache, 1, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(response).toEqual(response2);
});

test('fetchEntity should work with filter instead of id', async () => {
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    // We don't particularly care what the fetch returns just needs to be valid for updateEntity.
    // For this test we just need to make sure it gets passed the expected data.
    const todos = [
        { id: 1, title: 'Todo01', date: '2016-01-01', staffMemberId: 1, sortKey: 1 },
        { id: 2, title: 'Todo02', date: '2016-02-02', staffMemberId: 2, sortKey: 2 },
        { id: 3, title: 'Todo03', date: '2016-03-03', staffMemberId: 3, sortKey: 3 },
        { id: 4, title: 'Todo03', date: '2016-03-04', staffMemberId: 4, sortKey: 4 },
    ];
    const partialRecordFieldNames = ['id', 'title', 'date'];
    const partialTodos = todos.map(todo =>
        ['id', ...partialRecordFieldNames].reduce((obj, fieldName) => {
            obj[fieldName] = todo[fieldName];
            return obj;
        }, {})
    );
    global.fetch = jest.fn((url, data) => {
        const [, query] = url.split('?');
        const params = query.split('&').reduce((acc, pair) => {
            const [key, value] = pair.split('=');
            acc[key] = value;
            return acc;
        }, {});
        return Promise.resolve({
            ok: true,
            headers: new Map([['Content-Type', 'application/json']]),
            async json() {
                return partialTodos.filter(todo => {
                    return Object.entries(params).reduce((matches, [key, value]) => {
                        // eslint-disable-next-line eqeqeq
                        return matches && todo[key] == value;
                    }, true);
                });
            },
        });
    });
    const response = await store.dispatch(
        fetchEntity(TodoWithCache, { id: 1 }, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(
        TodoWithCache.selectors.partialFields
            .all(store.getState())(partialRecordFieldNames)
            .first()
            .toJS()
    ).toEqual(expect.objectContaining(partialTodos[0]));
    // Cache should still work with filters
    const response2 = await store.dispatch(
        fetchEntity(TodoWithCache, { id: 1 }, { partialRecordFieldNames })
    );
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(response).toEqual(response2);

    // If multiple objects returned should be a 400
    global.console.warn = jest.fn();
    const fetchPromise = store.dispatch(
        fetchEntity(TodoWithCache, { title: 'Todo03' }, { partialRecordFieldNames })
    );
    await expect(fetchPromise).rejects.toEqual(
        expect.objectContaining({
            status: 400,
            message: expect.stringContaining('Multiple objects'),
        })
    );
    expect(global.console.warn).toHaveBeenCalledWith(expect.stringContaining('Expected only one'));
    expect(global.fetch).toHaveBeenCalledTimes(2);
    expect(
        store.dispatch(
            fetchEntity(TodoWithCache, { title: 'UNKNOWN' }, { partialRecordFieldNames })
        )
    ).rejects.toEqual(
        expect.objectContaining({
            status: 404,
        })
    );
    expect(global.fetch).toHaveBeenCalledTimes(3);
});

test('fetchEntity should support abort signal', async () => {
    // For this case don't care about what fetch returns
    fetchMock.get('*', {});
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(
        store.dispatch(fetchEntity(TodoWithCache, 1, { fetchOptions: { signal } }))
    ).rejects.toEqual(abortSignalError);
});

test('fetchEntities should support abort signal', async () => {
    // For this case don't care about what fetch returns
    fetchMock.get('*', {});
    const store = createStore(reducer, {}, applyMiddleware(...middlewares));
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(
        store.dispatch(fetchEntities(TodoWithCache, {}, { fetchOptions: { signal } }))
    ).rejects.toEqual(abortSignalError);
});

test('updateEntity should support abort signal', async () => {
    // For this case don't care about what fetch returns
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    const todo = Todo.selectors.all(store.getState()).get(1);
    fetchMock.patch('*', todo.toJS());
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(store.dispatch(updateEntity(todo, {}, { fetchOptions: { signal } }))).rejects.toEqual(
        abortSignalError
    );
});

test('addEntity should support abort signal', async () => {
    // For this case don't care about what fetch returns
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    fetchMock.post('*', {});
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(store.dispatch(addEntity(Todo, {}, { fetchOptions: { signal } }))).rejects.toEqual(
        abortSignalError
    );
});

test('deleteEntity should support abort signal', async () => {
    // For this case don't care about what fetch returns
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    const todo = Todo.selectors.all(store.getState()).get(1);
    fetchMock.delete('*', {});
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(store.dispatch(deleteEntity(todo, {}, { fetchOptions: { signal } }))).rejects.toEqual(
        abortSignalError
    );
});

test('customDetailRoute should support abort signal', async () => {
    // For this case don't care about what fetch returns
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    const todo = Todo.selectors.all(store.getState()).get(1);
    fetchMock.patch('*', todo.toJS());
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(
        store.dispatch(customDetailRoute('patch', todo, 'test', {}, { fetchOptions: { signal } }))
    ).rejects.toEqual(abortSignalError);
});

test('customListRoute should support abort signal', async () => {
    // For this case don't care about what fetch returns
    const store = createStore(reducer, initialState, applyMiddleware(...middlewares));
    const todo = Todo.selectors.all(store.getState()).get(1);
    fetchMock.patch('*', todo.toJS());
    const controller = new AbortController();
    const signal = controller.signal;
    controller.abort();
    expect(
        store.dispatch(customListRoute('patch', Todo, 'test', {}, { fetchOptions: { signal } }))
    ).rejects.toEqual(abortSignalError);
});
