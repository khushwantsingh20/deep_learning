import { List } from 'typed-immutable';
import { combineReducers } from 'redux';
import Model from '../Model';
import { Numeric } from '../fieldTypes';
import ForeignKeyField from '../ForeignKeyField';
import createModelReducer from '../createModelReducer';
import createModelsReducer from '../createModelsReducer';
import { actionTypes } from '../actions';

const data = {
    Entities: {
        articles: [
            {
                id: 1,
                title: 'Some Article',
                author: {
                    id: 7,
                    name: 'Dan',
                },
                contributors: [
                    {
                        id: 10,
                        name: 'Abe',
                    },
                    {
                        id: 15,
                        name: 'Fred',
                    },
                ],
            },
        ],
    },
};

const User = Model(
    {
        id: Numeric,
        name: String,
    },
    'users',
    'User'
);

const Article = Model(
    {
        id: Numeric,
        title: String,
        authorId: ForeignKeyField(User, { schemaFieldName: 'author' }),
        contributorIds: List(ForeignKeyField(User, { schemaFieldName: 'contributors' })),
    },
    'articles',
    'Article',
    {
        buildSelectors: defaultSelectors => ({
            first: state => defaultSelectors.all(state).first(),
        }),
    }
);

const reducers = {
    Entities: createModelsReducer([createModelReducer(Article), createModelReducer(User)]),
};
const reducer = combineReducers(reducers);

function serializeEntities(entities) {
    return entities
        .toMap()
        .map(record => record.serialize())
        .toJS();
}

test('model reducer', () => {
    const state = reducer(data, {});
    expect(Article.selectors.first(state)).toEqual(state.Entities.articles.synced.first());
});

test('model fetch', () => {
    const state = reducer(undefined, {});
    const articles = {
        2: {
            id: 2,
            title: 'A new article',
            authorId: 7,
            contributorIds: [10],
        },
    };
    const state1 = reducer(state, {
        type: actionTypes.fetch,
        payload: {
            entities: {
                articles,
            },
        },
        meta: {
            stateKey: 'articles',
        },
    });
    expect(state1.Entities.articles.synced.size).toEqual(1);
    expect(serializeEntities(state1.Entities.articles.synced)).toEqual(articles);
    const state2 = reducer(state1, {
        type: actionTypes.fetch,
        payload: {
            entities: {
                articles,
            },
        },
        meta: {
            stateKey: 'articles',
        },
    });
    expect(serializeEntities(state2.Entities.articles.synced)).toEqual(articles);
    const entity1 = state1.Entities.articles.synced.get(2);
    const entity2 = state2.Entities.articles.synced.get(2);
    // modelUUID should be retained if samea entity is fetched again
    expect(entity1.modelUUID).toBeTruthy();
    expect(entity2.modelUUID).toBe(entity2.modelUUID);
    expect(
        state2.Entities.articles.synced.get(2).equals(state1.Entities.articles.synced.get(2))
    ).toBe(true);
});
