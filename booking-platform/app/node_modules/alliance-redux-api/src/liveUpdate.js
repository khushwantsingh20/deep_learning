import ReconnectingWebSocket from 'reconnecting-websocket';
import { liveUpdateModels, liveUpdateListeners, $modelDefinition } from './Model';
import normalize from './normalize';
import { actionTypes } from './actions';
import { CLIENT_UID } from './api';

/**
 * Initialise live updates for entities.
 *
 * This works with django-channels on the backend. For any model you want
 * live updates on you need to create a 'Binding' class
 * (eg. forward_planning.models.WeekAllocationBinding) that defines that model,
 * serializer class and permissions required to receive updates on entities.
 * That will start triggering changes that you can observer in the network
 * panel (click on the WS tab and inspect each frame that comes through)
 *
 * On the frontend you need to opt a record into live updates by specifying
 * the model it maps to on the backend - this is the model label string
 * that you will see in the payload sent from the backend. Specify this with
 * the 'liveUpdateModel' option in the call to Model():
 *
 *   import Model from 'alliance-redux-api/Model';
 *   const TodoRecord = Model({
 *     // ... specify fields as normal
 *   }, 'todos', 'Todo Items', { liveUpdateModel: 'dashboard.todo' });
 *
 * Once this is done redux store should update live when any model changes
 * are triggered on the backend. Note that a client will ignore any model
 * changes that are triggered by them to avoid applying the same change twice.
 *
 * @param {Object} store redux store - used to dispatch actions based on
 * updates received from the server
 */
export default function initialiseLiveUpdater(store, host = window.location.host) {
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const socket = new ReconnectingWebSocket(`${wsScheme}://${host}`);
    socket.onmessage = event => {
        const message = JSON.parse(event.data);
        if (!message) {
            console.warn(
                // eslint-disable-line
                'Received invalid json string in message',
                message
            );
            return;
        }
        const { stream, payload } = message;
        if (stream !== 'model_updates') {
            return;
        }
        if (!payload.action) {
            console.warn(
                // eslint-disable-line
                'Expected action field in data',
                payload
            );
            return;
        }
        const { action, clientId, data, model } = payload;
        // This client triggered this message so ignore it
        if (clientId === CLIENT_UID) {
            return;
        }

        const entityRecord = liveUpdateModels[model];
        if (!entityRecord) {
            if (__DEBUG__) {
                console.warn(
                    // eslint-disable-line
                    `Received live updates for '${model}' but no record is registered ` +
                        `for that. Make sure the 'liveUpdateModel' option is set to '${model}'` +
                        'on the relevant call to Model(). We know about the ' +
                        `following models: ${Object.keys(liveUpdateModels).join(', ')}`,
                    message
                );
            }
            return;
        }
        const { stateKey } = entityRecord[$modelDefinition];
        const meta = {
            stateKey,
            liveUpdate: true,
        };
        switch (action) {
            case 'update': {
                store.dispatch({
                    type: actionTypes.update,
                    payload: normalize(entityRecord, data),
                    meta,
                });
                break;
            }
            case 'create': {
                store.dispatch({
                    type: actionTypes.add,
                    payload: normalize(entityRecord, data),
                    meta,
                });
                break;
            }
            case 'bulk_update':
            case 'bulk_create': {
                store.dispatch({
                    type: actionTypes.fetch,
                    payload: normalize(entityRecord, data),
                    meta,
                });
                break;
            }
            case 'delete': {
                store.dispatch({
                    type: actionTypes.delete,
                    payload: data,
                    meta,
                });
                break;
            }
            default:
                console.warn(
                    // eslint-disable-line
                    `Received unknown live update action ${action}`,
                    message
                );
        }
        liveUpdateListeners.forEach(fn => fn(entityRecord, payload, store));
    };
}
