import uid from './uid';
import map from 'lodash/map';
import trim from 'lodash/trim';
import invariant from 'invariant';
import startsWith from 'lodash/startsWith';
import identity from 'lodash/identity';
import { CALL_API } from 'redux-api-middleware';

export const API_CALL_REQUEST = '@alliance-redux-api/apiCallRequest';
export const API_CALL_RESULT = '@alliance-redux-api/apiCallResult';
export const API_CALL_AUTH_REQUIRED = '@alliance-redux-api/authRequired';

export const CLIENT_UID = uid.v4();

const apiSettings = {};
let defaultApi = null;
const defaultConfiguration = {
    // True for historical reason (exists only for historical reasons - could be
    // done as part of headers param below)
    includeCsrfTokenHeader: true,
    appendSlash: true,
    // Set this to true to avoid sending a API_CALL_AUTH_REQUIRED action on
    // a 401
    bypassAuthRetry: false,
    // Only one configuration can be default
    isDefault: true,
    credentials: 'include',
    headers: {},
    includeClientIdHeader: false,
};

export function configureApi(baseUrl, config) {
    if (typeof baseUrl != 'string') {
        throw new Error(
            'configureApi() has changed signature to configureApi(baseUrl: string, config:Object)'
        );
    }
    apiSettings[baseUrl] = { ...defaultConfiguration, ...config, baseUrl };
    if (apiSettings[baseUrl].isDefault && defaultApi) {
        throw new Error(
            `Default API already set to ${defaultApi}; you can only have one default. Pass { isDefault: false, /* other options */ } to configureApi for ${baseUrl}`
        );
    }
    if (apiSettings[baseUrl].isDefault) {
        defaultApi = baseUrl;
    }
}

export function setBaseApiUrl() {
    throw new Error('Please use configureApi instead of setBaseApiUrl');
}

export function toQueryString(params, convertValue = identity) {
    return map(params, (value, key) => {
        if (Array.isArray(value)) {
            const values = value
                .map(v => encodeURIComponent(convertValue(v)))
                .join(`&${encodeURIComponent(key)}=`);
            return `${encodeURIComponent(key)}=${values}`;
        }
        return `${encodeURIComponent(key)}=${encodeURIComponent(convertValue(value))}`;
    }).join('&');
}

function buildApiUrl(endPoint) {
    const apiConfig = getApiConfigFor(endPoint);
    const [uri, query] = endPoint.split('?');
    let url = `${apiConfig.baseUrl}${trim(uri, '/')}`;
    if (apiConfig.appendSlash) {
        url = `${url}/`;
    }
    if (query) {
        url += `?${query}`;
    }
    return url;
}

function isAbsUrl(maybeUrl) {
    return startsWith(maybeUrl, 'http://') || startsWith(maybeUrl, 'https://');
}

/**
 * Helper to get django CSRF token. Needs to be called on every request as
 * the token can change (ie. after you login it will change)
 * @return {String} token
 */
function getCsrfToken() {
    const cookieMatch = document.cookie.match(/csrftoken=(.*?)(?:$|;)/);
    if (cookieMatch && cookieMatch.length > 1) {
        return cookieMatch[1];
    }
    console.error(
        // eslint-disable-line
        'CSRF cookie not set. Authentication can not take place. Please contact a developer.'
    );
    return 'COOKIE NOT FOUND';
}

export function isApiConfigured(baseUrl) {
    if (!isAbsUrl(baseUrl)) {
        return !!apiSettings[defaultApi];
    }
    const matches = Object.keys(apiSettings).filter(key => baseUrl.startsWith(key));
    return matches.length > 0;
}

export function getApiConfigFor(url) {
    if (!isAbsUrl(url)) {
        const config = apiSettings[defaultApi];
        invariant(
            config,
            "Default API config not set - you must set this with 'configureApi(baseUrl, { isDefault: true })' in your app entry file before using relative API urls"
        );
        return config;
    } else {
        const matches = Object.keys(apiSettings).filter(key => url.startsWith(key));
        if (matches.length > 1) {
            console.warn(`Multiple configurations found for ${url}, using ${matches[0]}`);
        }
        if (matches.length > 0) {
            return apiSettings[matches[0]];
        }
        return defaultConfiguration;
    }
}

export function buildHeaders(apiConfig, extraHeaders = {}) {
    const finalHeaders = {
        ...apiConfig.headers,
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...extraHeaders,
    };
    if (apiConfig.includeClientIdHeader) {
        finalHeaders['X-Client-UID'] = CLIENT_UID;
    }
    if (apiConfig.includeCsrfTokenHeader) {
        finalHeaders['X-CSRFToken'] = getCsrfToken();
    }
    return finalHeaders;
}

/**
 * Call an endpoint. See @post() and @get() below for method helpers.
 *
 * If the request itself fails (eg. you provide an invalid actionType) then
 * only the request action type will be dispatched and it will be marked as
 * an error.
 *
 * Otherwise requestType will be dispatched followed by either successType
 * or failureType depending on status code response. By default these action
 * types are the same - you can differentiate in reducer if 'error' key is
 * set to true.
 *
 * @param {String} endpoint can be relative in which case it will be made
 * absolute with baseUrl
 * @param {String} method
 * @param {Object?} data
 * @param {Object?} config
 */
export function callApi(
    endpoint,
    method,
    data,
    {
        types = [API_CALL_REQUEST, API_CALL_RESULT, API_CALL_RESULT],
        requestType = types[0],
        successType = types[1],
        failureType = successType,
        headers = {},
        fetchOptions = {},
    } = {}
) {
    method = method.toUpperCase(); // eslint-disable-line
    invariant(
        ['GET', 'PUT', 'POST', 'DELETE', 'PATCH'].includes(method),
        `Invalid method '${method}' specified to callApi`
    );
    const apiConfig = getApiConfigFor(endpoint);
    if (!isAbsUrl(endpoint)) {
        endpoint = buildApiUrl(endpoint); // eslint-disable-line
    }
    if (requestType === API_CALL_REQUEST) {
        requestType = {
            // eslint-disable-line
            type: requestType,
            meta: {
                endpoint,
                method,
                data,
            },
        };
    }
    const finalTypes = [requestType, successType, failureType];
    finalTypes.forEach(reqType => {
        invariant(
            reqType && ((typeof reqType == 'object' && reqType.type) || typeof reqType == 'string'),
            `Invalid request type provided for callApi('${endpoint}', '${method}', ...) must ` +
                "either be a string or an object with a 'type' property set"
        );
    });
    const finalHeaders = buildHeaders(apiConfig, headers);
    let finalData = null;
    if (data instanceof FormData) {
        finalData = data;
        delete finalHeaders['Content-Type'];
    } else if (data) {
        // If we have received any files convert our data to a FormData instance
        // with a key 'formData' that contains our stringified non-File data with
        // placeholder values for each file upload (eg. ____ATTACHED_FILE_ID_1 etc)
        // Add a matching form key to the actual file data for every file field found
        // On the backend this is handled transparently and converts it back to the
        // nested JSON structure with each placeholder value replaced with actual
        // file contents (eg. in django an InMemoryUploadedFile)
        // This special case is identified by the header X-RADCOMBINEDFORMPOST
        let fileCount = 0;
        const files = {};
        const replacer = (key, value) => {
            if (value instanceof File) {
                const id = `____ATTACHED_FILE_ID_${fileCount++}`;
                files[id] = value;
                return id;
            }
            return value;
        };
        const stringifiedData = JSON.stringify(data, replacer);
        if (fileCount > 0) {
            delete finalHeaders['Content-Type'];
            finalData = new FormData();
            finalData.append('formData', stringifiedData);
            Object.keys(files).forEach(fileKey => finalData.append(fileKey, files[fileKey]));
            finalHeaders['X-RADCombinedFormPost'] = true;
        } else {
            finalData = stringifiedData;
        }
    }
    return dispatch =>
        dispatch({
            [CALL_API]: {
                endpoint,
                method,
                body: finalData,
                types: finalTypes,
                credentials: apiConfig.credentials,
                headers: finalHeaders,
                options: fetchOptions,
            },
        }).then(response => {
            // For calls to our API invalidate auth if we get a 401 (unless config says not to)
            if (!apiConfig.bypassAuthRetry && response.error && response.payload.status === 401) {
                // If we get a 401 handle it such that a login form can be displayed
                // and then the API call retried.
                let deferred;
                // Create a promise that we return instead to defer handling of
                // the result of the API call. This means that the caller will
                // NEVER see a 401 - the promise it will be dealing with will
                // be unresolved until they log in. This allows any UI dependencies
                // on the state of the promise to work until the login has finished.
                // It does mean UI must allow for a pending API call while  login
                // form is displayed (eg. displayed a full screen loading message
                // which obscures the login form would be bad)
                const p = new Promise((resolve, reject) => {
                    deferred = { resolve, reject };
                });
                dispatch({
                    type: API_CALL_AUTH_REQUIRED,
                    // Payload is a function that de-dispatches the API call
                    // and resolves the promise we created above.
                    payload: dispatch => {
                        return dispatch(callApi(...arguments)).then(
                            deferred.resolve,
                            deferred.reject
                        );
                    },
                    meta: {
                        requestTypes: {
                            requestType,
                            successType,
                            failureType,
                        },
                    },
                });
                return p;
            }
            return response;
        });
}

const apiCallInProgressByEndpoint = {};

/**
 * Django rest framework filters in query parameters require booleans be
 * either True or False
 */
function convertDjangoQueryParam(value) {
    if (value === true) return 'True';
    if (value === false) return 'False';
    return value;
}

function buildEndpointWithQueryParams(endpoint, params, apiConfig) {
    invariant(
        endpoint.indexOf('?') === -1,
        `Call to API method provided endpoint of ${endpoint} which contains a '?'. Pass ` +
            'any query parameters through as an object to the second parameter'
    );
    endpoint = trim(endpoint, '/');
    if (apiConfig.appendSlash) {
        endpoint += '/';
    }
    return [
        endpoint,
        // Convert query params into form expected by django-rest-framework
        // but only if we aren't dealing with absolute URL
        toQueryString(params, isAbsUrl(endpoint) ? identity : convertDjangoQueryParam),
    ].join('?');
}

/**
 * For GET's don't fire same request multiple times
 */
export function get(endpoint, getParams = {}, config = {}) {
    invariant(
        endpoint.indexOf('?') === -1,
        `Call to get provided endpoint of ${endpoint} which contains a '?'. Pass ` +
            'any query parameters through as an object to the second parameter'
    );
    const apiConfig = getApiConfigFor(endpoint);
    const finalEndpoint = buildEndpointWithQueryParams(endpoint, getParams, apiConfig);
    return dispatch => {
        let cacheKey = finalEndpoint;
        if (config.headers && Object.keys(config.headers).length > 0) {
            const headersList = Object.keys(config.headers).map(
                header => `${header}=${config.headers[header]}`
            );
            headersList.sort((a, b) => {
                if (a < b) return -1;
                if (a > b) return 1;
                return 0;
            });
            cacheKey += headersList.join(',');
        }
        if (apiCallInProgressByEndpoint[cacheKey]) {
            return apiCallInProgressByEndpoint[cacheKey];
        }
        apiCallInProgressByEndpoint[cacheKey] = dispatch(
            callApi(finalEndpoint, 'get', null, config)
        );
        return apiCallInProgressByEndpoint[cacheKey].then(
            result => {
                delete apiCallInProgressByEndpoint[cacheKey];
                return result;
            },
            e => {
                delete apiCallInProgressByEndpoint[cacheKey];
                throw e;
            }
        );
    };
}

export function post(endpoint, data = {}, config = {}) {
    return callApi(endpoint, 'post', data, config);
}

export function patch(endpoint, data = {}, config = {}) {
    return callApi(endpoint, 'patch', data, config);
}

export function del(endpoint, queryParams = {}, config = {}) {
    const apiConfig = getApiConfigFor(endpoint);
    const finalEndpoint = buildEndpointWithQueryParams(endpoint, queryParams, apiConfig);
    return callApi(finalEndpoint, 'delete', null, config);
}
