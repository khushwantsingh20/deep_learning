// @flow
import { isModelInstance } from '../model/Model';
import type { Model } from '../model/Model';
import type { ModelId } from '../model/types';
import Site from '../site/Site';
import type { Store } from '../types/store';
import { isDev } from '../util/log';
import { getModelPermissions } from '../actions';
import { selectors } from '../site/reducers';

export type ActionPermission =
    | { action: string, record: Model }
    | { action: string, model: Class<Model> | ModelId, id: string | number };
export type ModelPermission = { perm: string | Array<string>, model: Class<Model> | ModelId };
export type RecordPermission = { perm: string | Array<string>, record: Model };
export type PermissionDescriptor =
    | Array<string>
    | string
    | ActionPermission
    | ModelPermission
    | RecordPermission;

/**
 * Class responsible for checking permissions for a user. You can provide a custom class by extending
 * this and setting it on your site using [setPermissionCheckerClass](/api/js/site/#Site-setPermissionCheckerClass).
 */
export default class PermissionChecker {
    // Permissions are stored in redux to make it easy to integrate with existing data fetching
    // for models. This way the permissions for a record can be returned with regular fetches
    // and just be written to redux using a regular reducer. The permission checker can extract
    // them from redux as required.
    store: Store;
    site: Site;

    constructor(store: Store, site: Site) {
        this.store = store;
        this.site = site;
    }

    /**
     * Get the current resolved permissions for an object
     * @param model The model class to check
     * @param id The id of the record to check
     */
    getUserObjectPermissions(model: Class<Model>, id: number | string) {
        return selectors.entityPermissions(this.store.getState()).getIn([model._meta.modelId, id]);
    }

    /**
     * Get the current known global permissions
     */
    getGlobalPermissions() {
        return selectors.globalPermissions(this.store.getState());
    }

    /**
     * Check if a user has the specified permission. Resolves any async permission
     * by performing an API call.
     *
     * All permission checks are async but most will resolve immediately without any API call
     * as determined by which permissions are marked async on the backend.
     *
     * @param perm the permission to check
     * @param object The object to check permissions for. If false the permission check is against global permissions.
     * Either a model instance or a model class is accepted. If model class is provided then `id` must also be provided.
     * @param id only used if `object` is a model class. the id of the model to retrieve permissions for.
     */
    async hasPerm(
        perm: string,
        object?: ?Model | ?Class<Model>,
        id?: number | string
    ): Promise<boolean> {
        let model: ?Class<Model>;
        if (object) {
            if (isModelInstance(object)) {
                model = object.constructor;
                id = object.id;
            } else {
                model = object;
            }
        }
        let hasPerm;
        if (object) {
            let objectPermissions = this.getUserObjectPermissions(model, id);
            if (!objectPermissions) {
                // Permissions for this object haven't been fetched - in the current implementation
                // this means the record hasn't been fetched as permissions are returned as part
                // of the record response.
                // This typically will happen when using an id (eg. on RelatedModelFormatter) and
                // has the potential to cause lots of queries (eg. if you use it on a list view)
                // A better solution for this may be required, eg. some kind of batching of calls.
                // See https://manage.alliancesoftware.com.au/kanban/board/93/card/5052/summary
                await this.store.dispatch(getModelPermissions(model, id));
                objectPermissions = this.getUserObjectPermissions(model, id);
            }
            if (!objectPermissions) {
                hasPerm = false;
            } else {
                hasPerm = objectPermissions.get(perm);
            }
        } else {
            hasPerm = this.getGlobalPermissions().get(perm);
        }
        if (hasPerm === undefined) {
            // DOC_TODO: It would be nice to just give a link to the documentation on how to manage perms here.
            if (isDev()) {
                if (model) {
                    throw new Error(
                        `Unknown model permission '${perm}' specified. Check it is spelled correctly and is specified on the backend. If this is a global permission ensure 'model' isn't being passed.`
                    );
                }
                throw new Error(
                    `Unknown global permission '${perm}' specified. Check it is spelled correctly and is specified on the backend. If this is a model permission ensure 'model' and 'id' are being passed.`
                );
            }
            return false;
        }
        if (hasPerm === null) {
            if (!object) {
                throw new Error('async global permission checks not currently supported');
            }
            try {
                // Async object permissions are just resolved by fetching the record. We may need
                // to do this even when we have a record if that record is not complete (it was
                // retrieve by specifying 'partialRecordFieldNames'). In the case of a partial record
                // only the non-async permissions are returned and any async permissions need to
                // be retrieved by fetching the full record. In the future this mechanism may change
                // eg. having a dedicate permission resolve endpoint.
                await this.store.dispatch(getModelPermissions(model, id));
                return this.getUserObjectPermissions(model, id).get(perm);
            } catch (error) {
                // TODO: What should we do here? Handle specific codes? Log something?
                console.warn('Failed to fetch permissions for record', object, perm, error); // eslint-disable-line
                return false;
            }
        }
        return hasPerm;
    }

    /**
     * Check if user has all specified permissions
     *
     * @param perms Array of permissions to check
     * @param object Optional model or model instance to check permission against. If model class is provided you must
     * provide the third `id` parameter. This is handy if you have the id of a model but not an actual instance.
     * @param id Optional id to check. If you specify this you must provide the model class in the second parameter.
     */
    async hasPerms(
        perms: Array<string>,
        object?: ?Model | Class<Model>,
        id?: string | number
    ): Promise<boolean> {
        const resolvedPerms = await Promise.all(perms.map(perm => this.hasPerm(perm, object, id)));
        return resolvedPerms.filter(Boolean).length === perms.length;
    }

    /**
     * Accept a description of a permission where this is one of:
     * - A permission string, eg. my_app.user_list
     * - A list of permission strings, eg. ['my_app.user_list', 'my_app.userprofile_list'] (user must have _all_ perms for success)
     * - An object for an action permission { action: 'detail', record: user } or { action: 'list', model: User }
     * - An object for a record permission { perm: 'my_app.user_detail', record: user } or { perm: 'my_app.user_list', model: user }
     *   - This is the equivalent of checking the action perm; actions just translate from a name (eg. list) to the
     *     underlying permission (my_app.user_list)
     * @returns Promise resolving to true or false based on current users access
     **/
    async check(permOrObj: PermissionDescriptor): Promise<boolean> {
        if (Array.isArray(permOrObj) || typeof permOrObj == 'string') {
            let perm = permOrObj;
            if (!Array.isArray(perm)) {
                perm = [perm];
            }
            return this.hasPerms(perm);
        } else if (permOrObj && typeof permOrObj == 'object') {
            const { record, model, id, action } = permOrObj;
            let { perm } = permOrObj;
            const modelClass = (model || record) && this.site.getModelClass(model || record);
            if (action) {
                if (!modelClass) {
                    throw new Error('One of model or record is required when using action');
                }
                perm = modelClass._meta.getActionPermissions(action);
            }
            if (!Array.isArray(perm)) {
                perm = [perm];
            }
            if (record) {
                return this.hasPerms(perm, record);
            } else if (modelClass && id) {
                return this.hasPerms(perm, modelClass, id);
            }
            return this.hasPerms(perm);
        }
        throw new Error('Invalid permission descriptor', permOrObj);
    }
}
