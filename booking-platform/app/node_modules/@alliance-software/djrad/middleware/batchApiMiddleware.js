// @flow
import { RequestError, RSAA } from 'redux-api-middleware';
import { normalizeTypeDescriptors, actionWith } from 'redux-api-middleware/lib/util';
import { buildHeaders, getApiConfigFor } from 'alliance-redux-api/lib/api';
import Site from '../site/Site';
import type { Action } from '../types/action';
import type { GetState } from '../types/store';

type ApiAction = {
    endpoint: string,
    body: any,
    headers: any,
    method: string,
};

type BatchedApiAction = {
    resolve: (response: Response) => void,
    reject: (responseOrError: Response | Error) => void,
    action: ApiAction,
};

/**
 * The batch API class for a specific djrad site.
 *
 * The queue is cleared the next frame after an action is enqueued.
 */
class BatchApi {
    isPending: boolean;
    queue: Array<BatchedApiAction>;
    site: Site;

    constructor(site: Site) {
        this.isPending = false;
        this.queue = [];
        this.site = site;
    }

    /**
     * Clear the queue. This fires an API call to the backend and resolves all actions in the queue.
     * @returns {Promise<void>}
     */
    clearQueue = async () => {
        this.isPending = false;
        const queue = this.queue;
        this.queue = [];
        const apiConfig = getApiConfigFor(this.site.getBaseApiUrl());
        const payload = queue.map(({ action }) => {
            const { endpoint, body, headers = {}, method } = action;
            return { endpoint, body, headers: Object.entries(headers), method };
        });
        const headers = buildHeaders(apiConfig);
        try {
            const response = await fetch(`${this.site.getBaseApiUrl()}batch-api/`, {
                method: 'post',
                body: JSON.stringify(payload),
                credentials: apiConfig.credentials,
                headers,
            });
            if (response.ok) {
                const results = await response.json();
                queue.forEach(({ resolve, reject }, i) => {
                    // The response for each batched call should be returned in order they
                    // were sent. The backend needs to guarantee this.
                    const subResponseDescriptor = results[i];
                    const { status, statusText, content } = subResponseDescriptor;
                    const subResponseHeaders = new Headers();
                    subResponseDescriptor.headers.forEach(([key, value]) =>
                        subResponseHeaders.append(key, value)
                    );
                    const subResponse = new Response(content, {
                        status,
                        statusText,
                        headers: subResponseHeaders,
                    });
                    if (subResponse.ok) {
                        resolve(subResponse);
                    } else {
                        reject(subResponse);
                    }
                });
                return;
            }
            // This is unexpected - the actual batch endpoint itself failed
            queue.forEach(({ reject }) => {
                reject(
                    new Response('Batch call failed', {
                        status: response.status,
                    })
                );
            });
        } catch (err) {
            queue.forEach(({ reject }) => {
                reject(new RequestError(err.message));
            });
        }
    };

    /**
     * Enqueue an action to be batched
     * @param action ApiAction Any API action
     * @returns {Promise<any>} Resolves when the batch this action is added to has been cleared.
     */
    enqueueAction = (action: ApiAction) =>
        new Promise((resolve, reject) => {
            this.queue.push({ action, resolve, reject });
            if (!this.isPending) {
                this.isPending = true;
                requestAnimationFrame(() => {
                    this.clearQueue();
                });
            }
        });
}

/**
 * RSAA is the identifier from redux-api-middleware for an API action. eg. it's shape is
 * {
 * //    [RSAA]: {
 * //       types: [REQUEST_TYPE, SUCCESS_TYPE, FAILURE_TYPE],
 * //       ...
 * //    }
 * // }
 * Where REQUEST_TYPE, SUCCESS_TYPE and FAILURE_TYPE are either strings or objects describing
 * the action to dispatch for each part of the request (where REQUEST_TYPE is dispatched at
 * the start for all calls followed by either SUCCESS_TYPE or FAILURE_TYPE depending on response)
 * Actions can flag themselves as being a batch API call by setting the `batchCall` property
 * on the REQUEST_TYPE meta object.
 *
 * @param action Any redux action
 * @returns {boolean}
 */
function isBatchCallAction(action: Action) {
    return (
        action[RSAA] &&
        typeof action[RSAA].types[0] == 'object' &&
        action[RSAA].types[0].meta.batchCall
    );
}

/**
 * Create API middleware that will look at all API actions as inspect the requestType for a meta property
 * batchCall. If true the call will be batched.
 *
 * Batches are dispatched on the next frame with the typical use case being that a page that renders (eg.
 * a list view) that triggers multiple requests within it could have all the requests batched into a single
 * API call.
 *
 * Batching is opt in with permissions & related lookups being the only actions that opt into it
 * by default.
 *
 * **WARNING**: On the backend you a subject to some limitations. See [BatchApiViewSet](/api/viewsets/#djrad_rest.viewsets.BatchApiViewSet) header comments.
 *
 * @param site Site djrad site this middleware is for.
 * @returns {function({getState?: *}): function(*=): Function}
 */
export default function batchApiMiddleware(site: Site) {
    const batchApi = new BatchApi(site);
    return ({ getState }: { getState: GetState }) => (next: Action => void) => async (
        action: Action
    ) => {
        if (!isBatchCallAction(action)) {
            return next(action);
        }
        if (!action[RSAA].endpoint.toLowerCase().startsWith(site.baseUrl.toLowerCase())) {
            // eslint-disable-next-line
            console.warn(
                `Can only batch API calls to ${site.baseUrl}. Received: ${
                    action[RSAA].endpoint
                }. Action has been dispatched normally`
            );
            return next(action);
        }
        // We now need to duplicate some behaviour from the core middleware:
        // https://github.com/agraboso/redux-api-middleware/blob/v2.3.0/src/middleware.js
        // These are now guaranteed to be objects
        const [requestType, successType, failureType] = normalizeTypeDescriptors(
            action[RSAA].types
        );
        // Restrict the scope of this to only plain objects. The API middleware accepts the following
        // props as functions as well which it would resolve now and throw an error on failure. This
        // necessitates duplicating a lot of logic from the core middleware which I want to avoid. For
        // our use case I don't think this is going to be a problem.
        const errors = [];
        for (const prop of ['endpoint', 'body', 'headers', 'options']) {
            if (typeof action[RSAA][prop] == 'function') {
                errors.push(`Only simple API actions are supported: ${prop} cannot be a function`);
            }
        }
        if (errors.length) {
            throw new Error(errors.join('\n'));
        }

        // For all batched actions we immediately fire the request type action
        if (typeof requestType.payload === 'function' || typeof requestType.meta === 'function') {
            next(await actionWith(requestType, [action, getState()]));
        } else {
            next(requestType);
        }

        // Instead of doing the fetch now we return a promise that will resolve once the batch has
        // been processed. Note that this always should resolve - failures are resolved but with
        // a failureType rather than successType.
        return new Promise(async resolve => {
            try {
                const response = await batchApi.enqueueAction(action[RSAA]);
                resolve(next(await actionWith(successType, [action, getState(), response])));
            } catch (response) {
                if (response instanceof Response) {
                    resolve(
                        next(
                            await actionWith({ ...failureType, error: true }, [
                                action,
                                getState(),
                                response,
                            ])
                        )
                    );
                } else {
                    // Non-response objects are handled differently - just gets passed
                    // through on payload. This is used for RequestError.
                    resolve(
                        next(
                            await actionWith({ ...failureType, payload: response, error: true }, [
                                action,
                                getState(),
                            ])
                        )
                    );
                }
            }
        });
    };
}
