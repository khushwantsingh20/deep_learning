// @flow
import * as Immutable from 'immutable';
import { Record, Any, Maybe, Map as TypedMap, Typed } from 'typed-immutable';
import isPlainObject from 'lodash/isPlainObject';
import { actionTypes } from 'alliance-redux-api/lib/actions';
import { GET_MODEL_PERMISSIONS } from '../actions/actionTypes';
import type { Action } from '../types/action';
import type { DjradSiteContext } from './Site';

export const NumberToString = Typed('NumberToString', value => {
    if (typeof value == 'object') {
        return value;
    }
    return String(value);
});

export const PermissionMap = TypedMap(String, Maybe(Boolean));
class PermissionsMap extends TypedMap(NumberToString, PermissionMap, 'EntityPermissionsStateMap') {
    get(keyData) {
        // This makes up for shortcoming in typed-immutable; doesn't properly
        // apply type when you read via key from the map. In the case of permissions
        // we force scalars to be a string so that primary keys of either
        // string or numbers work without having to properly cast it each time.
        return super.get(this[Typed.type].key[Typed.read](keyData));
    }
}
const EntityPermissionsStateMap = TypedMap(String, PermissionsMap);
const DjradState = Record({
    // This is managed by alliance-redux-api - see App.js buildReducer
    Entities: Any,
    // This is a central store for all model/entity permissions. Whenever a fetch or update occurs
    // this state tree is updated with the returned permissions for each record.
    EntityPermissions: EntityPermissionsStateMap(),
    GlobalPermissions: PermissionMap(),
});

type ModelState = typeof DjradState;

const selectorPrematureMessage =
    'You tried to use a selector before the selectors were created. You must wait until after djrad has initialized before using this selector.';

// Selectors into redux state. Only initialized after buildSelectors called as we need to know where the djrad
// state tree is mounted.
export const selectors = {
    entityPermissions() {
        throw new Error(selectorPrematureMessage);
    },
    globalPermissions() {
        throw new Error(selectorPrematureMessage);
    },
    entities() {
        throw new Error(selectorPrematureMessage);
    },
};

function buildSelectors(reduxRootStateKey: string) {
    selectors.entityPermissions = state => state[reduxRootStateKey].EntityPermissions;
    selectors.globalPermissions = state => state[reduxRootStateKey].GlobalPermissions;
    selectors.entities = state => state[reduxRootStateKey].Entities;
}

export default function buildDjradReducer(
    initialState: Object,
    reduxRootStateKey: string,
    setGlobalContext: (ModelState, DjradSiteContext) => ModelState
) {
    buildSelectors(reduxRootStateKey);
    function djradReducer(
        state: ModelState = DjradState(initialState),
        action: Action
    ): ModelState {
        // eslint-disable-line
        // If state has been specified as a plain object first convert it to immutable
        if (isPlainObject(state)) {
            state = DjradState(state);
        }

        // If the key 'djradContext' is available on the payload, then use it to update the global context
        const { payload } = action;
        if (payload && payload.djradContext) {
            state = setGlobalContext(state, payload.djradContext);
        }

        switch (action.type) {
            case GET_MODEL_PERMISSIONS: {
                if (action.error) {
                    return state;
                }
                // Payload is object with model ID => array of records
                const data = Object.keys(action.payload).reduce((acc, modelId) => {
                    const records = action.payload[modelId];
                    acc[modelId] = records.reduce((byId, record) => {
                        byId[record.id] = record._permissions;
                        return byId;
                    }, {});
                    return acc;
                }, {});
                return state.mergeIn(['EntityPermissions'], data);
            }
            case actionTypes.customDetail:
            case actionTypes.customList:
            case actionTypes.add:
            case actionTypes.update:
            case actionTypes.fetch: {
                // If available this will be a structure like:
                // {
                //    demo.country: {
                //       5: { ..., _permissions: [['demo.detail_country', true], ['demo.update_country', false]] },
                //    },
                //    demo.continent: {
                //        ....
                //    }
                // }
                // Where demo.country & demo.continent are the model id's and the indices are record ids.
                const allEntities = action.payload.entities || {};
                let nextState = state;
                Object.keys(allEntities).forEach(stateKey => {
                    const entities = Object.assign({}, allEntities[stateKey]);
                    const permissionsByEntity = Immutable.Map(entities)
                        .map(record => record._permissions)
                        .filter(Boolean);
                    nextState = nextState.mergeIn(
                        ['EntityPermissions', stateKey],
                        permissionsByEntity
                    );
                });
                return nextState;
            }
            default:
                return state;
        }
    }

    return djradReducer;
}

// TODO: Placeholder for now
export type Reducers = {
    djrad: {
        Entities: any,
    },
};
