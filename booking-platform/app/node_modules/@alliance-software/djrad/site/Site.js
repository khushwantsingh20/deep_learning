// @flow
import createModelsReducer from 'alliance-redux-api/lib/createModelsReducer';
import reduceReducers from 'alliance-redux-api/lib/reduceReducers';
import { $modelDefinition } from 'alliance-redux-api/lib/Model';
import type { ModelRecord as ReduxApiModelRecord } from 'alliance-redux-api/lib/flowTypes';
import trim from 'lodash/trim';
import oneLine from 'common-tags/lib/oneLine';
import stripIndent from 'common-tags/lib/stripIndent';
import invariant from 'invariant';
import buildMiddleware from '../middleware';
import PermissionChecker from '../permissions/PermissionChecker';
import type { Store } from '../types/store';
import FieldFactory from '../model/factory/FieldFactory';
import StorageTypeFactory from '../model/factory/StorageTypeFactory';
import buildModel, { isModelClass, isModelInstance } from '../model/Model';
import type { ModelConfigurationOptions, Model } from '../model/Model';
import type { ModelId, ModelDefinition } from '../model/types';
import ModelComponentFactory from '../model/ModelComponentFactory';
import DeferredInitModel, { $isModelRegistered } from '../model/DeferredInitModel';

import AppApi from './AppApi';
import buildDjradReducer from './reducers';

import type { ApiConfig } from '../api';

export type SiteConfigDescriptor = {
    siteId: string,
    constants: {
        baseApiUrl: string,
    },
    modelRegistrationOrder: Array<ModelId>,
    models: { [ModelId]: ModelDefinition },
};

invariant(
    window.__RAD__,
    stripIndent`
    The global __RAD__ variable does not exist. During development check that your template includes:

        <script src="{% url 'rad_model_data' %}" ></script>
    
    And that it has successfully loaded.

    For production check that your deployment calls collectstatic_djrad and your template includes the generated files in your template?
`
);

const globalSiteRegistry = window.__RAD__.apps;

export type DjradSiteContext = {
    // The global permissions the current user has
    globalPermissions: {
        [string]: ?boolean,
    },
    // Optionally can also specify upfront the specify entity permissions
    entityPermissions: ?{
        [ModelId]: {
            [id: string | number]: ?boolean,
        },
    },
};

/**
 * Copy properties from one class to another. Does not traverse prototype hierarchy.
 *
 * @param target Class to copy properties to
 * @param cls Class to copy properties from
 * @returns {*}
 */
function copyClassProperties(target, cls) {
    const descriptors = Object.getOwnPropertyDescriptors(cls.prototype);
    const staticDescriptors = Object.getOwnPropertyDescriptors(cls);
    Object.entries(descriptors).forEach(([name, desc]) => {
        if (['constructor', 'name', 'length'].includes(name) || target.hasOwnProperty(name)) {
            return;
        }
        Object.defineProperty(target.prototype, name, desc);
    });
    Object.entries(staticDescriptors).forEach(([name, desc]) => {
        if (['prototype', 'name', 'length'].includes(name) || target.hasOwnProperty(name)) {
            return;
        }
        Object.defineProperty(target, name, desc);
    });
    return target;
}

/**
 * Patch a Model class such that it extends the generated typed immutable class.
 *
 * The class hierarchy is traversed and all properties from each class is copied to the
 * final class. The final class hierarchy only include `modelClass` - anything else that
 * was originally there is now gone. This sucks but could not get it to work by patching
 * the prototype on the recordClass instead which would have been ideal. The problem seems
 * to be in typed-immutable.
 *
 * Note that this means that instanceof checks will not work for any of the classes in the prototype
 * hierarchy as they are no longer there.
 *
 * @param recordClass The class created by buildModel
 * @param modelClass The model class to use. Should extend or be DeferredInitModel.
 * @param isBaseClass True if this modelClass is the base model class in the system. By default
 * this is DeferredInitModel but can be customised.
 * @returns {*}
 *
 * @private
 */
export function setModelBaseClass(recordClass, modelClass) {
    let cls = modelClass;
    // For each class in the hierarchy copy properties to the record class
    while (Object.getPrototypeOf(cls) !== Function.prototype) {
        cls = Object.getPrototypeOf(cls);
        copyClassProperties(recordClass, cls);
    }
    // Hook up the instance properties
    Object.setPrototypeOf(modelClass.prototype, recordClass.prototype);
    // Hook up the static properties
    Object.setPrototypeOf(modelClass, recordClass);
    return modelClass;
}

/**
 * Every site you define on the backend has a corresponding site on the frontend. This is where
 * the all model classes are configured, the redux store is setup and the API is configured.
 *
 * Usage:
 *
 * ```
 * const apiConfig = {
 *     headers: {
 *       'X-Requested-With': 'XMLHttpRequest',
 *     }
 * }
 * export const defaultSite = new Site(
 *     window.__APP_CONTEXT__.baseUrl,
 *     'default',
 *     apiConfig,
 *     window.__APP_CONTEXT__.djradContext
 * );
 * ```
 *
 * The values in `__APP_CONTEXT__` are included in your django view and then embedded directly in
 * the template. For example the django view may have something like:
 *
 * $python$: django_site.views # djrad: app_context
 *
 * And then in the corresponding template:
 *
 * ```html
 * <script>
 *   window.__APP_CONTEXT__ = {{ app_context|escapejson }}
 * </script>
 * ```
 *
 * In the example above `'default'` is the name of the backend Site. If you have created a custom
 * site you will have given it a name and it should match that. For example with a backend site
 * created as:
 *
 * ```python
 * admin_site = RestSite('admin');
 * ```
 *
 * The corresponding frontend site would be:
 *
 * ```
 * export const adminSite = new Site(
 *     window.__APP_CONTEXT__.baseUrl,
 *     'admin',
 *     null,
 *     window.__APP_CONTEXT__.djradContext
 * );
 * ```
 *
 * The third parameter is the API configuration object which you can supply to customise things
 * like the default headers to pass through. See below for the possible options.
 *
 * To get access to the site in your components use the [useSite](/api/hooks/#useSite) hook.
 *
 * You can use `injectSite` if you are using class components:
 *
 * ```js
 * import injectSite from '@alliance-software/djrad/site/injectSite';
 *
 * class MyComponent extends React.Component {
 *     render() {
 *         const { djradSite } = this.props;
 *         ...
 *     }
 * }
 * export default injectSite(MyComponent);
 * ```
 *
 * > **NOTE**: Once you define your site you can then register custom model classes by calling
 * > configureModel(). It is recommended that you _don't_ import it in components. The chances
 * > are you do not need it and if you really really do use `injectSite` instead.
 */
export default class Site {
    fieldFactoryClass: Class<FieldFactory>;
    storageTypeFactoryClass: Class<StorageTypeFactory>;
    baseModelClass: Class<DeferredInitModel>;
    permissionCheckerClass: Class<PermissionChecker>;
    permissionChecker: PermissionChecker;
    siteId: string;
    config: SiteConfigDescriptor;
    models: Map<ModelId, Class<Model>>;
    modelDefinitions: { [ModelId]: ModelDefinition };
    modelConfigurations: Map<ModelId, ModelConfigurationOptions> = new Map();
    api: AppApi;
    baseUrl: string;
    apiConfig: ApiConfig;
    reduxStateKey: string;
    djradContext: DjradSiteContext;
    _reducerAdded: boolean = false;

    /**
     * @param baseUrl The base URL to use for all API calls.
     * @param siteId The unique id of the site. This should match what you use on the backend as described above.
     * @param apiConfig The custom API config, if any. Set to null to ignore.
     * @param djradContext The djrad context. This should be generated on the backend by calling `site.get_runtime_context(request)`
     * as described above.
     */
    constructor(
        baseUrl: string,
        siteId: string,
        apiConfig: ApiConfig,
        djradContext: DjradSiteContext
    ) {
        invariant(
            djradContext,
            'Since version 0.2.0 you must provide the djradContext parameter to site'
        );
        const config = globalSiteRegistry[siteId];
        if (!config) {
            throw new Error(oneLine`
                Unknown site '${siteId}' specified. Check that this matches the site
                name in django. Known site ids: ${Object.keys(globalSiteRegistry).join(', ')}
            `);
        }
        this.djradContext = djradContext;
        this.siteId = config.siteId;
        this.config = config;
        this.modelDefinitions = config.models;
        this.models = new Map();
        this.baseUrl = baseUrl;
        this.apiConfig = apiConfig;
        this.fieldFactoryClass = FieldFactory;
        this.storageTypeFactoryClass = StorageTypeFactory;
        this.permissionCheckerClass = PermissionChecker;
        this.baseModelClass = DeferredInitModel;
    }

    /**
     * Set the factory class used to create Fields for models. If you want to provide custom
     * fields or override the defaults you should provide one of these. See the [FieldFactory](/api/js/FieldFactory/)
     * docs for more.
     *
     * @param fieldFactoryClass The class to use. Must extend `FieldFactory`. This should be
     * the class itself and not an instance.
     */
    setFieldFactoryClass(fieldFactoryClass: Class<FieldFactory>) {
        if (!(fieldFactoryClass.prototype instanceof FieldFactory)) {
            throw new Error('Class passed to setFieldFactoryClass must extend FieldFactory');
        }
        this.fieldFactoryClass = fieldFactoryClass;
    }

    /**
     * Set the factory class used to create typed-immutable types for models based on the StorageType specification
     * provided by backend model registrations. You most likely don't need to customise this.
     * See the [StorageTypeFactory](/api/js/StorageTypeFactory/) docs for more details.
     *
     * @param fieldFactoryClass The class to use. Must extend `StorageTypeFactory`. This should be
     * the class itself and not an instance.
     */
    setStorageTypeFactoryClass(storageTypeFactoryClass: Class<StorageTypeFactory>) {
        if (!(storageTypeFactoryClass.prototype instanceof StorageTypeFactory)) {
            throw new Error(
                'Class passed to setStorageTypeFactoryClass must extend StorageTypeFactory'
            );
        }
        this.storageTypeFactoryClass = storageTypeFactoryClass;
    }

    /**
     * Set the class to use as the base for all models in the system. This class will be used for
     * any models djrad automatically creates for you. Any model classes you provide via
     * `configureModel` MUST extend the base class set here. If not provided models will extend
     * [DeferredInitModel](/api/js/DeferredInitModel) by default.
     *
     * @param baseModelClass The class to use. Must extend [DeferredInitModel](/api/js/model/#DeferredInitModel).
     */
    setBaseModelClass(baseModelClass: Class<DeferredInitModel>) {
        if (!(baseModelClass.prototype instanceof DeferredInitModel)) {
            throw new Error('Class passed to setBaseModelClass must extend DeferredInitModel');
        }
        this.baseModelClass = baseModelClass;
    }

    /**
     * Set the class to use to do permission checks.
     * @param permissionCheckerClass The class to use. Must extend [PermissionChecker](/api/js/permissions/#PermissionChecker)
     */
    setPermissionCheckerClass(permissionCheckerClass: Class<PermissionChecker>) {
        if (!(permissionCheckerClass.prototype instanceof PermissionChecker)) {
            throw new Error(
                'Class passed to setPermissionCheckerClass must extend PermissionChecker'
            );
        }
        this.permissionCheckerClass = permissionCheckerClass;
    }

    configureModel(modelId: ModelId, options: ModelConfigurationOptions) {
        if (this.reducerBuilt) {
            // Hint that the model is being imported before initialization but after djrad reducer has been
            // built so it likely just needs to move before the main reducer import.
            throw new Error(oneLine`
                Model ${modelId} configured after djrad reducer built. This probably
                means that the file this model is defined in was imported after your main reducer file. On standard
                projects this means the import should appear in your entry point before the line:
                import configureStore from './core/configureStore';
            `);
        }
        const modelDefinition = this.modelDefinitions[modelId];
        if (!modelDefinition) {
            throw new Error(
                `No such model definition found for '${modelId}'. Has the model been registered in the backend and does the id match? You can inspect window.__RAD__.apps['${
                    this.siteId
                }'].models to see what has been generated from django.`
            );
        }
        if (this.modelConfigurations.has(modelId)) {
            throw new Error(
                `configureModel called multiple times for model ${modelId}. Search for "configureModel('${modelId}" and consolidate into a single call.`
            );
        }
        const validKeys = [
            'componentFactory',
            'modelClass',
            'buildSelectors',
            'cache',
            'sortBy',
            'liveUpdateModel',
            'liveUpdateListener',
            'createModelReducer',
        ];
        const invalidKeys = Object.keys(options).filter(key => !validKeys.includes(key));
        if (invalidKeys.length > 0) {
            throw new Error(
                `Invalid configuration options provided for model ${modelId}: ${invalidKeys.join(
                    ', '
                )}. Valid options are: ${validKeys.join(', ')}.`
            );
        }
        const { componentFactory, modelClass, buildSelectors, ...rest } = options;
        if (componentFactory && !(componentFactory.prototype instanceof ModelComponentFactory)) {
            throw new Error('componentFactory must extend ModelComponentFactory');
        }
        if (modelClass && !(modelClass.prototype instanceof this.baseModelClass)) {
            throw new Error(
                `Custom modelClass for ${modelId} must extend ${this.baseModelClass.name}`
            );
        }
        if (modelClass) {
            this.modelConfigurations.forEach((config, id) => {
                if (config.modelClass === modelClass) {
                    throw new Error(
                        `modelClass for each model must be unique. ${modelId} conflicts with ${id}`
                    );
                }
            });
        }
        if (modelClass) {
            modelClass[$isModelRegistered] = true;
        }
        this.modelConfigurations.set(modelId, {
            componentFactory: componentFactory || ModelComponentFactory,
            modelClass,
            buildSelectors,
            ...rest,
        });
    }

    getModelClass(modelId: ModelId | Class<Model> | Model) {
        if (typeof modelId == 'string') {
            const modelClass = this.models.get(modelId);
            if (!modelClass) {
                throw new Error(
                    `Unknown model '${modelId}'. Known model ids are: ${[
                        ...this.models.keys(),
                    ].join(', ')}`
                );
            }
            return modelClass;
        }
        // We have an instance of the model, return the class
        if (isModelInstance(modelId)) {
            return modelId.constructor;
        }

        if (isModelClass(modelId)) {
            return modelId;
        }

        throw new Error(
            `Unknown parameter supplied to getModelClass. It should be a model class, model instance or model id. Received: ${modelId}`
        );
    }

    siteInitialized = false;
    initialize(store: Store) {
        // TODO: This check should be added but requires updating a lot of tests
        // invariant(!this.siteInitialized, 'Site already initialized. initialize() should only be called once.');
        invariant(
            store && typeof store.getState == 'function',
            'initialize must be passed an instance of the redux store'
        );
        invariant(
            this.reduxStateKey,
            oneLine`
            The redux reducer for djrad has not been added. Make sure you are calling 
            app.buildReducer('djrad') when creating your redux store where 'app' is
            your app instance  and 'djrad' matches the redux state key.
        `
        );
        invariant(
            store.getState()[this.reduxStateKey],
            oneLine`
            The redux reducer for djrad looks like it has been added but is
            not available on the specified state key of '${this.reduxStateKey}'.
            Check the parameter passed to buildReducer matches the assigned
            state key in Redux.
        `
        );
        this.siteInitialized = true;
        this.permissionChecker = new this.permissionCheckerClass(store, this);
        this.models.forEach(model => {
            const fieldFactory = new this.fieldFactoryClass(model, this.models, this);
            model._meta.initialize(fieldFactory, this.permissionChecker);
            this._validateModelClass(model);
        });
        this.api = new AppApi(this.models, this.getBaseApiUrl(), store, this.apiConfig);
        this.store = store;

        store.dispatch({
            type: 'djrad/model init',
            payload: {
                modelClasses: [...this.models.values()],
            },
        });
    }

    /**
     * Get base URL for API calls. Includes trailing slash
     * @returns {string} eg. http://localhost/rad-api/
     */
    getBaseApiUrl() {
        return trim(this.baseUrl, '/') + '/' + trim(this.config.constants.baseApiUrl, '/') + '/';
    }

    /**
     * Build the necessary redux middleware for this site
     * @param loginActionType String the action dispatched on successful login. This is required for the auth middleware
     * - which will retry failed API calls on login - so it doesn't retry failed login attempts on successful login.
     * @returns {*}
     */
    buildReduxMiddleware(loginActionType: string) {
        return buildMiddleware(this, loginActionType);
    }

    _validateModelClass(modelClass: Class<DeferredInitModel>) {
        const urlPrefix = modelClass.getUrlPrefix();
        if (urlPrefix) {
            if (urlPrefix[0] !== '/' || urlPrefix[urlPrefix.length - 1] !== '/') {
                const { modelId } = modelClass._meta;
                const config = this.modelConfigurations.get(modelId) || {};
                let label;
                if (config.modelClass) {
                    label = config.modelClass.name;
                } else {
                    label = this.baseModelClass.name;
                }
                throw new Error(
                    `getUrlPrefix() must include leading and trailing slashes. Check implementation for class '${label}'.`
                );
            }
        }
    }

    reducerBuilt = false;

    /**
     * Build the redux reducer for this site
     * @param stateKey {String} the root key in the redux state under which the site state should sit
     * @param extraModelReducers {Array} An array of either ModelRecord classes from alliance-redux-api or
     * of reducer functions created with createModelReducer
     */
    buildReducer(stateKey: string, extraModelReducers: Array<ReduxApiModelRecord | Function> = []) {
        // TODO: This check should be added but requires updating a lot of tests
        // invariant(!this.reducerBuilt, 'buildReducer should called only once');
        this.reduxStateKey = stateKey;
        this.models = new Map();
        const storageTypeFactory = new this.storageTypeFactoryClass(this.models);
        for (const modelId of this.config.modelRegistrationOrder) {
            const definition = this.modelDefinitions[modelId];
            const options = this.modelConfigurations.get(modelId);
            const recordClass = buildModel(definition, storageTypeFactory, options);
            let { modelClass } = options || {};
            if (!modelClass) {
                // Generate a class so setModelBaseClass can safely patch it
                modelClass = class extends this.baseModelClass {};
            }
            const finalModelClass = setModelBaseClass(recordClass, modelClass);
            const partialRecordClass = setModelBaseClass(
                recordClass[$modelDefinition].partialRecordClass,
                class extends this.baseModelClass {}
            );
            copyClassProperties(partialRecordClass, modelClass);
            recordClass[$modelDefinition].partialRecordClass = partialRecordClass;
            this.models.set(modelId, finalModelClass);
        }
        this.reducerBuilt = true;
        const modelReducers = [...this.models.entries()].map(([modelId, model]) => {
            const options = this.modelConfigurations.get(modelId) || {};
            if (options.createModelReducer) {
                return options.createModelReducer(model);
            }
            return model;
        });
        return reduceReducers(
            buildDjradReducer(
                {
                    // These are the defaults for redux state for the djrad reducer
                    Entities: this.djradContext.entities,
                    GlobalPermissions: this.djradContext.globalPermissions,
                    EntityPermissions: this.djradContext.entityPermissions,
                },
                this.reduxStateKey,
                this.setGlobalContext
            ),
            [
                'Entities',
                createModelsReducer(
                    [...modelReducers, ...extraModelReducers],
                    [stateKey, 'Entities']
                ),
            ]
        );
    }

    /**
     * The global djrad redux state (which contains e.g. Entities, GlobalPermissions, etc) is initially
     * populated on page load via django template context. Some ajax actions may however require updating
     * this global context (e.g. permissions are not known until user logs in, which happens via ajax).
     *
     * To facilitate this, the global djrad redux state can also be updated as a side effect of ajax
     * requests (assuming they pass through redux) if the response contains the key 'djradContext'. The
     * djrad reducer (see ./reducers.js buildDjradReducer) will inspect the payload of all actions and
     * if the payload contains the key 'djradContext' it will pass that object to this function
     * (setGlobalContext) to update the djrad redux state.
     *
     * NOTE: future global context variables may have side effects outside of redux and should be handled here.
     *
     * @param state The (Immutable) redux state for the djrad state tree
     * @param context The new djrad context, generated by site.get_runtime_context (see e.g. djrad_rest.site)
     * @return The new djrad redux state
     */
    setGlobalContext = (state: Object, context: DjradSiteContext) => {
        const { globalPermissions } = context;
        return state.setIn(['GlobalPermissions'], globalPermissions);
    };
}
