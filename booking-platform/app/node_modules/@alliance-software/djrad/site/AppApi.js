// @flow
import {
    fetchEntities,
    fetchEntity,
    updateEntity,
    addEntity,
    deleteEntity,
    customDetailRoute,
} from 'alliance-redux-api';
import batchAction from '../actions/batchAction';
import type { Store } from '../types/store';

import Api from '../api';
import type { ApiConfig } from '../api';
import type { Model } from '../model/Model';
import type { ModelId } from '../model/types';

type PaginatedModelResponse = {
    count: number,
    ids: Array<string | number>,
    next: ?string,
    previous: ?string,
    results: Array<Model>,
};

type CreateFormResponse = {
    record: Model,
};
type UpdateFormResponse = {
    record: Model,
};

type HttpMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';

function isValidMethod(method: string) {
    return ['GET', 'POST', 'PATCH', 'DELETE'].indexOf(method.toUpperCase()) !== -1;
}

export default class AppApi extends Api {
    appModels: Map<ModelId, Class<Model>>;

    constructor(
        models: Map<ModelId, Class<Model>>,
        baseUrl: string,
        store: Store,
        config: ApiConfig = {}
    ) {
        super(baseUrl, store, config);
        this.appModels = models;
        this.store = store;
    }

    _getModelClass(modelId: Class<Model> | ModelId): Class<Model> {
        if (typeof modelId == 'string') {
            const modelClass = this.appModels.get(modelId);
            if (!modelClass) {
                throw new Error(
                    `Unknown model '${modelId}'. Known model ids are: ${[
                        ...this.appModels.keys(),
                    ].join(', ')}`
                );
            }
            return modelClass;
        }
        // We have an instance of the model, return the class
        if (modelId && typeof modelId == 'object' && modelId.constructor) {
            return modelId.constructor;
        }
        return modelId;
    }

    createModel(
        modelId: Class<Model> | ModelId,
        data: {},
        options: {} = {},
        meta: {} = {}
    ): Promise<CreateFormResponse> {
        const modelClass = this._getModelClass(modelId);
        // $FlowFixMe: Revisit
        return this.store.dispatch(addEntity(modelClass, data, options, meta));
    }

    deleteModel(
        modelId: Class<Model> | ModelId | Model,
        pk: number | string,
        meta: {} = {}
    ): Promise<void> {
        // $FlowFixMe: revisit
        const modelClass = this._getModelClass(modelId);
        const entity = modelClass.selectors.synced(this.store.getState()).get(pk);
        // $FlowFixMe: Revisit
        return this.store.dispatch(deleteEntity(entity, meta));
    }

    updateModel(
        modelId: Class<Model> | ModelId,
        pk: number | string,
        data: {}
    ): Promise<UpdateFormResponse> {
        const modelClass = this._getModelClass(modelId);
        const entity = modelClass.selectors.synced(this.store.getState()).get(pk);
        // $FlowFixMe: Revisit
        return this.store.dispatch(updateEntity(entity, data));
    }

    customDetailRoute(
        method: HttpMethod,
        modelId: Class<Model> | ModelId,
        pk: number | string,
        route: string,
        data: {},
        meta: {} = {}
    ): Promise<UpdateFormResponse> {
        if (!isValidMethod(method)) {
            throw new Error(`Invalid method ${method} passed to customDetailRoute.`);
        }
        const modelClass = this._getModelClass(modelId);
        const entity = modelClass.selectors.synced(this.store.getState()).get(pk);
        // $FlowFixMe: Revisit
        return this.store.dispatch(
            customDetailRoute(method.toLowerCase(), entity, route, data, meta)
        );
    }

    listModel(
        modelId: Class<Model> | ModelId,
        filter: ?{} = null,
        options: {} = {},
        meta: {} = {}
    ): Promise<PaginatedModelResponse> {
        const modelClass = this._getModelClass(modelId);
        // $FlowFixMe: Revisit
        return this.store.dispatch(fetchEntities(modelClass, filter, options, meta));
    }

    listRelatedModel(
        modelId: Class<Model> | ModelId,
        fieldName: string,
        filter: ?{ ids?: Array<number | string> }
    ) {
        const modelClass = this._getModelClass(modelId);
        if (!modelClass._meta.relatedLookup || !modelClass._meta.relatedLookup.endpoint) {
            throw new Error('Model does not support related lookups');
        }
        const field = modelClass._meta.fields[fieldName];
        if (!field.relation) {
            throw new Error(`Field ${fieldName} is not a relation`);
        }
        const toModelClass = field.relation.model;
        const { endpoint } = modelClass._meta.relatedLookup;
        const options = {
            endpoint,
            partialRecordFieldNames: ['__str__'],
        };
        const meta = { batchCall: true };
        if (filter && filter.ids) {
            const { ids, ...filterRest } = filter;
            // Uniquely identify the batch by the filters + fieldName
            // Not worrying about being super smart here, eg. different order on filters would
            // result in different batch.
            const filterKey = JSON.stringify(filterRest);
            // $FlowFixMe typing on batchAction return is wrong
            return this.store.dispatch(
                batchAction(
                    `${modelClass._meta.modelId}.${fieldName}.${filterKey}`,
                    (batch = { filter: filterRest, ids: [] }) => {
                        batch.ids.push(...ids);
                        return batch;
                    },
                    batch =>
                        fetchEntities(
                            toModelClass,
                            {
                                // Include any extra filters that were part of request
                                ...batch.filter,
                                // Send through all ids removing any duplicates
                                ids: [...new Set(batch.ids)],
                                fieldName,
                            },
                            options,
                            meta
                        ),
                    response => {
                        const { entities, results, ...rest } = response;
                        return {
                            ...rest,
                            entities: entities.filter(record => ids.includes(record.id)),
                            ids,
                        };
                    }
                )
            );
        }
        return this.listModel(toModelClass, { ...filter, fieldName }, options, meta);
    }

    getModel(modelId: Class<Model> | ModelId, id: string | number): Promise<Model> {
        const modelClass = this._getModelClass(modelId);
        // $FlowFixMe: Revisit
        return this.store.dispatch(fetchEntity(modelClass, id));
    }
}
