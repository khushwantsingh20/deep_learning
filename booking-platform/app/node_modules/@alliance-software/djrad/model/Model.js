import type { LiveUpdateListener } from 'alliance-redux-api/src/flowTypes';

// @flow
import { KeyedCollection, Record } from 'immutable';
import {
    isModel as isBaseModelClass,
    isModelInstance as isBaseModelInstance,
    $modelDefinition,
} from 'alliance-redux-api/lib/Model';
import { Model as ImmutableModel } from 'alliance-redux-api';
import invariant from 'invariant';
import oneLine from 'common-tags/lib/oneLine';
import type { FetchCache } from 'alliance-redux-api/lib/flowTypes';
import PermissionChecker from '../permissions/PermissionChecker';

import FieldFactory from './factory/FieldFactory';
import ModelComponentFactory from './ModelComponentFactory';
import Field from './fields/Field';
import type { ModelId, ModelDefinition, PermissionNameList } from './types';
import type { State } from '../types/state';
import StorageTypeFactory from './factory/StorageTypeFactory';

/**
 * Contains meta data about a model. This is created based on a ModelRegistration from django.
 */
export class ModelMeta {
    // This is set when we build the model class
    componentFactory: ModelComponentFactory;
    /** Label for the app this model belongs to */
    appLabel: string;
    /** Label for the model itself - supplied by ModelRegistration.get_label */
    label: string;
    /** Plural label - supplied by ModelRegistration.get_label_plural */
    labelPlural: string;
    /** Unique identifier for this model. Defaults to app_name.model_name but can be specified on ModelRegistration */
    modelId: ModelId;
    /** The name of the field that is the primary key for this model */
    pkFieldName: string;
    /** This is the api endpoint used for this model */
    endpoint: string;
    // This is the frontend url used for this model
    urlBase: string;
    // If supported will specify the endpoint to use for related model lookups
    // from other models to this model
    relatedLookup: ?{
        endpoint: string,
        supportsKeywordSearch: boolean,
    };
    /** List of all field names on this model */
    fieldNames: Array<string>;
    /** Object mapping field name to Field instance */
    fields: { [string]: Field };
    crud: {
        sortableFields: Array<string>,
        listFields: Array<string>,
        detailFields: Array<string>,
        createFields: Array<string>,
        updateFields: Array<string>,
        filterFields: Array<Field>,
    };
    /** Mapping of global and object level permissions for this model */
    actions: {
        global: PermissionNameList,
        object: PermissionNameList,
    };
    /** Mapping from action name to array of string permission names */
    actionPermissions: { [actionName: string]: PermissionNameList };
    /** @private */
    permissionChecker: PermissionChecker;
    /** @private */
    _definition: ModelDefinition;

    constructor(definition: ModelDefinition) {
        invariant(
            !!definition && typeof definition == 'object' && definition.fields,
            oneLine`
        You must passa model definition to Model(). This is typically generated by the
        backend and extracted from an App instance using 'defaultSite.modelDefinitions['sample_app.modelname']'.
        ${!definition &&
            'You passed a null value - has the model been registered in the backend and does the id match? You can inspect window.__RAD__ to see what has been generated from django.'}
        `
        );
        this.actions = definition.actions;
        this.actionPermissions = definition.actionPermissions;
        this.modelId = definition.modelId;
        this.endpoint = definition.endpoint;
        this.relatedLookup = definition.relatedLookup;
        this.urlBase = definition.urlBase;
        this.appLabel = definition.appLabel;
        this.label = definition.label;
        this.labelPlural = definition.labelPlural;
        this.pkFieldName = definition.pkFieldName;
        this.fields = {};
        this.fieldNames = [];
        const {
            listFields,
            detailFields,
            createFields,
            updateFields,
            sortableFields,
        } = definition.crud;
        this.crud = {
            sortableFields,
            listFields,
            detailFields,
            createFields,
            updateFields,
            filterFields: [],
        };
        this._definition = definition;
    }

    /**
     * @private
     */
    initialize(fieldFactory: FieldFactory, permissionChecker: PermissionChecker) {
        this.fields = {};
        this.fieldNames = [];
        this.permissionChecker = permissionChecker;
        for (const fieldDefinition of this._definition.fields) {
            const field = fieldFactory.buildField(fieldDefinition);
            // Note that for relations that get normalized field.name here may
            // be different from fieldDefinition.name.
            // Search for normalizeToField for more.
            this.fieldNames.push(field.name);
            this.fields[field.name] = field;
        }
        this.crud.filterFields = this._definition.crud.filterFields.map(fieldDef =>
            fieldFactory.buildFilterField(fieldDef)
        );
    }

    /**
     * @private
     */
    getValidLinkActions({
        recordOnly = false,
        includeDelete = true,
    }: {
        recordOnly: boolean,
        includeDelete: boolean,
    }): Array<string> {
        const actions = [];
        if (!recordOnly) {
            actions.push(...this.actions.global);
        }
        if (includeDelete) {
            actions.push(...this.actions.object);
        } else {
            actions.push(...this.actions.object.filter(action => action !== 'delete'));
        }
        return actions;
    }

    async getDefaultValues(
        fieldNames: Array<string> = this.fieldNames
    ): Promise<{ [fieldName: string]: any }> {
        const defaultValues = {};
        // We just do a map here to trigger all async requests immediately, Promise.all
        // to wait for them to resolve. Values are set directly in defaultValues obj.
        await Promise.all(
            fieldNames.map(async fieldName => {
                const field = this.fields[fieldName];
                // TODO: Move this to the Field class instead
                // Other things to support
                // - Fetching defaults via api call (this is why it returns a promise). This handles stuff
                //   that we can't statically cache
                // - Minimum items for many related
                const value = await field.getDefaultValue();
                if (value != null) {
                    defaultValues[fieldName] = value;
                }
            })
        );
        return defaultValues;
    }

    /**
     * Get the required permissions for an action. Throws Error if invalid action requested.
     * @param action
     * @returns {PermissionNameList}
     */
    getActionPermissions(action: string): PermissionNameList {
        const perms = this.actionPermissions[action];
        if (!perms) {
            throw new Error(
                `Unknown action '${action}' specified. Known actions: ${Object.keys(
                    this.actionPermissions
                ).join(', ')}`
            );
        }
        return perms;
    }

    /**
     * Check if action is valid object action for this model
     */
    isValidObjectAction(action: string): boolean {
        return this.actions.object.includes(action);
    }

    /**
     * Check if action is valid global action for this model
     */
    isValidGlobalAction(action: string): boolean {
        return this.actions.global.includes(action);
    }

    /**
     * Check if action is valid for this model
     */
    isValidAction(action: string): boolean {
        return this.isValidObjectAction(action) || this.isValidGlobalAction(action);
    }

    /**
     * Check whether user has requested permission for a specific action.
     *
     * Throws error if invalid action is specified
     * @param action identifier for action (eg. 'list', 'detail' etc). Defined on backend ModelRegistration - see
     * get_global_actions() and get_object_actions()
     * @param object optional model to check permission against. Checking global actions against an object is invalid
     * and vice versa.
     * @returns {Promise<boolean>} Promise that resolves to true or false once permission has been verified.
     */
    // eslint-disable-next-line no-use-before-define
    hasActionPerm(action: string, object?: ?Model): Promise<boolean> {
        const perms = this.getActionPermissions(action);
        if (object && this.isValidGlobalAction(action)) {
            throw new Error(`${action} is a global action but an object was passed.`);
        } else if (!object && this.isValidObjectAction(action)) {
            throw new Error(`${action} is an object specific action but no object was passed.`);
        }
        return this.permissionChecker.hasPerms(perms, object);
    }
}

/**
 * Redux selectors for a specific model. This are available on the 'selectors' property on every model class. Use this to select model data from redux cache.
 *
 * See https://github.com/reactjs/reselect for more information about selectors in general.
 *
 * @example
 * // Component that renders list of products that have already been fetched and are in Redux
 * function ProductList({ products }) {
 *    return <ul>{products.map(product => <li>{product.name}</li>)}</ul>;
 * }
 *
 * function mapStateToProps(state) {
 *    return {
 *        products: Product.selectors.all(state),
 *    };
 * }
 * export default connect(mapStateToProps)(ProductList);
 *
 * @example
 * // As above but uses the partial fields selector
 * function ProductList({ products }) {
 *    return <ul>{products.map(product => <li>{product.name}</li>)}</ul>;
 * }
 *
 * function mapStateToProps(state) {
 *    return {
 *        // This list of products will only have the 'name' field available
 *        products: Product.selectors.partialFields.all(state)(['name']),
 *    };
 * }
 * export default connect(mapStateToProps)(ProductList);

 */
/* eslint-disable */
export type ModelReduxSelectors = {
    all: (state: State) => KeyedCollection<string | number, Model>,
    synced: (state: State) => KeyedCollection<string | number, Model>,
    local: (state: State) => KeyedCollection<string | number, Model>,
    related: (state: State) => KeyedCollection<string | number, Model>,
    partialFields: {
        all: (
            state: State
        ) => (fieldNames: Array<string>) => KeyedCollection<string | number, Model>,
        synced: (
            state: State
        ) => (fieldNames: Array<string>) => KeyedCollection<string | number, Model>,
    },
};
/* eslint-enable */

/**
 * This is just a placeholder class for custom model classes to extend. It's purpose
 * is to make it clear to the user that providing a custom model involves some
 * deferred initialization.
 *
 * The extending of Record is just to get flow types working properly - it always gets
 * replaced at runtime to the actual model record.
 * @ignore
 */
export class BaseModel extends Record(({ __str__: '' }: { __str__: string })) {
    static selectors: ModelReduxSelectors;
    static _meta: ModelMeta;
    _meta: ModelMeta;
    __str__: string;
}

export type Model = BaseModel;

/*
export interface Model {
    static selectors: ModelReduxSelectors;
    static _meta: ModelMeta;
    _meta: ModelMeta;
    __str__: string;
    get(fieldName: string): any;
    getId(): number | string;
    constructor(data: { [fieldName: string]: any }) : void;
}
*/

/**
 * Is something a model class?
 */
export function isModelClass(model: any): boolean {
    return isBaseModelClass(model);
}

/**
 * Is something an instance of a model class?
 */
export function isModelInstance(model: any): boolean {
    return isBaseModelInstance(model);
}

export function isValidModel(model: any): boolean {
    return isModelClass(model) || isModelInstance(model);
}

type Selector = (state: {}, props: {}) => {};

export type ModelConfigurationOptions = {
    componentFactory?: Class<ModelComponentFactory>,
    modelClass?: Class<BaseModel>,
    createModelReducer: (model: Class<BaseModel>) => Function,
    buildSelectors?: (defaultSelectors: {
        all: Selector,
        synced: Selector,
        local: Selector,
        meta: Selector,
    }) => { [key: string]: Selector },
    // These options can all be passed directly through to the alliance-redux-api Model
    cache?: FetchCache,
    liveUpdateModel?: string,
    sortBy: (
        comparatorValueMapper: (value: any, key: any) => any,
        comparator?: (valueA: any, valueB: any) => number
    ) => any,
    liveUpdateListener?: LiveUpdateListener,
};

export default function buildModel(
    definition: ModelDefinition,
    storageTypeFactory: StorageTypeFactory,
    options: ModelConfigurationOptions = {}
): Class<Model> {
    const { componentFactory = ModelComponentFactory, buildSelectors, ...rest } = options;
    const meta = new ModelMeta(definition);
    const typedImmutableDefinition = storageTypeFactory.buildFields(definition.fields);

    const ModelClass = ImmutableModel(
        typedImmutableDefinition,
        definition.modelId,
        definition.labelPlural,
        {
            ...rest,
            idFieldName: definition.pkFieldName,
            endpoint: definition.endpoint,
            modelId: definition.modelId,
            orderedModel: definition.orderedModel,
            buildSelectors: defaultSelectors => {
                const selectors = {
                    // Related models are fetched as partial fields only - this fetches the correct subset
                    related: state => defaultSelectors.partialFields.synced(state)(['__str__']),
                };
                if (buildSelectors) {
                    return {
                        ...selectors,
                        ...buildSelectors(defaultSelectors),
                    };
                }
                return selectors;
            },
        }
    );
    const addProperties = cls => {
        // Here we want to add both a static property and instance property _meta
        // This allows us to get _meta on either a model instance or model class
        // $FlowFixMe
        Object.defineProperty(cls, '_meta', {
            get() {
                return meta;
            },
        });
        // $FlowFixMe
        Object.defineProperty(cls.prototype, '_meta', {
            get() {
                return meta;
            },
        });
    };
    addProperties(ModelClass);
    addProperties(ModelClass[$modelDefinition].partialRecordClass);
    meta.componentFactory = new componentFactory(ModelClass);

    return ModelClass;
}
