// @flow
import Immutable from 'immutable';
import { Id } from 'alliance-redux-api/lib/fieldTypes';
import { ForeignKeyField } from 'alliance-redux-api';
import { Typed, List, Maybe, Record } from 'typed-immutable';
import { typeOf as typedImmutableTypeOf } from 'typed-immutable/lib/typed';

import type { Model } from '../Model';
import type { FieldDefinition, ModelId, StorageTypeDescriptor } from '../types';
import FileType from '../immutable-types/FileType';
import MomentDateType from '../immutable-types/MomentDateType';
import MomentDateTimeType from '../immutable-types/MomentDateTimeType';

// Override the default implementation for Any. Normally it would end up as
// inferred by typed-immutable - so arrays would be lists, objects maps and
// everything else the native type. This generally works however there is an
// inconsitency when updates are done. Here's an example that demonstrates:
// With the mergeIn method:
//   > record.mergeIn(['myField'], {}).myField;
//   > Map(...)
// With the setIn method:
//   > record.setIn(['myField'], {}).myField;
//   > {}
// In the first the type is an immutable Map. In the second a plain object.
// This is problematic as things work fine on initial load and most updates/creates
// but if anything uses setIn() it will suddenly break (partial records use
// setIn and as such the issue happens when working with partial records only)
// The fix is to use the core immutablejs revive function fromJS(). As Any types
// have no type we aren't losing anything here - we just rely on the core immutablejs
// functionality without this bug that exists only in typed-immutable.
const Any = Typed('Any', value => Immutable.fromJS(value));

/**
 * Generate typed-immutable types based on StorageType specification provided
 * by the backend. This class is used to generate the final redux state specification
 * for each model.
 */
export default class StorageTypeFactory {
    // Map of models already registered. Used for looking up references for relations;
    models: Map<ModelId, Class<Model>>;

    constructor(models: Map<ModelId, Class<Model>>) {
        this.models = models;
    }

    buildPrimaryKey(fieldDef: FieldDefinition) {
        const { storageType } = fieldDef;
        if (!storageType) {
            throw new Error(
                "storageType not defined. Check 'requires_storage_type' on FieldDescriptor is True"
            );
        }
        // For numbers use the Id type which handles either a string that looks like a number, or a
        // number directly. Due to ID often being used as a key in an object numbers often end up
        // as strings. Using `Id` will convert a string back to number so things like ImmutableJS
        // collection equality checks will correctly pass.
        if (storageType.name === 'Number') {
            return Id();
        }
        return this.buildStorageType(storageType, fieldDef);
    }

    buildStorageType(storageType: StorageTypeDescriptor, fieldDef: FieldDefinition) {
        switch (storageType.name) {
            case 'List': {
                if (storageType.subType == null) {
                    throw new Error('subType should not be null for storage type of List');
                }
                const subType = this.buildStorageType(storageType.subType, fieldDef);
                return List(subType);
            }
            case 'String': {
                if (fieldDef.defaultValue != null) {
                    return String(fieldDef.defaultValue);
                }
                return String;
            }
            case 'Boolean': {
                if (fieldDef.defaultValue != null) {
                    return Boolean(fieldDef.defaultValue);
                }
                return Boolean;
            }
            case 'Number': {
                if (fieldDef.defaultValue != null) {
                    return Number(fieldDef.defaultValue);
                }
                return Number;
            }
            case 'Date': {
                return MomentDateType(fieldDef.defaultValue);
            }
            case 'DateTime': {
                return MomentDateTimeType(fieldDef.defaultValue);
            }
            case 'File':
            case 'Image': {
                return FileType;
            }
            case 'Record': {
                if (!fieldDef.fieldClassOptions) {
                    throw new Error(
                        "Storage type of Record must provide fieldClassOptions with key of 'fields'"
                    );
                }
                return Record(this.buildFields(fieldDef.fieldClassOptions.fields));
            }
            case 'ModelReference': {
                const model = this.models.get(storageType.registrationId);
                if (!model) {
                    // eslint-disable-next-line
                    console.warn(
                        `Failed to find model ${
                            storageType.registrationId
                        }. This is unexpected. Type has been set to Any.`,
                        storageType,
                        fieldDef
                    );
                    return Any;
                }
                return model;
            }
            case 'Range': {
                const rangeType = this.buildStorageType(storageType.subType, fieldDef);
                return new Record(
                    {
                        lower: rangeType,
                        upper: rangeType,
                    },
                    `${storageType.subType.name} Range`
                );
            }
            case 'Any':
            default: {
                return Any;
            }
        }
    }

    buildNormalizedRelationField(fieldDef: FieldDefinition): ForeignKeyField {
        if (!fieldDef.relation || !fieldDef.relation.normalizeToField) {
            throw new Error(
                'buildNormalizedRelationField must be called on a field with a relation with normalizeToField set'
            );
        }
        // This handles normalizing nested data into the root entities state for that entity
        // eg.
        // {
        //    id: 1,
        //    items: [{ name: 'item 1', id: 1}, { name: 'item 2', id: 2}]
        // }
        // with normalizeToField of 'itemIds' would result in:
        // {
        //    id: 1,
        //    itemIds: [1, 2],
        // }
        const {
            relationRegistrationId: toModelId,
            relationType,
            normalizeToField,
        } = fieldDef.relation;
        const toMany = ['ManyToMany', 'OneToMany'].includes(relationType);
        const toModel = this.models.get(toModelId);
        if (!toModel) {
            throw new Error(
                `Relation '${
                    fieldDef.name
                }' to '${toModelId}' wants to normalize to field '${normalizeToField}' but ${toModelId} hasn't been registered. This is likely a dependency resolution issue.`
            );
        }
        return ForeignKeyField(toModel, {
            schemaFieldName: fieldDef.originalFieldName,
            many: toMany,
        });
    }

    buildStorageForField(fieldDef: FieldDefinition) {
        if (fieldDef.pk) {
            return this.buildPrimaryKey(fieldDef);
        }
        if (fieldDef.subType && fieldDef.name !== 'List') {
            throw new Error('Container types only supported for List currently');
        }
        const { storageType } = fieldDef;
        if (!storageType) {
            throw new Error(
                "storageType not defined. Check 'requires_storage_type' on FieldDescriptor is True"
            );
        }
        return this.buildStorageType(storageType, fieldDef);
    }

    buildFields(fieldDefs: Array<FieldDefinition>) {
        return fieldDefs.reduce((acc, fieldDef) => {
            let type;
            const fieldName = fieldDef.name;
            if (fieldDef.relation && fieldDef.relation.normalizeToField) {
                type = this.buildNormalizedRelationField(fieldDef);
            } else {
                type = this.buildStorageForField(fieldDef);
                if (
                    (!fieldDef.required || fieldDef.writeOnly) &&
                    typedImmutableTypeOf(type) !== Any
                ) {
                    type = Maybe(type);
                }
            }
            acc[fieldName] = type;
            return acc;
        }, {});
    }
}
