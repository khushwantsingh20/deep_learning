// @flow
import AnyTypeField from '../fields/AnyTypeField';
import BooleanField from '../fields/BooleanField';
import CharField from '../fields/CharField';
import DateField from '../fields/DateField';
import DateTimeField from '../fields/DateTimeField';
import DurationField from '../fields/DurationField';
import EmailField from '../fields/EmailField';
import DecimalField from '../fields/DecimalField';
import IntegerField from '../fields/IntegerField';
import FloatField from '../fields/FloatField';
import Field from '../fields/Field';
import FileField from '../fields/FileField';
import IPAddressField from '../fields/IPAddressField';
import ImageField from '../fields/ImageField';
import NullBooleanField from '../fields/NullBooleanField';
import PrimaryKeyRelatedField from '../fields/PrimaryKeyRelatedField';
import RecordField from '../fields/RecordField';
import Relation from '../relations/Relation';
import ModelReferenceField from '../fields/ModelReferenceField';
import TextField from '../fields/TextField';
import TimeField from '../fields/TimeField';
import URLField from '../fields/URLField';
import buildRelation from '../relations/buildRelation';
import type { FieldContainerDescriptor, FieldDefinition, ModelId } from '../types';
import type { Model } from '../Model';
import DateRangeField from '../fields/DateRangeField';
import DateTimeRangeField from '../fields/DateTimeRangeField';
import IntegerRangeField from '../fields/IntegerRangeField';
import FloatRangeField from '../fields/FloatRangeField';
import LookupChoiceField from '../fields/LookupChoiceField';
import ContainerField from '../fields/ContainerField';

export default class FieldFactory {
    fieldTypeMap = {
        AnyTypeField,
        TextField,
        CharField,
        EmailField,
        URLField,
        DurationField,
        TimeField,
        IPAddressField,
        SlugField: TextField,
        FloatField,
        DecimalField,
        IntegerField,
        FileField,
        DateField,
        DateTimeField,
        BooleanField,
        NullBooleanField,
        ImageField,
        PrimaryKeyRelatedField,
        RecordField,
        ModelReferenceField,
        DateRangeField,
        DateTimeRangeField,
        IntegerRangeField,
        FloatRangeField,
    };

    model: Class<Model>;
    allModels: Map<ModelId, Class<Model>>;
    // This is a Site instance... can't type it properly because jest
    // breaks on circular imports
    site: Object;

    constructor(model: Class<Model>, allModels: Map<ModelId, Class<Model>>, site: Object) {
        this.model = model;
        this.allModels = allModels;
        this.site = site;
    }

    /**
     * Add any extra mappings for default value constants here. This maps to the
     * constants defined in ModelRegistration DEFAULT_VALUE_FRONTEND_CONSTANTS.
     *
     * Note that Field.js implements some defaults that will be concatenated to these,
     * specifically handling of values required by specific fields (eg. date now() and today())
     *
     * @example
     * ```js
     * getDefaultValueMap() {
     *     return new Map([
     *         ['MY_VALUE', () => somethingDynamic()],
     *         ['MY_VALUE2', 5],
     *     ]);
     * }
     * ```
     */
    getDefaultValueMap(): Map<any, any> {
        return new Map();
    }

    getFieldClass(fieldClassName: string) {
        return this.fieldTypeMap[fieldClassName];
    }

    getRelation(definition: FieldDefinition): Relation {
        if (!definition.relation) {
            throw new Error("Cannot create Relation if 'relation' property is unspecified");
        }
        return buildRelation(this.model, definition.relation, this.allModels);
    }

    constructFieldClass(
        fieldClass: Class<Field>,
        definition: FieldDefinition,
        relation?: Relation
    ) {
        if (fieldClass === RecordField) {
            if (!definition.fieldClassOptions) {
                throw new Error('fieldClassOptions is required for RecordField');
            }
            const { fields } = definition.fieldClassOptions;
            const recordFields = fields.map(fieldDescriptor => this.buildField(fieldDescriptor));
            return new RecordField(this.model, this.site, relation, definition, recordFields);
        }
        return new fieldClass(this.model, this.site, relation, definition);
    }

    buildField(definition: FieldDefinition) {
        const { fieldClassName, containedIn } = definition;
        const finalDefinition: FieldDefinition = {
            ...definition,
            defaultValueMap: this.getDefaultValueMap(),
        };
        const fieldClass = this.getFieldClass(fieldClassName);
        if (!fieldClass) {
            throw new Error(`Unknown field type ${fieldClassName} found`);
        }
        let relation;
        if (definition.relation) {
            relation = this.getRelation(finalDefinition);
        }
        const field = this.constructFieldClass(fieldClass, finalDefinition, relation);
        if (containedIn) {
            return this.buildContainer(containedIn, field);
        }
        return field;
    }

    /**
     * Recursively build container fields. A container field will either accept another
     * ContainerField or Field until the final container which must accept a Field.
     *
     * eg.
     * LookupChoiceField
     *    ListField
     *        TextField
     */
    buildContainer(
        containedIn: FieldContainerDescriptor,
        field: Field | ContainerField
    ): ContainerField {
        if (containedIn.child) {
            field = this.buildContainer(containedIn.child, field);
        }
        if (containedIn.containerType === 'List') {
            return field.buildListField(containedIn);
        }
        if (containedIn.containerType === 'LookupChoiceField') {
            const { defaultValue, options } = containedIn;
            return new LookupChoiceField(
                field,
                { ...options, defaultValueMap: this.getDefaultValueMap() },
                defaultValue
            );
        }
        throw new Error(`Unknown container type ${containedIn.containerType}`);
    }

    buildFilterField(definition: FieldDefinition) {
        return this.buildField(definition);
    }
}
