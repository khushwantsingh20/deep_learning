// @flow
import * as React from 'react';

import type { WidgetProps } from '../../components/form/FormField';
import type { FormatterProps } from '../../components/formatter/types';
// This causes Jest to die, I guess because of some circular imports
// Ignore it for now - just set return type of get model() to Object.
// import Model from '../Model';
import Field from './Field';
import Relation from '../relations/Relation';
import type { FieldContainerDescriptor } from '../types';

/**
 * Container fields provide widgets and logic for managing a single field value. For
 * example a list of urls would be a ListField with a `field` value of type
 * `URLField`. Details about the field such as the model, name, helpText etc are
 * taken from the underlying field, the container just defines some logic over
 * the top specific to the container (eg. managing a collection of values or
 * managing some meta data about the value for example the lookup expression to use
 * on a filter field).
 */
export default class ContainerField {
    field: Field | ContainerField;
    defaultValue: ?Array<any>;

    constructor(field: Field | ContainerField, defaultValue: ?Array<any>) {
        this.field = field;
        // We need to handle async default values - defer to default field logic for that
        this.defaultValue = field.buildDefaultValue(defaultValue, true);
    }

    buildDefaultValue(...args) {
        return this.field.buildDefaultValue(...args);
    }

    get site(): Object {
        return this.field.site;
    }

    get model(): Object {
        return this.field.model;
    }

    get name(): string {
        return this.field.name;
    }

    get source(): string {
        return this.field.source;
    }

    get required(): boolean {
        return this.field.required;
    }

    get label(): string {
        return this.field.label;
    }

    get helpText(): ?string {
        return this.field.helpText;
    }

    get readOnly(): boolean {
        return this.field.readOnly;
    }

    get writeOnly(): boolean {
        return this.field.writeOnly;
    }

    get relation(): ?Relation {
        return this.field.relation;
    }

    get choices() {
        return this.field.choices;
    }

    get choicesLookupEndpoint() {
        return this.field.choicesLookupEndpoint;
    }

    buildListField(containerDefinition: FieldContainerDescriptor) {
        return this.field.buildListField(containerDefinition);
    }

    async getDefaultValue(): Promise<?Array<any>> {
        if (typeof this.defaultValue === 'function') {
            const value = await this.defaultValue();
            if (!value) {
                return null;
            }
            // TODO: This doesn't properly handle nested ArrayFields - only one level
            // of container is supported
            return value.containerValue;
        }
        return this.defaultValue;
    }

    // eslint-disable-next-line no-unused-vars
    parse(values: any) {
        throw new Error('parse must be implemented');
    }

    // eslint-disable-next-line no-unused-vars
    format(values: any) {
        throw new Error('format must be implemented');
    }

    // eslint-disable-next-line no-unused-vars
    getDefaultWidget(props: WidgetProps) {
        throw new Error('getDefaultWidget must be implemented');
    }

    // eslint-disable-next-line no-unused-vars
    getDefaultFormatter(props: FormatterProps): React.Node {
        throw new Error('getDefaultFormatter must be implemented');
    }

    getReduxFormFieldComponent() {
        throw new Error('getReduxFormFieldComponent');
    }
}
