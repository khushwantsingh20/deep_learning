// @flow
import * as React from 'react';
import oneLine from 'common-tags/lib/oneLine';
import { List } from 'immutable';
import { Field as ReduxFormField } from 'redux-form';
import moment from 'moment';

import InputWidget from '../../components/form/widgets/InputWidget';
import ChoiceFormatter from '../../components/formatter/ChoiceFormatter';
import type { Model } from '../Model';
import type { FieldContainerDescriptor, FieldDefinition } from '../types';
import type { FormatterProps } from '../../components/formatter/types';
import type { WidgetProps } from '../../components/form/FormField';
import Relation from '../relations/Relation';
import ListField from './ListField';
import type { RenderListItemExtra } from './ListField';
import FormField from '../../components/form/FormField';
import ListItemWidget from '../../components/form/widgets/ListItemWidget';
import RemoteChoicesWidget from '../../components/form/widgets/RemoteChoicesWidget';
import ChoicesWidget from '../../components/form/widgets/ChoicesWidget';
import { getModelDefaultValue } from '../../actions';

export default class Field {
    model: Class<Model>;
    required: boolean;
    name: string;
    source: string;
    label: string;
    helpText: ?string;
    defaultValue: ?any;
    choices: ?Map<any, string>;
    choiceRefinementUrl: ?string;
    readOnly: boolean;
    writeOnly: boolean;
    relation: ?Relation;
    defaultValueMap: Map<any, any>;
    // This is a Site instance... can't type it properly because jest
    // breaks on circular imports
    site: Object;

    constructor(model: Class<Model>, site: Object, relation: ?Relation, options: FieldDefinition) {
        const {
            name,
            label,
            source,
            required,
            helpText,
            defaultValue,
            choices,
            choiceRefinementUrl,
            readOnly,
            writeOnly,
        } = options;
        this.site = site;
        this.model = model;
        if (options.relation && options.relation.normalizeToField) {
            this.name = options.relation.normalizeToField;
        } else {
            this.name = name;
        }
        this.choiceRefinementUrl = choiceRefinementUrl;
        this.source = source;
        this.required = required;
        this.label = label;
        this.helpText = helpText;
        this.readOnly = readOnly;
        this.writeOnly = writeOnly;
        if (choices) {
            this.choices = new Map(choices);
        }
        this.relation = relation;
        this.defaultValueMap = options.defaultValueMap || new Map();
        this.defaultValue = this.buildDefaultValue(defaultValue);

        // Resolve potential binding issues here rather than requiring each
        // subclass to do it.
        // $FlowFixMe
        this.getDefaultWidget = this.getDefaultWidget.bind(this);
    }

    getDefaultValueMap(): Map<any, any> {
        return new Map([
            ['DATETIME.NOW', () => moment()],
            // Today, but time set to 0
            ['DATETIME.TODAY', () => moment(0, 'HH')],
            ['DATE.TODAY', () => moment(0, 'HH')],
            ...this.defaultValueMap.entries(),
        ]);
    }

    buildDefaultValue(defaultValue: any, isContainer: boolean = false): any {
        const defaultValueMap = this.getDefaultValueMap();
        if (!(defaultValueMap instanceof Map)) {
            throw new Error(
                `getDefaultValueMap must return an instance of map. See field ${
                    this.model._meta.modelId
                }.${this.name}`
            );
        }
        if (defaultValue && typeof defaultValue === 'object') {
            if (defaultValue.__djradMappedValue) {
                if (!defaultValueMap.has(defaultValue.value)) {
                    // eslint-disable-next-line
                    console.warn(
                        oneLine`
                    Unknown mapping for default value for field ${this.model._meta.modelId}.${
                            this.name
                        }. If
                    this is a custom field make sure 'getDefaultValueMap' contains a mapping for this field or
                    add it to the FieldFactory getDefaultValueMap`,
                        defaultValue
                    );
                }
                return defaultValueMap.get(defaultValue.value);
            }
            if (defaultValue.__djradCallable) {
                return async () => {
                    const value = await this.site.store.dispatch(
                        getModelDefaultValue(this.model, this.name)
                    );
                    if (isContainer) {
                        return value;
                    }
                    if (!value) {
                        return null;
                    }
                    return value.singleValue;
                };
            }
        }
        return defaultValue;
    }

    parse(value: any): any {
        return value;
    }

    format(value: any): any {
        return value;
    }

    getDefaultFormatter(props: FormatterProps): React.Node {
        if (this.choices) {
            return <ChoiceFormatter {...props} labels={this.choices} />;
        }
        if (props.value && typeof props.value == 'object') {
            let message;
            if (Array.isArray(props.value) || List.isList(props.value)) {
                message = oneLine`
                    Field '${this.name}' on '${this.model._meta.modelId} is a list of values but
                    has no specific FieldFormatter. This means the value will render directly
                    which could have undesirable results. This can
                    happen with custom fields or when using 'SerializerMethodField' or 'ReadOnlyField'.
                    If you are using properties from a model as a field on a serializer this will also
                    result in the same behaviour. To tell djrad what type of field this is see
                    https://djrad.herokuapp.com/api/registration/#djrad_rest.registration.registration.ModelRegistration.create_field_descriptor
                `;
            } else {
                message = oneLine`
                    Field '${this.name}' on '${this.model._meta.modelId} has an object value but
                    has no specific FieldFormatter. This means the value will render as is and will
                    likely emmit the warning 'Using Maps as children is unsupported...'. This can
                    happen with custom fields or when using 'SerializerMethodField' or 'ReadOnlyField'.
                    If you are using properties from a model as a field on a serializer this will also
                    result in the same behaviour. To tell djrad what type of field this is see
                    https://djrad.herokuapp.com/api/registration/#djrad_rest.registration.registration.ModelRegistration.create_field_descriptor
                `;
            }
            // eslint-disable-next-line no-console
            console.warn(message);
        }
        return props.value;
    }

    getDefaultWidget(props: WidgetProps) {
        if (this.choiceRefinementUrl) {
            return (
                <RemoteChoicesWidget
                    endpoint={this.choiceRefinementUrl}
                    allowClear={!this.required}
                    {...props}
                />
            );
        }
        if (this.choices) {
            const choices: Array<[string, string]> = [...this.choices.entries()];
            return <ChoicesWidget required={this.required} {...props} choices={choices} />;
        }
        return <InputWidget {...props} />;
    }

    getDefaultValue() {
        if (typeof this.defaultValue === 'function') {
            return this.defaultValue();
        }
        return this.defaultValue;
    }

    buildListField(containerDefinition: FieldContainerDescriptor) {
        const { defaultValue } = containerDefinition;
        return new ListField(this, defaultValue);
    }

    getReduxFormFieldComponent() {
        return ReduxFormField;
    }

    /**
     * Get widget to use for single item when this field is rendered as part of a list
     * @param formFieldName
     * @param extra
     * @returns {*}
     */
    getListItemWidget(formFieldName: string, extra: RenderListItemExtra): React.Element<*> {
        // We let the field type determine whether to use FormField or something
        // else for a field widget. This is primarily so things like ModelReferenceField
        // can just render as a subform with formFieldName as the form key in which
        // case wrapping in FormField is not required.
        return (
            <FormField
                name={formFieldName}
                widget={<ListItemWidget {...extra} inputWidget={this.getDefaultWidget} />}
            />
        );
    }

    /**
     * When this field is used as a filter this function can be used to transform a value
     * into a different shape as required by the backend. Should return an object indexed
     * by name that will be merged with all other fields in a form.
     * @param value
     * @returns {[null]}
     */
    // eslint-disable-next-line no-unused-vars
    transformFilterValue(value: any, allValues: { [string]: any }): { [string]: any } {
        return { [this.name]: value };
    }
}
