// @flow
import React from 'react';
import Field from './Field';
import NumberFormatter from '../../components/formatter/NumberFormatter';
import type { FormatterProps } from '../../components/formatter/types';
import ChoicesWidget from '../../components/form/widgets/ChoicesWidget';
import NumberWidget from '../../components/form/widgets/NumberWidget';
import type { WidgetProps } from '../../components/form/FormField';
import RemoteChoicesWidget from '../../components/form/widgets/RemoteChoicesWidget';

export default class NumberField extends Field {
    parse(value: string | number): ?number | string {
        // Don't force empty string, null or undefined to a number (which would be 0) -
        // force them both to be null to represent no value set.
        if (value === '' || value == null) {
            return null;
        }
        const numberValue = Number(value);
        // If we can't parse number just return it as is so as not to break inputs
        if (Number.isNaN(numberValue)) {
            return value;
        }
        return numberValue;
    }

    getDefaultFormatter(props: FormatterProps) {
        const el = super.getDefaultFormatter(props);
        if (el) {
            return el;
        }
        // TODO: Handle localeOptions, eg DecimalField places etc
        return <NumberFormatter {...props} />;
    }

    getDefaultWidget(props: WidgetProps) {
        if (this.choiceRefinementUrl) {
            return (
                <RemoteChoicesWidget
                    allowClear={!this.required}
                    endpoint={this.choiceRefinementUrl}
                    {...props}
                />
            );
        }
        if (this.choices) {
            const choices = [...this.choices.entries()];
            return <ChoicesWidget required={this.required} {...props} choices={choices} />;
        }
        return <NumberWidget {...props} />;
    }
}
