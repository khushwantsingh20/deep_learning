// @flow
import * as React from 'react';
import { Icon, Button } from 'antd';
import Field from './Field';
import type { FormatterProps } from '../../components/formatter/types';
import type { WidgetProps } from '../../components/form/FormField';
import type { RenderListItemExtra } from './ListField';
import ActionLink from '../../components/model/ActionLink';
import RelatedModelLookupWidget from '../../components/form/widgets/RelatedModelLookupWidget';
import RelatedModelFormatter from '../../components/formatter/RelatedModelFormatter';
import type { Model } from '../Model';
import type { FieldDefinition } from '../types';
import Relation from '../relations/Relation';

export default class ModelReferenceField extends Field {
    isNormalized: boolean = false;

    constructor(model: Class<Model>, site: Site, relation: ?Relation, options: FieldDefinition) {
        super(model, site, relation, options);
        if (options.fieldClassOptions) {
            this.isNormalized = options.fieldClassOptions.isNormalized;
        }
    }

    getDefaultFormatter(props: FormatterProps) {
        if (!props.value) {
            return null;
        }
        const label = props.value.__str__;
        const { relation } = this;
        if (!relation) {
            return label;
        }
        if (this.isNormalized) {
            return <RelatedModelFormatter {...props} />;
        }
        if (relation.model._meta.isValidObjectAction('detail')) {
            return (
                <ActionLink action="detail" record={props.value}>
                    {label}
                </ActionLink>
            );
        }
        return label;
    }

    getDefaultWidget(props: WidgetProps) {
        const { relation } = this;
        if (!relation) {
            return super.getDefaultWidget(props);
        }
        if (this.isNormalized) {
            // For normalized fields don't show form inline, use drop lookup reference.
            return (
                <RelatedModelLookupWidget
                    allowClear={!this.required}
                    supportsServerSideSearch={relation.filterable}
                    toModel={relation.model}
                    fromModel={relation.fromModel}
                    fromFieldName={this.name}
                    {...props}
                />
            );
        }
        // $FlowFixMe: formProps comes from getListItemWidget, not in WidgetProps
        const { formProps, ...rest } = props;
        const { value } = props;
        const { model } = relation;
        const finalFormProps = {
            ...rest,
            // Note initialValues is not needed (and does nothing) - this is
            // handled by the form initialisation.
            // initialValues: value,
            formName: props.name,
            footer: null,
            ...formProps,
        };
        if (value && value[model._meta.pkFieldName] != null) {
            return model._meta.componentFactory.buildUpdateForm(finalFormProps);
        }
        return model._meta.componentFactory.buildCreateForm(finalFormProps);
    }

    async getDefaultValue() {
        const { relation } = this;
        if (!relation) {
            return super.getDefaultValue();
        }
        return relation.model._meta.getDefaultValues();
    }

    getListItemWidget(formFieldName: string, extra: RenderListItemExtra): React.Element<*> {
        // Doesn't match WidgetProps, probably need to rework those. They
        // specify the final values the widget will get but it will have them injected
        // later when passed to redux-form Field
        // $FlowFixMe: ^
        return this.getDefaultWidget({
            name: formFieldName,
            value: extra.value,
            formProps: {
                footer: extra.canRemove && (
                    <Button type="danger" size="small" onClick={extra.onRemove}>
                        <Icon type="minus" /> Remove
                    </Button>
                ),
            },
        });
    }
}
