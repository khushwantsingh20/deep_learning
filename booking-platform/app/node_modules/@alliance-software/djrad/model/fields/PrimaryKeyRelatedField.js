// @flow
import React from 'react';
import Field from './Field';
import RelatedModelLookupWidget from '../../components/form/widgets/RelatedModelLookupWidget';
import RelatedModelFormatter from '../../components/formatter/RelatedModelFormatter';
import ModelLookupWidget from '../../components/form/widgets/ModelLookupWidget';
import type { FormatterProps } from '../../components/formatter/types';
import type { WidgetProps } from '../../components/form/FormField';
import type { FieldContainerDescriptor } from '../types';

export default class PrimaryKeyRelatedField extends Field {
    getDefaultFormatter(props: FormatterProps) {
        const relation = this.relation;
        if (relation == null) {
            return props.value;
        }
        return <RelatedModelFormatter {...props} />;
    }

    getDefaultWidget(props: WidgetProps) {
        const { relation } = this;
        if (!relation) {
            return super.getDefaultWidget(props);
        }
        let lookupWidget;
        const multiple = relation.isToMany();
        if (multiple) {
            lookupWidget = ModelLookupWidget.TransferWidget;
        }
        return (
            <RelatedModelLookupWidget
                allowClear={!this.required}
                supportsServerSideSearch={relation.filterable}
                toModel={relation.model}
                fromModel={relation.fromModel}
                fromFieldName={this.name}
                multiple={multiple}
                lookupWidget={lookupWidget}
                showUpdate={!multiple}
                {...props}
            />
        );
    }

    buildListField(containerDefinition: FieldContainerDescriptor) {
        // For multiple values we render it above using multi-select widget
        if (this.relation != null && this.relation.isToMany()) {
            return this;
        }
        return super.buildListField(containerDefinition);
    }
}
