// @flow
import { ApiError } from 'redux-api-middleware';
import * as api from 'alliance-redux-api/lib/api';

import type { Store } from '../types/store';

const { API_CALL_AUTH_REQUIRED } = api;
export { ApiError, API_CALL_AUTH_REQUIRED };

type CredentialsType = 'omit' | 'same-origin' | 'include';

/**
 * API Configuration Options
 */
export type ApiConfig = {
    includeCsrfTokenHeader?: boolean,
    appendSlash?: boolean,
    credentials?: CredentialsType,
    headers?: { [string]: string },
    convertQueryParam?: (value: any) => any,
};

type CallConfig = {
    types?: [string, string, string],
    requestType?: string,
    successType?: string,
    failureType?: string,
};

type ApiData = FormData | { [string]: any };

export default class Api {
    store: Store;

    constructor(baseUrl: string, store: Store, config: ApiConfig = {}) {
        // When running tests or styleguide this class will be instantiated multiple times
        if (!api.isApiConfigured(baseUrl)) {
            api.configureApi(baseUrl, config);
        }
        this.store = store;
    }

    get(endpoint: string, params: ?{} = {}, config: CallConfig = {}): Promise<any> {
        // $FlowFixMe
        return this.store.dispatch(api.get(endpoint, params, config));
    }

    post(endpoint: string, data: ApiData = {}, config: CallConfig = {}): Promise<any> {
        // $FlowFixMe
        return this.store.dispatch(api.post(endpoint, data, config));
    }

    patch(endpoint: string, data: ApiData = {}, config: CallConfig = {}): Promise<any> {
        // $FlowFixMe
        return this.store.dispatch(api.patch(endpoint, data, config));
    }

    delete(endpoint: string, params: ?{} = {}, config: CallConfig = {}): Promise<Response> {
        // $FlowFixMe
        return this.store.dispatch(api.del(endpoint, params, config));
    }
}
