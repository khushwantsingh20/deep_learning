/* eslint consistent-return: 0 */
import isPlainObject from 'lodash/isPlainObject';
import isObjectLike from 'lodash/isObjectLike';
import { isModelInstance, isModelClass } from '../model/Model';

function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location) {
        if (props[propName] == null) {
            if (isRequired) {
                return new Error(
                    `Required prop '${propName}' was not specified in ${componentName}`
                );
            }
            return null;
        }
        return validate(props, propName, componentName, location);
    }

    const chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
}

/**
 * Validate that an instance of a model class was passed in. Can optionally limit to certain model types.
 */
export function modelInstance(modelIds) {
    return createChainableTypeChecker((props, propName) => {
        const value = props[propName];
        if (isModelInstance(value)) {
            const modelId = value._meta.modelId;
            if (modelIds && !Array.isArray(modelIds)) {
                modelIds = [modelIds];
            }
            if (modelIds && modelIds.length > 0 && !modelIds.includes(modelId)) {
                if (modelIds.length > 1) {
                    return new Error(
                        `Expected an instance of one of '${modelIds.join(
                            ', '
                        )}' but instead received '${modelId}'`
                    );
                }
                return new Error(
                    `Expected an instance of '${modelIds[0]}' but instead received '${modelId}'`
                );
            }
            return;
        }
        if (isPlainObject(value)) {
            return new Error(
                'Expected an instance of a model class but received a plain object instead.'
            );
        }
        if (isModelClass(value)) {
            return new Error('Expected a model instance but received a class instead');
        }
        if (!isObjectLike(value)) {
            return new Error(`Expected a model instance but received: ${value}`);
        }
        if (value.constructor) {
            return new Error(
                `Expected a model instance but received an instance of '${
                    value.constructor.name
                }' instead`
            );
        }
        return new Error(
            'Expected a model instance but received but received an unknown object instead'
        );
    });
}

/**
 * Validate that a model class was passed in. Can optionally limit to certain model types.
 * @param modelIds
 * @param sitePropName
 * @returns {any}
 */
export function modelClass(modelIds, sitePropName = 'djradSite') {
    return createChainableTypeChecker((props, propName) => {
        let value = props[propName];
        if (typeof value == 'string') {
            const site = props[sitePropName];
            if (!site) {
                return new Error(
                    `When passing a string modelId the djrad site instance must be available in props. No site was found on prop ${sitePropName} - you can change prop used by passing a second parameter to 'modelClass'`
                );
            }
            const model = site.models.get(value);
            if (!model) {
                return new Error(
                    `Invalid model ID '${value}' passed. Known model id's are: ${[
                        ...site.models.keys(),
                    ].join(', ')}`
                );
            }
            value = model;
        }
        // This is either a model class or instance as they can be used interchangeably
        // (the reverse isn't true)
        if (isModelClass(value)) {
            const modelId = value._meta.modelId;
            if (modelIds && !Array.isArray(modelIds)) {
                modelIds = [modelIds];
            }
            if (modelIds && modelIds.length > 0 && !modelIds.includes(modelId)) {
                if (modelIds.length > 1) {
                    return new Error(
                        `Expected class for one of '${modelIds.join(
                            ', '
                        )}' but instead received '${modelId}'`
                    );
                }
                return new Error(
                    `Expected class for '${modelIds[0]}' but instead received '${modelId}'`
                );
            }
            return;
        }
        if (isPlainObject(value)) {
            return new Error('Expected a model class but received a plain object instead.');
        }
        if (!isObjectLike(value)) {
            return new Error(`Expected a model class but received: ${value}`);
        }
        if (value.constructor) {
            return new Error(
                `Expected a model class but received an instance of '${
                    value.constructor.name
                }' instead`
            );
        }
        return new Error(
            'Expected a model class but received but received an unknown object instead'
        );
    });
}

/**
 * Check a prop is a valid field name for a particular model
 * @param modelPropName {String|Object} Either a string that identifies another prop on the component that contains
 * the model or a function that receives all props and returns the model
 * @param sitePropName {String} Optionally specify djradSite prop to use to extract models when model is passed
 * as a string rather than class instance.
 */
export function modelFieldName(modelPropName, sitePropName = 'djradSite') {
    return createChainableTypeChecker((props, propName) => {
        const fieldName = props[propName];
        let model =
            typeof modelPropName == 'function' ? modelPropName(props) : props[modelPropName];
        if (typeof model == 'string') {
            const site = props[sitePropName];
            if (!site) {
                return new Error(
                    `When passing a string modelId the djrad site instance must be available in props. No site was found on prop ${sitePropName} - you can change prop used by passing a second parameter to 'modelClass'`
                );
            }
            const m = site.models.get(model);
            if (!m) {
                return new Error(
                    `Invalid model ID '${model}' passed. Known model id's are: ${[
                        ...site.models.keys(),
                    ].join(', ')}`
                );
            }
            model = m;
        }
        if (isModelClass(model)) {
            if (!model._meta.fields[fieldName]) {
                const knownFields = model._meta.fieldNames.join(', ');
                return new Error(
                    `Invalid field '${fieldName}' for model ${
                        model._meta.modelId
                    }. Known fields are: ${knownFields}`
                );
            }
            return;
        }
        if (isPlainObject(model)) {
            return new Error(
                `Expected a model class or instance on prop ${modelPropName} but received a plain object instead.`
            );
        }
        if (!isObjectLike(model)) {
            return new Error(
                `Expected a model class or instance on prop ${modelPropName} but received: ${model}`
            );
        }
        return new Error(
            'Expected a model class or instance but received but received an unknown object instead'
        );
    });
}
