// @flow
import { Typed, typeOf } from 'typed-immutable';
import { useMemo } from 'react';
import { $modelDefinition, PARTIAL_FIELDS_KEY_FIELD_NAME } from 'alliance-redux-api/lib/Model';
import Immutable from 'immutable';

import { shallowEqual, useSelector } from 'react-redux';
import { isModelInstance } from '../model/Model';
import type { Model } from '../model/Model';
import useSite from './useSite';

type ModelData = {};

type RecordId = number | string;

type ResponseShape = {
    deletedEntities: { [modelId: string]: Array<RecordId> },
    entities: { [modelId: string]: { [RecordId]: ModelData } },
    result?: Array<RecordId> | RecordId,
    ids?: Array<RecordId>,
    entity: Model | Class<Model>,
    entityClass: Class<Model>,
};

type PaginatedResponseShape = ResponseShape & {
    count: Number,
    nextPage: ?Number,
    previousPage: ?Number,
    pageSize: Number,
    page: Number,
};

type EntityResponseReturn = {
    /**
     * When a single record is fetched (eg. using `getModel`) then the current
     * record from redux is returned here.
     */
    record: ?Model,
    /**
     * When multiple records are fetched (eg. using `listModel`) then the current
     * list of records from redux is returned here (as an Immutable list)
     */
    records: ?Immutable.List<Model>,
    /**
     * If extra model data is returned from the backend then the current records
     * from redux will be returned in this object indexed by the model id. Note
     * that the data returned in `record` or `records` is not included here - this
     * only contains any data in addition.
     *
     * The value for each object key is always an Immutable list even if a single
     * value was returned from the backend.
     */
    recordsByModelId: {
        [modelId: string]: Immutable.List<Model>,
    },
    /**
     * Any extra data returned from the backend returned verbatim here.
     */
    extraData: Object,
};

// These keys are used by alliance-redux-api - any other keys can be used in API
// responses for other data that is just passed straight through.
const reservedResponseKeys = [
    'deletedEntities',
    'entities',
    'result',
    'ids',
    'entityClass',
    'count',
    'nextPage',
    'previousPage',
    'pageSize',
    'page',
    'record',
    'paginated',
];

/**
 * Comparison function passed to useSelector to compare the values of selector
 * to see whether re-render is required.
 *
 * We need a custom comparison function as we return objects from our selectors
 * that are new every time. Specifically:
 * - recordsByModelIdSame is an object created each time, but within that the
 *   values maintain identity. We can shallow compare this object
 * - records is a new List created each time but it's values are the same so we
 *   can use ImmutableJS .equals() to do the comparison
 * - record should pass strict equality as it's the same record instance each time...
 *   however it seems this occasionally isn't true for some reason. Seems to be
 *   something in the bowels of alliance-redux-api that causes it (maybe?) but
 *   can't work it out; equality check using immutablejs equals catches it
 * @param prev Previous selected value
 * @param next Next selected value
 * @returns {boolean|*} If true values are same and useSelector won't force a rerender
 */
function selectorValuesEqual(prev, next) {
    const recordsSame =
        prev.records === next.records ||
        (prev.records && next.records && prev.records.equals(next.records));
    const recordSame =
        prev.record === next.record ||
        (prev.record && next.record && prev.record.equals(next.record));
    const recordsByModelIdSame = shallowEqual(prev.recordsByModelId, next.recordsByModelId);
    return recordsSame && recordSame && recordsByModelIdSame;
}

/**
 * Takes a standard response from the backend and connects to redux
 *
 * This means the record data fetched from the backend is always served
 * from redux and so always reflects the latest version rather than the
 * data at the point in time it was returned. It also gives you access
 * to the data as the underlying record class instances rather than the
 * raw object returned by API calls.
 *
 * This works with the response given from any of the data fetching functions:
 * `getModel`, `listModel`, `customListRoute`, `customDetailRoute`.
 *
 * When using the `useGetModel` or `useListModel` hooks this is used automatically
 * and the data provided as part of the standard hook return.
 *
 * @param response The response as returned from any of the data fetching actions
 */
export default function useEntityResponse(
    response?: ResponseShape | PaginatedResponseShape | Model
): EntityResponseReturn {
    if (response && !response.entities && !isModelInstance(response)) {
        throw new Error(`${response} does not look like a DjradEntityResponse value`);
    }

    const site = useSite();
    // We generate the required selectors only when the response object changes
    const cachedSelectors = useMemo(() => {
        if (!response) {
            return {};
        }
        if (isModelInstance(response)) {
            const modelClass = response.constructor;
            const { [PARTIAL_FIELDS_KEY_FIELD_NAME]: partialRecordFieldNames } = response;
            if (partialRecordFieldNames) {
                return {
                    selectRecord: state =>
                        modelClass.selectors.partialFields
                            .synced(state)(partialRecordFieldNames)
                            .get(response.getId()),
                };
            }
            return {
                selectRecord: state => modelClass.selectors.synced(state).get(response.getId()),
            };
        }
        let { entities } = response;
        if (response.paginated && Immutable.List.isList(response.entities)) {
            // Paginated responses set entities to the list of records if it's a
            // 'flat' paginated response
            const modelClass = site.getModelClass(response.entityClass);
            entities = {
                [modelClass._meta.modelId]: response.entities
                    .groupBy(entity => entity.getId())
                    .toJS(),
            };
        }
        let selectRecord = null;
        let selectRecords = null;
        const idOrIds = response.result || response.ids;
        let resultModel;
        if (!response.entityClass) {
            const entityIds = Object.keys(response.entities);
            if (entityIds.length !== 1) {
                throw new Error(
                    "Can't determine model type if multiple entities exist and entityClass not provided"
                );
            }
            resultModel = site.getModelClass(entityIds[0]);
        } else {
            resultModel = site.getModelClass(response.entityClass);
        }
        if (idOrIds) {
            let selectResultRecords = state => resultModel.selectors.synced(state);
            if (response.entities.size > 0) {
                const {
                    [PARTIAL_FIELDS_KEY_FIELD_NAME]: partialRecordFieldNames,
                } = response.entities.first();
                if (partialRecordFieldNames) {
                    selectResultRecords = state =>
                        resultModel.selectors.partialFields.synced(state)(partialRecordFieldNames);
                }
            }
            if (Array.isArray(idOrIds)) {
                selectRecords = state => {
                    const allRecords = selectResultRecords(state);
                    return Immutable.List(idOrIds.map(id => allRecords.get(id)).filter(Boolean));
                };
            } else {
                selectRecord = state => {
                    const allRecords = selectResultRecords(state);
                    return allRecords.get(idOrIds);
                };
            }
        }
        let selectRecordsByModelId = {};
        // A plain list response returns the entities as an immutable list rather than
        // an object indexed by model ID. In that case we can ignore it - the records
        // themselves are returned on the 'records' key.
        if (!Immutable.List.isList(entities)) {
            selectRecordsByModelId = Object.entries(entities).reduce((acc, [modelId, values]) => {
                let ids = isModelInstance(values) ? [values.getId()] : Object.keys(values);
                if (modelId === resultModel._meta.modelId && idOrIds) {
                    // Exclude any records that are part of the main `records` response
                    const { IdType } = resultModel[$modelDefinition];
                    // This ensures type matches in filter below
                    const convertId = id => typeOf(IdType)[Typed.read](id);
                    const resultModelRecordIds = (Array.isArray(idOrIds) ? idOrIds : [idOrIds]).map(
                        convertId
                    );
                    ids = ids.map(convertId).filter(id => !resultModelRecordIds.includes(id));
                }
                if (ids.length === 0) {
                    return acc;
                }
                const model = site.getModelClass(modelId);
                acc[model._meta.modelId] = state => {
                    const allRecords = model.selectors.synced(state);
                    const _records = ids.map(id => allRecords.get(id));
                    return Immutable.List(_records);
                };
                return acc;
            }, {});
        }
        return {
            selectRecord,
            selectRecords,
            selectRecordsByModelId,
        };
    }, [response, site]);
    // The selector itself runs every time but just uses the cached selectors
    const selectedData = useSelector(state => {
        if (!response) {
            return {
                record: null,
                records: null,
                recordsByModelId: null,
            };
        }
        let record = null;
        let records = null;
        let recordsByModelId = {};
        if (cachedSelectors.selectRecord) {
            record = cachedSelectors.selectRecord(state);
        }
        if (cachedSelectors.selectRecords) {
            records = cachedSelectors.selectRecords(state);
        }
        if (cachedSelectors.selectRecordsByModelId) {
            recordsByModelId = Object.entries(cachedSelectors.selectRecordsByModelId).reduce(
                (acc, [modelId, selector]) => {
                    acc[modelId] = selector(state);
                    return acc;
                },
                {}
            );
        }
        return {
            record,
            records,
            recordsByModelId,
        };
    }, selectorValuesEqual);

    const pagination = useMemo(() => {
        if (!response || !response.paginated) {
            return false;
        }
        return {
            total: response.count,
            nextPage: response.nextPage,
            previousPage: response.previousPage,
            pageSize: response.pageSize ? Number(response.pageSize) : null,
            current: response.page ? Number(response.page) : null,
        };
    }, [response]);
    const extraData = useMemo(() => {
        if (!response) {
            return null;
        }
        if (isModelInstance(response)) {
            return {};
        }
        return Object.keys(response)
            .filter(key => !reservedResponseKeys.includes(key))
            .reduce((acc, key) => {
                acc[key] = response[key];
                return acc;
            }, {});
    }, [response]);
    return {
        ...selectedData,
        deletedEntities: response ? response.deletedEntities || {} : null,
        pagination,
        extraData,
    };
}
