// @flow
import { useMemo, useDebugValue } from 'react';
import isPlainObject from 'lodash/isPlainObject';
import { getModel } from '../actions';
import type { Model } from '../model/Model';
import type { ModelId } from '../model/types';
import type { Action } from '../types/action';
import useAsyncRedux from './useAsyncRedux';
import useEntityResponse from './useEntityResponse';
import useModelClass from './useModelClass';

const { DEEP, MANUAL } = useAsyncRedux;

type Options = {
    /**
     * The action to use for the API call. Defaults to [getModel](/api/js/actions/#getModel).
     */
    action?: (
        modelClass: Class<Model>,
        id: string | number | Object,
        options: Object,
        meta?: Object
    ) => Action,
    /**
     * Determines when the function is called. Defaults to `DEEP`.
     *
     * **NOTE**: If changing from MANUAL then the function will be called immediately regardless
     *
     * **useGetModel.MANUAL** - only called when you explicitly call `run`
     *
     * **useGetModel.DEEP (default)** - called whenever a deep equality check fails. Compares previous function, and
     * `option.args`. Passing a function defined inline with this option will result in an infinite loop; use `useCallback` in
     * those cases.
     */
    trigger?: typeof MANUAL | typeof DEEP,
    /**
     * Redux action meta param to pass through to getModel.
     */
    actionMeta?: {},
    /**
     * Set this to true to batch this call up with any other batched API calls
     * that happen in the same frame. This is useful where it's easier to write
     * a component such that the data is fetched on each item rather than doing
     * it upfront and splitting out the results. When this option is true only
     * a single API call is done for all batched actions.
     *
     * The network call will appear to the 'batch-api' endpoint which can make
     * it difficult to see the details for each call. You can use the djrad
     * devtools to workaround this - it will show you each individual call and
     * its response.
     */
    batchCall?: boolean,
    /**
     * The list of field names you wish to fetch from the backend. Only these
     * values will be returned. Note that the serializer can specify fields to
     * _always_ include using `get_pinned_fields` regardless of what you
     * specify here. This  defaults to `__str__` and `id`.
     *
     * When this option is used the returned record is a partial record instance.
     *
     * If you specify a custom action this option is only valid if that action
     * supports it.
     */
    partialRecordFieldNames?: Array<string>,
    /**
     * Options to pass through to the specified action. See [getModel](/api/js/actions/#getModel)
     * for the available options when using the default action.
     */
    actionOptions?: Object,
    /**
     * Called when action resolves successfully. Is passed a single parameter which
     * is the response from the async action.
     *
     * If you just need access to the record you don't need to specify this; just
     * use the returned `record`.
     *
     * **NOTE:** If your component unmounts before the promise resolves this function
     * will NOT be called. This is to avoid the general case of calling React
     * state transition functions on an unmounted component. If you want the
     * method to be called regardless then attach your own callbacks to the
     * promise when you call `run` or in the async function definition itself.
     */
    onSuccess?: (response: Object) => void,
    /**
     * Called when action errors. Passed the error returned from async action.
     *
     * See note above on `onSuccess` for behaviour when component has unmounted.
     */
    onError?: (error: Error) => void,
};

type UseGetModelReturn = {
    /**
     * The single record fetched. Only one of `error` and `record` can be set.
     * This is always pulled from redux so any changes there will be reflected
     * here. If `isLoading` is true consider this as stale (ie. based on
     * _previous_ props). This can be useful when you want the UI to show the
     * previous value until the next value is ready (for example showing one
     * record with a loading indicator while next record is loading).
     */
    record: ?Model,
    /**
     * True while API call is in progress
     */
    isLoading: boolean,
    /**
     * If API call responds with a non-2XX response the error will be returned here.
     * Only one of `error` and `record` can be set. If `isLoading` is true
     * consider this as stale (ie. based on _previous_ props). This can be useful
     * when you want the UI to show the previous value until the next value is ready.
     */
    error: ?Error,
    /**
     * A function to manually trigger the action. If `options.trigger` is `useGetModel.MANUAL`
     * calling this function is the only way to trigger the action. You can pass
     * arguments to `run` which will override the defaults. If no arguments are passed then
     * `options.args` will be passed by default (if supplied).
     *
     * This function will return a promise that resolves to the fetched record
     */
    run: (...args: Array<any>) => Promise<any>,
    /**
     * When called will set record or error to null.
     */
    reset: () => void,
    /**
     * If extra model data is returned from the backend then the current records
     * from redux will be returned in this object indexed by the model id. Note
     * that the data returned in `record` is not included here - this
     * only contains any data in addition to these.
     *
     * The value for each object key is always an Immutable list even if a single
     * value was returned from the backend.
     *
     * See [DjradEntityResponse](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how to return extra data.
     */
    recordsByModelId: {
        [modelId: string]: Immutable.List<Model>,
    },
    /**
     * Any extra data returned from the backend returned verbatim here.
     *
     * See [DjradEntityResponse `data` prop](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how this is returned.
     */
    extraData: Object,
    /**
     * An object mapping model ID to the id's of any records that were deleted as
     * part of this API call.
     *
     * See [DjradEntityResponse `deleted_entities` prop](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how this is returned.
     */
    deletedEntities: { [modelId: string]: Array<RecordId> },
};

const validOptionKeys = [
    'action',
    'trigger',
    'batchCall',
    'actionOptions',
    'partialRecordFieldNames',
    'onSuccess',
    'onError',
    'actionMeta',
];

/**
 * Fetches a record from the backend using [getModel](/api/js/actions/#getModel)
 * either immediately (`options.trigger` = `useGetModel.DEEP`) or when `run` is
 * called (`options.trigger` = `useGetModel.MANUAL`). `SHALLOW` is not a valid option.
 * The record returned is always the latest version of the record in the redux state
 * eg. if the record is changed in redux somewhere else your component will re-render
 * and have access to the latest version.
 *
 * @param {Model|ModelId|Class<Model>} model Either a model class, instance or model id that
 * identifies the model type to fetch from the backend
 * @param {String|Number|Object} id either the id of the record to fetch or a filter object
 * that should result in a single record being returned. This is useful when you
 * have a unique constraint on a record that you want to use to identify a record.
 * When the filter object is passed the API call is to the list view and passes
 * the filter as query parameters. For example if you pass `{ userId: 5, projectId: 2 }`
 * you might get:
 * ```
 * /api/users/?userId=5&projectId2
 * ```
 * Your backend must handle those query parameters such that a single record is returned.
 * If multiple records are returned an `ApiError` will be raised with a status of 400.
 * @param {Object } options @expand
 *
 * @example
 *
 * ```jslive
 * function UserView({ id }) {
 *     const { record, isLoading, error } = useGetModel(UserModel, id);
 *     if (isLoading) return null;
 *     if (error) {
 *         return <Alert type="error" message={error.message} />;
 *     }
 *     return (
 *         <DetailGridView
 *             record={record}
 *             fields={['firstName', 'lastName', 'email']}
 *             footer={null}
 *         />
 *     );
 * }
 *
 * <UserView id={testData.userId} />
 * ```
 */
export default function useGetModel(
    model: Model | ModelId | Class<Model>,
    id: string | number | Object,
    options?: Options = {}
): UseGetModelReturn {
    const modelClass = useModelClass(model);
    const {
        actionMeta,
        trigger = useAsyncRedux.DEEP,
        action = getModel,
        batchCall = false,
        actionOptions = {},
        partialRecordFieldNames,
        onSuccess,
        onError,
    } = options;

    // =========================================================================
    // Validate parameters
    const invalidOptionKeys = Object.keys(options).filter(key => !validOptionKeys.includes(key));
    if (invalidOptionKeys.length > 0) {
        throw new Error(
            `Invalid options specified: ${invalidOptionKeys.join(
                ', '
            )}. Valid options are: ${validOptionKeys.join(', ')}`
        );
    }
    if (options && !isPlainObject(options)) {
        throw new Error(`Options must be an object, received ${options}`);
    }
    if (![MANUAL, DEEP].includes(trigger)) {
        throw new Error(`Invalid trigger ${trigger}. Must be one of ${MANUAL} or ${DEEP}.`);
    }
    // =========================================================================

    // ID can be a string/number OR it can be an object representing a filter that
    // should return a single record (eg. from a unique constraint).
    // We ignore the response from useAsyncRedux - it's the record we fetched. Instead
    // we extract the record from redux so it's always in sync with what's in redux
    const { response, isLoading, error, run, reset } = useAsyncRedux(action, {
        args: [
            modelClass,
            id,
            { partialRecordFieldNames, ...actionOptions },
            { ...actionMeta, batchCall },
        ],
        trigger,
        onSuccess,
        onError,
    });

    const { record, extraData, deletedEntities, recordsByModelId } = useEntityResponse(response);
    useDebugValue({ modelClass, id }, debugValue => {
        let debugId = debugValue.id;
        if (debugId && typeof debugId == 'object') {
            debugId = Object.entries(debugId)
                .map(([key, value]) => `${key}=${value}`)
                .join(', ');
        }
        return `${debugValue.modelClass._meta.modelId}(${debugId})`;
    });
    return useMemo(
        () => ({
            record,
            extraData,
            deletedEntities,
            recordsByModelId,
            isLoading,
            error,
            reset,
            run,
        }),
        [record, extraData, deletedEntities, recordsByModelId, isLoading, error, reset, run]
    );
}

useGetModel.MANUAL = useAsyncRedux.MANUAL;
useGetModel.DEEP = useAsyncRedux.DEEP;
