// @flow
import { useEffect, useState, useRef } from 'react';
import fromPairs from 'lodash/fromPairs';
import isEqual from 'lodash/isEqual';
import type { PermissionDescriptor } from '../permissions/PermissionChecker';
import useSite from './useSite';

const initMap = (keys, value, defaults = {}) =>
    keys.reduce((acc, key) => {
        acc[key] = key in defaults ? defaults[key] : value;
        return acc;
    }, {});

type CheckReturn = {
    /**
     * True while permission checks occur
     */
    isLoading: boolean,
    /**
     * A map of permission label to a boolean. Value will be null while that permission check is pending.
     */
    perms: { [PermLabel: string]: boolean },
};

/**
 * Check 1 or more permissions
 *
 * Accepts a single object where the key is some label for a permission check (eg. userDetail, userList etc)
 * and the value is either:
 * - A permission string, eg. my_app.user_list
 * - A list of permission strings, eg. ['my_app.user_list', 'my_app.userprofile_list'] (user must have _all_ perms for success)
 * - An object for an action permission { action: 'detail', record: user } or { action: 'list', model: User }
 * - An object for a record permission { perm: 'my_app.user_detail', record: user } or { perm: 'my_app.user_list', model: user }
 *   - This is the equivalent of checking the action perm; actions just translate from a name (eg. list) to the
 *     underlying permission (my_app.user_list)
 *
 * @example
 * ```js
 * function UserView({ user }) {
 *      const { isLoading, perms } = useCheckPermissions({
 *          update: { action: 'update', record: user },
 *          delete: { action: 'delete', record: user },
 *          masquerade: 'is_superuser',
 *      });
 *      if (isLoading) {
 *          return null;
 *      }
 *
 *      return (
 *          <>
 *              <UserDetails user={user} />
 *              {perms.update && <UpdateButton record={user} />}
 *              {perms.delete && <DeleteButton record={user} />}
 *              {perms.masquerade && <MasqueradeButton user={user} >}
 *          </>
 *      );
 * }
 * ```
 */
export default function useCheckPermissions(permissions: {
    [string]: PermissionDescriptor,
}): CheckReturn {
    const site = useSite();
    const { permissionChecker } = site;
    const [perms, setPerms] = useState(() => initMap(Object.keys(permissions), null));
    const [isLoading, setIsLoading] = useState(true);
    const prevPermissions = useRef();
    const promiseRef = useRef();
    const mountedRef = useRef(false);
    useEffect(() => {
        mountedRef.current = true;
        let changedPermissions = Object.entries(permissions);
        if (prevPermissions.current) {
            // This will run on every change of permissions (but not the initial one)
            // Here we identify which permission check details have changed which requires
            // us to identify which of the existing keys have changed, which ones no longer
            // exist, and which ones are removed
            // changedPermissions contains all new permissions and any ones that have changed
            // We use this to know whether to check any new permissions. If this is empty we
            // know we don't need to check any permissions and the only thing that can change
            // is removing existing permission checks (see setPerms below)
            changedPermissions = changedPermissions.filter(([index, permOrObj]) => {
                if (!prevPermissions.current[index]) {
                    return true;
                }
                return !isEqual(prevPermissions.current[index], permOrObj);
            });
            // If permissions have changed reset the changed ones to initial state (null)
            // and remove any checks that are no longer required
            setPerms(currentPerms => {
                const newKeys = Object.keys(permissions);
                // Optimisation; allow us to bail out of state change if nothing has actually changed. This prevents
                // unnecessary renders of the component. We already handle not doing unnecessary permission check
                // calls below - this just prevents us calling setPerms with a new object that is deeply equal to
                // the previous version.
                // Things that cause diff:
                // 1. Passing a different permission descriptor on the same key (checked in changedPermissions)
                // 2. Passing a different key (checked in changedPermissions)
                // 3. Not passing some keys that were previously passed (check length of keys)
                const hasChanged =
                    changedPermissions.length > 0 ||
                    newKeys.length !== Object.keys(currentPerms).length;
                if (!hasChanged) {
                    return currentPerms;
                }
                // Create nextPerms retaining existing values if they are still in
                // the new 'permissions' prop otherwise set to null for new checks.
                const nextPerms = initMap(Object.keys(permissions), null, currentPerms);
                for (const [index] of changedPermissions) {
                    nextPerms[index] = null;
                }
                return nextPerms;
            });
        }
        prevPermissions.current = permissions;
        if (changedPermissions.length > 0) {
            setIsLoading(true);
            promiseRef.current = Promise.all(
                changedPermissions.map(async ([index, permOrObj]) => [
                    index,
                    await permissionChecker.check(permOrObj),
                ])
            ).then(entries => {
                if (mountedRef.current) {
                    // Merge checked permissions with current perm state. Any permissions no longer
                    // required have already been removed in the earlier setPerms called.
                    setPerms(currentPerms => ({ ...currentPerms, ...fromPairs(entries) }));
                    setIsLoading(false);
                }
            });
        }

        return () => {
            // When component is unmounted track this so we can avoid doing any setStates
            // It would be ideal to abort the specific promise but it's more work than it's
            // worth. Note that we set this to true when the effect runs to handle the case
            // where permissions changes and so the effect re-runs.
            mountedRef.current = false;
        };
    }, [permissionChecker, permissions, site]);

    return { isLoading, perms };
}
