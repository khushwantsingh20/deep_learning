// @flow
import { Collection } from 'immutable';
import { useEffect, useRef } from 'react';

export const ADD = 'ADD';
export const UPDATE = 'UPDATE';
export const DELETE = 'DELETE';

type Options = {
    /**
     * If true then when any records are added it will call `run` with 'ADD'
     * as the first parameter.
     */
    runOnAdd: boolean,
    /**
     * If true then when any records are deleted it will call `run` with 'DELETE'
     * as the first parameter.
     */
    runOnDelete: boolean,
    /**
     * If true then when any records are updated it will call `run` with 'UPDATE'
     * as the first parameter.
     */
    runOnUpdate: boolean,
    /** If true will pass through diff object to `run` on second parameter */
    includeDiff: boolean,
};

/**
 * Run an effect after a collection of records changes.
 *
 * This works by monitoring the collection of records passed in itself - it does
 * _not_ listen for actions in redux itself. As such make sure you only pass in
 * collections that come from a `connect` or `useSelector` call. If you pass in
 * a list of records that are cached on your component then no changes will be
 * detected.
 *
 * @param records The records to monitor for changes. This should come from a
 * a usage of `useSelector`, a manually `connect`ed component or something that
 * returns one of these (eg. `[useListModel](/api/js/hooks#useListModel`)
 * @param run The function to call when `records` changes. The first parameter
 * will be one of 'ADD', 'UPDATE' or 'DELETE' depending on the change. If
 * `options.includeDiff` is true then the second parameter will also be passed
 * which will be an object describing the change. The object looks like:
 *
 * ```
 * {
 *     // Previous version of `records`
 *     previous: ...
 *     // The record(s) updated
 *     updated: ...,
 *     // The record(s) deleted
 *     deleted: ...,
 *     // The record(s) added
 *     added: ...,
 * }
 * ```
 *
 * One of `updated`, `deleted` or `added` will be set depending on the type
 * of change.
 * @param options @expand
 * @return Has no return value
 */
export default function useModelChangeEffect(
    records: Collection,
    run: (changeType: ADD | UPDATE | DELETE, diff: Collection) => void,
    options: Options = {}
): void {
    const {
        runOnAdd = true,
        runOnDelete = true,
        runOnUpdate = true,
        includeDiff = false,
    } = options;
    const lastAllRecords = useRef(null);
    // This effect handles calling action again if an update, delete or addition happens to
    // the model we are dealing with.
    useEffect(() => {
        if (!lastAllRecords.current) {
            lastAllRecords.current = records;
            return;
        }
        if (records && lastAllRecords.current.size < records.size) {
            if (runOnAdd) {
                if (includeDiff) {
                    const diff = records.filter(record => !lastAllRecords.current.includes(record));
                    run(ADD, {
                        previous: lastAllRecords.current,
                        added: diff,
                    });
                } else {
                    run(ADD);
                }
            }
        } else if (records && lastAllRecords.current.size > records.size) {
            if (runOnDelete) {
                if (includeDiff) {
                    const diff = lastAllRecords.current.filter(record => !records.includes(record));
                    run(DELETE, {
                        previous: lastAllRecords.current,
                        deleted: diff,
                    });
                } else {
                    run(DELETE);
                }
            }
        } else if (records && runOnUpdate && !lastAllRecords.current.equals(records)) {
            if (includeDiff) {
                const lastRecordsById = lastAllRecords.current
                    .toList()
                    .groupBy(record => record.getId())
                    .map(r => r.first());
                const diff = records.filter(
                    record => !record.equals(lastRecordsById.get(record.getId()))
                );
                run(UPDATE, {
                    previous: lastAllRecords.current,
                    updated: diff,
                });
            } else {
                run(UPDATE);
            }
        }
        lastAllRecords.current = records;
    }, [runOnAdd, runOnDelete, runOnUpdate, records, run, includeDiff]);
}
