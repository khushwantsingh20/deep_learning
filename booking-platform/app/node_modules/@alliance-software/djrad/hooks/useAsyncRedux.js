// @flow
import { useCallback } from 'react';
import { useDispatch } from 'react-redux';
import type { UseAsyncOptions, UseAsyncReturnObject } from './useAsync';
import useAsync from './useAsync';

/**
 * Hook to deal with triggering async redux actions and handling response / errors and loading states.
 *
 * Works with same options as [useAsync](/api/js/hooks/#useAsync) - please see
 * documentation for that hook for more details. The only difference is you
 * pass a redux action instead of a regular function.
 *
 * As a convenience you can access the trigger types on `useAsyncRedux` directly:
 * `useAsyncRedux.MANUAL`, `useAsyncRedux.DEEP` and `useAsyncRedux.SHALLOW`.
 *
 * @param action Any valid async redux function. Asynchronous redux actions are
 * supported with [redux-thunk](https://github.com/reduxjs/redux-thunk) internally.
 *
 * See the first example below for what an async action looks like.
 *
 * All the data fetching API actions in djrad are async (listModel, getModel
 * etc). See [/docs/api/js/actions/](action documentation) for more details.
 *
 * **NOTE:** When trigger is `DEEP` or `SHALLOW` you are responsible for making
 * sure `action` only changes when the  action needs to be fired again. This
 * means if you are passing an arrow function created in render you must memoize
 * it eg. use `useMemo`. Where possible pass arguments in `options.args`.
 *
 * @example for: action
 *
 * Defining a custom async function just means your action creator returns a
 * function that will be passed `dispatch` and `getState` and will in turn
 * return a promise. See [redux-thunk](https://github.com/reduxjs/redux-thunk)
 * for how these are handled internally.
 *
 * ```js
 * const myAsyncAction = dispatch => {
 *   // Can dispatch multiple times
 *   dispatch({ type: 'startCall' });
 *   // callApi is just some imaginary function that does an async API
 *   // call and returns a promise that resolves to the API response.
 *   return callApi().then(response => {
 *     // dispatch an action on success
 *     dispatch({
 *       type: 'success',
 *       payload: response,
 *     });
 *   });
 * }
 * ```
 *
 * @example for: action
 *
 * Use a deferred `modelDetailRoute` call that archives or unarchives a record
 *
 * ```js
 * function ArchiveLinkLink({ action, record }) {
 *    const endpoint = action === 'archive' ? 'archive' : 'unarchive';
 *    const { run, isLoading } = useAsyncRedux(
 *        () => modelDetailRoute('post', record, endpoint),
 *        {
 *            onError: () => message.error('There was a problem, please try again'),
 *        }
 *    );
 *    return (
 *        <Button loading={isLoading} onClick={run} type="link">
 *            {action === 'archive' ? 'Archive' : 'Unarchive'}
 *        </Button>
 *    );
 * }
 * ```
 *
 * @param options @expand
 */
export default function useAsyncRedux(
    action: (...args: Array<any>) => any,
    options: UseAsyncOptions
): UseAsyncReturnObject {
    const dispatch = useDispatch();
    const wrappedAction = useCallback((...args) => dispatch(action(...args)), [dispatch, action]);
    return useAsync(wrappedAction, options);
}
useAsyncRedux.MANUAL = useAsync.MANUAL;
useAsyncRedux.SHALLOW = useAsync.SHALLOW;
useAsyncRedux.DEEP = useAsync.DEEP;
