// @flow
import { useDebugValue, useMemo, useCallback } from 'react';
import isPlainObject from 'lodash/isPlainObject';
import { useSelector } from 'react-redux';
import { List } from 'immutable';
import useAsyncRedux from './useAsyncRedux';
import { listModel } from '../actions';
import type { Model } from '../model/Model';
import type { ModelId } from '../model/types';
import type { Action } from '../types/action';
import useEntityResponse from './useEntityResponse';
import useModelChangeEffect from './useModelChangeEffect';
import useModelClass from './useModelClass';
import useSettings from './useSettings';

const { DEEP, MANUAL } = useAsyncRedux;

type Options = {
    /**
     * Determines when the function is called. Defaults to `DEEP`.
     *
     * **NOTE**: If changing from MANUAL then the function will be called immediately regardless
     *
     * **useGetModel.MANUAL** - only called when you explicitly call `run`
     *
     * **useGetModel.DEEP (default)** - called whenever a deep equality check fails. Compares previous function,
     * filters and options. Passing a function defined inline with this option will
     * result in an infinite loop; use `useCallback` in such cases.
     */
    trigger?: typeof MANUAL | typeof DEEP,
    /**
     * Redux action meta to pass through to the specified action (eg. listModel).
     */
    actionMeta?: {},
    /**
     * Set this to true to batch this call up with any other batched API calls
     * that happen in the same frame. This is useful where it's easier to write
     * a component such that the data is fetched on each item rather than doing
     * it upfront and splitting out the results. When this option is true only
     * a single API call is done for all batched actions.
     *
     * The network call will appear to the 'batch-api' endpoint which can make
     * it difficult to see the details for each call. You can use the djrad
     * devtools to workaround this - it will show you each individual call and
     * its response.
     */
    batchCall?: boolean,
    /**
     * The list of field names you wish to fetch from the backend. Only these
     * values will be returned. Note that the serializer can specify fields to
     * _always_ include using `get_pinned_fields` regardless of what you
     * specify here. This  defaults to `__str__` and `id`.
     *
     * When this option is used the returned list of records are all partial
     * record instances.
     *
     * If you specify a custom action this option is only valid if that action
     * supports it.
     */
    partialRecordFieldNames?: Array<string>,
    /**
     * Options to pass through to the specified action. See [listModel](/api/js/actions/#listModel)
     * for the available options when using the default action.
     *
     * Note that `partialRecordFieldNames` can be passed as a top level option
     * due to how frequently it is required.
     */
    actionOptions?: Object,
    /**
     * This option controls when the hook will automatically refetch data. This
     * allows the data to be refreshed when a change is detected to the underlying
     * data. For instance if another component creates a new record then, when
     * 'add' is in `refetchOn` this component will refetch the data. This allows
     * you to avoid stale data on list views when things are changed elsewhere
     * in your app.
     *
     * This should be an array containing any of 'update', 'add', 'delete'. The
     * default is to refetch on any change.
     *
     * Set to `null` or an empty array to disable this behaviour.
     */
    refetchOn?: Array<'update' | 'add' | 'delete'>,
    /**
     * The action to use for the API call. Defaults to [listModel](/api/js/actions/#listModel).
     *
     * @example
     * ```js
     * // Hit an endpoint that returns a normal paginated response along with
     * // some stats (under the 'stats' key) using DjradEntityResponse.
     * function UserViewWithStats() {
     *   const listWithStats = (model, filters, options) => modelListRoute('get', model, 'list-with-stats', filters, options);
     *   const { isLoading, error, records, pagination, extraData } = useListModel(
     *      User,
     *      { pageSize: 5 },
     *      { action: listWithStats }
     *   );
     *   if (isLoading) {
     *     return null;
     *   }
     *   if (error) {
     *     return <StandardErrorResponse error={error} />
     *   }
     *   return (
     *     <>
     *       <UserStats stats={extraData.stats} />
     *       <UserList users={records} pagination={pagination} />
     *     </>
     *   );
     * }
     * ```
     *
     * @param modelClass The model we are fetching data for
     * @param filters The filters passed through to `useListModel`
     * @param options Any extra options passed through to the `useListModel` `options` param
     * @param meta The `actionMeta` object (if any) passed through to `useListModel`
     */
    action?: (modelClass: Class<Model>, filters: Object, options: Object, meta?: Object) => Action,
    /**
     * Called when action resolves successfully. Is passed a single parameter which
     * is the response from the async action.
     *
     * If you just need access to the records you don't need to specify this; just
     * use the returned `records` property.
     *
     * NOTE: If your component unmounts before the promise resolves this function
     * will NOT be called. This is to avoid the general case of calling React
     * state transition functions on an unmounted component. If you want the
     * method to be called regardless then attach your own callbacks to the
     * promise when you call `run` or in the async function definition itself.
     */
    onSuccess?: (response: Object) => void,
    /**
     * Called when action errors. Passed the error returned from async action.
     *
     * See note above on `onSuccess` for behaviour when component has unmounted.
     */
    onError?: (error: Error) => void,
};

type Pagination = {
    /** The total number of records available */
    total: number,
    /** The number of the next page (if any) */
    nextPage: ?number,
    /** The number of the previous page (if any) */
    previousPage: ?number,
    /** The page size used in the fetch */
    pageSize: number,
    /** The current page number used in the fetch */
    current: number,
};

type UseListModelReturn = {
    /**
     * This list of records fetched. This is always pulled from redux so any changes
     * there will be reflected here. Only one of `records` and `error` will be
     * set at a time. If `isLoading` is true consider this as stale (ie. based on
     * _previous_ props). This can be useful when you want the UI to show the
     * previous value until the next value is ready (for example showing previous
     * page of records with a loading indicator while the next page is loading).
     */
    records: ?List<Model>,
    /**
     * If response from backend was paginated pagination details will be returned
     * here otherwise will be set to `false`.
     *
     * Current page and page size is determined from the `page` and `pageSize` values
     * in the `filters` parameter. If not specified defaults to `1` and `20`. To
     * customise the default page size you can do this globally by passing
     * `defaultPageSize` to the `settings` object in [DjradProvider](/components/DjradProvider/#settings).
     */
    pagination: Pagination | false,
    /**
     * True while API call is in progress
     */
    isLoading: boolean,
    /**
     * If API call responds with a non-2XX response the error will be returned here.
     * Only one of `error` and `records` can be set. If `isLoading` is true
     * consider this as stale (ie. based on _previous_ props). This can be useful
     * when you want the UI to show the previous value until the next value is ready.
     */
    error: ?Error,
    /**
     * Function that will manually fire the API call. If `trigger` is set to `MANUAL`
     * this is te only way the API call is fired. When `trigger` is `DEEP` you can
     * use this to force a retry on an API call even if nothing has changed.
     */
    run?: () => Promise<{}, Error>,
    /**
     * If extra model data is returned from the backend then the current records
     * from redux will be returned in this object indexed by the model id. Note
     * that the data returned in `records` is not included here - this
     * only contains any data in addition to these.
     *
     * The value for each object key is always an Immutable list even if a single
     * value was returned from the backend.
     *
     * See [DjradEntityResponse](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how to return extra data.
     */
    recordsByModelId: {
        [modelId: string]: Immutable.List<Model>,
    },
    /**
     * Any extra data returned from the backend returned verbatim here.
     *
     * See [DjradEntityResponse `data` prop](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how this is returned.
     */
    extraData: Object,
    /**
     * An object mapping model ID to the id's of any records that were deleted as
     * part of this API call.
     *
     * See [DjradEntityResponse `deleted_entities` prop](/api/util/#djrad_rest.util.DjradEntityResponse)
     * for how this is returned.
     */
    deletedEntities: { [modelId: string]: Array<RecordId> },
};

const validOptionKeys = [
    'action',
    'trigger',
    'batchCall',
    'actionOptions',
    'partialRecordFieldNames',
    'onSuccess',
    'onError',
    'actionMeta',
    'refetchOn',
];

const validRefetchOnValues = ['delete', 'add', 'update'];

/**
 * Fetches records from the backend using [listModel](/api/js/actions/#listModel)
 * either immediately (`options.trigger` = `useListModel.DEEP`) or when `run` is
 * called (`options.trigger` = `useListModel.MANUAL`). `SHALLOW` is not a valid option.
 * The records returned are always the latest version of those records in the redux state
 * eg. if a record is changed in redux somewhere else your component will re-render
 * and have access to the latest version. Changes to any records in redux will reflect
 * straight away, but the list of which records are displayed will not automatically
 * change unless `refetchOn` is set (the defaults for this mean it _will_ trigger a
 * refetch if new records are added or removed from redux).
 *
 * When `options.trigger` is `useListModel.DEEP` any changes to `model`, `filters` or `options` will
 * result in the API call being fired again.
 *
 * @example
 *
 * Render a list of records and use the URL to store current pagination status.
 *
 * ```jslive
 * # OPTIONS: {"fakeBrowser": true}
 * function UserView() {
 *    const [pageState, setPageState] = useUrlQueryState({ page: 1, pageSize: 5 });
 *    const { records, isLoading, error, run: refetch, pagination, extraData } = useListModel(
 *        UserModel,
 *        pageState,
 *        {
 *            partialRecordFieldNames: ['email'],
 *        }
 *    );
 *    return (
 *        <ListTableView
 *            model={UserModel}
 *            loading={isLoading}
 *            data={records ? records.toArray() : []}
 *            columns={['email']}
 *            pagination={{
 *                ...pagination,
 *                onChange(page, pageSize) {
 *                    setPageState({ page, pageSize });
 *                },
 *            }}
 *        />
 *    );
 * }
 *
 * <UserView />
 * ```
 *
 * @param {Model|ModelId|Class<Model>} model Either a model class, instance or model id that
 * identifies the model type to fetch from the backend
 * @param {Object} filters Filters passed through in query params (if any)
 * @param {Object } options @expand
 */
export default function useListModel(
    model: Model | ModelId | Class<Model>,
    filters?: ?{},
    options?: Options = {}
): UseListModelReturn {
    const modelClass = useModelClass(model);
    const {
        actionMeta,
        trigger = DEEP,
        action = listModel,
        refetchOn = ['delete', 'add', 'update'],
        batchCall = false,
        actionOptions = {},
        partialRecordFieldNames,
        onSuccess,
        onError,
    } = options;
    const { defaultPageSize } = useSettings({ defaultPageSize: 20 });
    // =========================================================================
    // Validate parameters
    const invalidOptionKeys = Object.keys(options).filter(key => !validOptionKeys.includes(key));
    if (invalidOptionKeys.length > 0) {
        throw new Error(
            `Invalid options specified: ${invalidOptionKeys.join(
                ', '
            )}. Valid options are: ${validOptionKeys.join(', ')}`
        );
    }
    if (refetchOn) {
        if (!Array.isArray(refetchOn)) {
            throw new Error('refetchOn must be an array');
        }
        const invalidRefetchOn = refetchOn.filter(key => !validRefetchOnValues.includes(key));
        if (invalidRefetchOn.length > 0) {
            throw new Error(
                `Invalid refetchOn values specified: ${invalidRefetchOn.join(
                    ', '
                )}. Valid values are: ${validRefetchOnValues.join(', ')}`
            );
        }
    }
    if (options && !isPlainObject(options)) {
        throw new Error(`Options must be an object, received ${options}`);
    }
    if (![MANUAL, DEEP].includes(trigger)) {
        throw new Error(`Invalid trigger ${trigger}. Must be one of ${MANUAL} or ${DEEP}.`);
    }
    // =========================================================================

    const runOnUpdate = refetchOn && refetchOn.includes('update');
    const runOnAdd = refetchOn && refetchOn.includes('add');
    const runOnDelete = refetchOn && refetchOn.includes('delete');
    const defaultQueryParams = {
        pageSize: defaultPageSize,
        page: 1,
    };
    const finalQueryParams = {
        ...defaultQueryParams,
        ...filters,
    };

    // We ignore the response from useAsyncRedux - it's the records we fetched. Instead
    // we extract the records from redux so it's always in sync with what's in redux
    const actionStatus = useAsyncRedux(action, {
        args: [
            modelClass,
            finalQueryParams,
            { partialRecordFieldNames, ...actionOptions },
            { ...actionMeta, batchCall },
        ],
        trigger,
        onSuccess,
        onError,
    });
    const selectRecords = state => {
        // We do this as this could re-evaluate as soon as redux is updated - so
        // this could resolve the records and return it before useAsyncRedux updates
        // and returns the updated isLoading status. Doing this ensures they are
        // in sync and avoids an extra render.
        if (actionStatus.isLoading) {
            return null;
        }
        if (partialRecordFieldNames) {
            return modelClass.selectors.partialFields.synced(state)(partialRecordFieldNames);
        }
        return modelClass.selectors.synced(state);
    };
    const allRecords = useSelector(selectRecords) || null;
    const { run } = actionStatus;
    // Run with existing parameters; this is done when model data changes (eg. refetch on change/delete/update)
    const runDefault = useCallback(() => run(), [run]);
    useModelChangeEffect(allRecords, runDefault, { runOnAdd, runOnUpdate, runOnDelete });
    const { pagination, records, extraData, deletedEntities, recordsByModelId } = useEntityResponse(
        actionStatus.response
    );
    useDebugValue({ modelClass, filters }, debugValue => {
        const qp = debugValue.filters;
        if (qp) {
            const qpString = Object.entries(qp)
                .map(([key, value]) => `${key}=${value}`)
                .join(', ');
            return `${modelClass._meta.modelId}(${qpString})`;
        }
        return modelClass._meta.modelId;
    });
    return useMemo(() => {
        const { response, ...rest } = actionStatus;
        return {
            records,
            pagination,
            extraData,
            deletedEntities,
            recordsByModelId,
            ...rest,
        };
    }, [actionStatus, deletedEntities, extraData, pagination, records, recordsByModelId]);
}

useListModel.MANUAL = useAsyncRedux.MANUAL;
useListModel.DEEP = useAsyncRedux.DEEP;
