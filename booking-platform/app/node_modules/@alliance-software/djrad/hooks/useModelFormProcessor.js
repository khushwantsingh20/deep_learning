// @flow
import { useContext, useMemo, useCallback } from 'react';
import { ApiError } from 'redux-api-middleware';
import type { RouterHistory } from 'react-router-dom';
import { createModel, updateModel } from '../actions';
import { handleErrorResponse } from '../components/form';
import { SUBMISSION_ACTION_FIELD_NAME } from '../components/form/Form';
import { FORM_ACTIONS } from '../components/form/FormButton';
import type { Model } from '../model/Model';
import type { ModelId } from '../model/types';
import { ActionUrlContext } from '../site/components/context';
import type { getActionUrlType } from '../site/components/DjradProvider';
import type { BoundFormActions } from '../types/reduxFormBoundActions';
import useAsyncRedux from './useAsyncRedux';
import useElementFocus from './useElementFocus';
import useFormActions from './useFormActions';
import useModelClass from './useModelClass';
import useRouter from './useRouter';

type UpdateApiAction = (record: Model, data: {}) => Promise<*>;
type CreateApiAction = (model: Class<Model>, data: {}) => Promise<*>;
type OnSuccessArgs = {
    /**
     * Build an action URL. Prefer using this to model.getActionUrl directly as
     * it respects nested routing with [RelativeModelActionUrlProvider](/components/RelativeModelActionUrlProvider/)
     */
    getActionUrl: getActionUrlType,
    /**
     * The form action (if any). This comes from the action prop on the [FormButton](/components/FormButton/)
     * that triggered the submit.
     */
    submitAction: string,
    /**
     * The submitted form data
     */
    data: {},
    /**
     * The react-router history object. Use this to change URL with `history.push`
     * or `history.replace`
     */
    history: RouterHistory,
    /**
     * The original record (if any) before the submission took place.
     */
    originalRecord: Model,
    /**
     * The model class the submission was form.
     */
    model: Class<Model>,
    /**
     * The actions from https://redux-form.com/8.2.1/docs/api/actioncreators.md/
     * bound to redux dispatch and the current form. Call them without passing
     * the form name.
     *
     * eg. to reset the form
     *
     * ```js
     * formActions.reset()
     * ```
     */
    formActions: Object,
};

type RawRecordData = {};

type SuccessResponse = {
    /**
     * Raw record data as returned from endpoint. If the update returned multiple
     * records using [DjradEntityResponse](/api/util/#djrad_rest.util.DjradEntityResponse)
     * then the raw data (ie. not instances of the Model) is available here .
     */
    entities: { [modelId: ModelId]: { [recordId: string]: RawRecordData } },
    /**
     * The record instance that was updated / created
     */
    record: Model,
    /**
     * The ID of the record
     */
    result: string | number,
    /**
     * If [DjradEntityResponse](/api/util/#djrad_rest.util.DjradEntityResponse) is
     * used on the backend and included `deleted_entities` these will be available here
     * as a mapping from the model ID to an array of id's that were removed.
     */
    deletedEntities?: { [modelId: ModelId]: Array<string | number> },
};

type Options = {
    /**
     * The record the update is for. If not provided then `model` must be and
     * the submission is considered a create.
     */
    record?: Model,
    /**
     * The model the create is for. Can either be the model class or the model id.
     * Must be provided if `record` isn't. If `record` is provided this option
     * is ignored.
     */
    model?: Class<Model | ModelId>,
    /**
     * Function that will be called on success. It is passed the response
     * in the first argument and useful extra utilities in the second parameter.
     *
     * Note that if your backend returns extra data using [DjradEntityResponse](/api/util/#djrad_rest.util.DjradEntityResponse)
     * then each data extra key returned will be available in `response`.
     */
    onSuccess: (response: SuccessResponse, extra: OnSuccessArgs) => void,
    /**
     * Function that will be called on error. If not provided defaults to
     * [handleErrorResponse](/api/js/form-utils/#handleErrorResponse) which
     * handles standard response shapes and makes sure any errors end up in
     * the format redux-form expects to display them.
     */
    onError?: (error: Error | ApiError) => void,
    /**
     * The name of the form. If not specified defaults to `model._meta.modelId`
     * for create and `${model._meta.modelId}_${record.getId()}` for update.
     */
    formName?: string,
    /**
     * The API action to do the submissions. Defaults to [updateModel](/api/js/actions/#updateModel)
     * for update and [createModel](/api/js/actions/#createModel). You can pass
     * your own redux action creator here. It should accept two parameters - the
     * model and form data for create or the current record and the form data for
     * updates.
     */
    apiAction?: UpdateApiAction | CreateApiAction,
    /**
     * Function to transform the form data before passing it to apiAction. It is
     * passed the form data and the name of the action (if any) that triggered
     * the form submission (see [FormButton](/components/FormButton/) for more
     * info on form actions).
     */
    transformData?: (data: {}, submitAction: ?string) => {},
    /**
     * If true (the default) will focus on the first field that has errors on
     * a failed submission.
     */
    focusOnError?: boolean,
};

type ReturnObj = {
    /**
     * Form props to pass through to the [ModelForm](/components/ModelForm/)
     *
     * You would typically pass these straight through: `<ModelForm {...formProps} />`
     */
    formProps: {
        model: Class<Model>,
        record: Model,
        onSubmit: (data: {}) => Promise<SuccessResponse>,
        formName: string,
    },
    /**
     * Whether form is currently submitting
     */
    isSubmitting: boolean,
    /**
     * The response from the last submission (if any) if it was successful. Only
     * one of `submissionError` and `submissionResponse` will be set at a time.
     */
    submissionResponse: SuccessResponse,
    /**
     * The error from the last submission (if any) if it was un-successful. Only
     * one of `submissionError` and `submissionResponse` will be set at a time.
     */
    submissionError: Error | ApiError,
    /**
     * Actions that operate on the specified form
     *
     * See [redux-form Action Creators documentation](https://redux-form.com/8.2.1/docs/api/actioncreators.md/)
     * for details
     */
    formActions: BoundFormActions,
};

/**
 * Provides form props that include a submission function that either updates or
 * creates a record. Returns the current form submission status along with form
 * props to pass along to the form.
 *
 * This wraps up the logic and exposes the success/error callbacks and current state
 * and leaves it up to you how to render your form.
 *
 * By default the `onError` callback will handle standard responses such that the
 * errors appear in the form automatically. You often don't need to override this.
 *
 * You must provide the `onSuccess` callback.
 *
 * @example
 *
 * Show form in a modal but submit the form using the modal controls rather than
 * buttons inside the form itself.
 *
 * ```js
 * function UserModalForm({ user, onClose }) {
 *   const { isSubmitting, formActions, formProps } = useModelFormProcessor({
 *      record: user,
 *      onSuccess: () => onClose(),
 *  });
 *
 *   return (
 *       <Modal onOk={formActions.submit} onCancel={onClose} confirmLoading={isSubmitting}>
 *           <UserForm {...formProps} footer={null} />
 *       </Modal>
 *   );
 * }
 * ```
 *
 * @param {Options} options @expand
 */
export default function useModelFormProcessor(options: Options): ReturnObj {
    const {
        record,
        model,
        onSuccess,
        onError = handleErrorResponse,
        apiAction = record ? updateModel : createModel,
        // eslint-disable-next-line no-unused-vars
        transformData = (data, submitAction) => data,
        focusOnError = true,
    } = options;
    if (!record && !model) {
        throw new Error('You must provide either record or model');
    }
    if (!onSuccess) {
        throw new Error('You must pass the onSuccess callback');
    }
    let { formName } = options;
    const { history } = useRouter();
    const modelClass = useModelClass(record || model);
    if (!formName) {
        formName = modelClass._meta.modelId;
        if (record) {
            formName = `${formName}_${record.getId()}`;
        }
    }
    const { getActionUrl } = useContext(ActionUrlContext);

    const formActions = useFormActions(formName);

    const { run, error, response, isLoading: isSubmitting } = useAsyncRedux(apiAction);
    useElementFocus(error && focusOnError, { containerSelector: '.has-error' });

    const handleSubmit = useCallback(
        async (data: {}) => {
            const {
                [SUBMISSION_ACTION_FIELD_NAME]: submitAction = FORM_ACTIONS.SAVE,
                ...dataNoAction
            } = data;
            const finalData = transformData(dataNoAction, submitAction);
            const actionArgs = record ? [record, finalData] : [modelClass, finalData];
            try {
                const submissionResponse = await run(...actionArgs);

                onSuccess(submissionResponse, {
                    getActionUrl,
                    submitAction,
                    data: finalData,
                    history,
                    originalRecord: record,
                    model: modelClass,
                    formActions,
                });
            } catch (e) {
                onError(e);
            }
        },
        [
            formActions,
            getActionUrl,
            history,
            modelClass,
            onError,
            onSuccess,
            record,
            run,
            transformData,
        ]
    );

    const formProps = useMemo(
        () => ({
            model,
            record,
            onSubmit: handleSubmit,
            formName,
        }),
        [formName, handleSubmit, model, record]
    );

    return {
        formProps,
        isSubmitting,
        submissionResponse: response,
        submissionError: error,
        formActions,
    };
}
