// @flow
import {
    addEntity,
    deleteEntity,
    updateEntity,
    customDetailRoute,
    customListRoute,
    fetchEntity,
    fetchEntities,
} from 'alliance-redux-api';
import { List } from 'immutable';
import { API_CALL_REQUEST, get, patch, post, del } from 'alliance-redux-api/lib/api';
import { $modelDefinition } from 'alliance-redux-api/lib/Model';
import invariant from 'invariant';
import type { Model } from '../model/Model';
import { selectors } from '../site/reducers';
import type { Action } from '../types/action';
import { GET_MODEL_PERMISSIONS, GET_MODEL_DEFAULT_VALUES } from './actionTypes';
import batchAction from './batchAction';

const apiMethods = { get, patch, post, del, delete: del };

/**
 * Create a record on the backend and return it to the frontend.
 * @param {Model} entity The model class to create for
 * @extractdocs addEntity
 */
const createModel = addEntity;
/**
 * @extractdocs updateEntity
 */
const updateModel = updateEntity;
/**
 * @extractdocs deleteEntity
 */
const deleteModel = deleteEntity;
/**
 * @extractdocs fetchEntity
 */
const getModel = fetchEntity;
/**
 * @extractdocs fetchEntities
 */
const listModel = fetchEntities;

type HttpMethod = 'get' | 'post' | 'patch' | 'delete';

type CustomRouteOptions = {
    /**
     * Set this to true if your API endpoint does not return data in the shape expected
     * by djrad. You typically need to use this only when you are using a route against
     * a model to return completely custom data that doesn't need to be stored in redux.
     */
    hasCustomResponse?: boolean,
    /**
     * Any extra headers to pass through to the backend
     */
    headers?: Object,
    /**
     * Extra options to pass through to the
     * [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) call.
     */
    fetchOptions?: Object,
    /**
     * Set this to true to batch this call up with any other batched API calls
     * that happen in the same frame. This is useful where it's easier to write
     * a component such that the data is fetched on each item rather than doing
     * it upfront and splitting out the results. When this option is true only
     * a single API call is done for all batched actions.
     *
     * The network call will appear to the 'batch-api' endpoint which can make
     * it difficult to see the details for each call. You can use the djrad
     * devtools to workaround this - it will show you each individual call and
     * its response.
     */
    batchCall?: boolean,
};

/**
 * Perform a call to a custom route for a model. In the backend this is typically defined
 * using the DRF action.
 *
 * If you don't wish to return a normal model response pass `options.hasCustomResponse`.
 * This prevents any updates from automatically occurring in redux and the response is
 * return directly.
 *
 * @param method the HTTP method to call
 * @param record the record to call the API endpoint for. This is used to fill out the ID
 * in the URL. eg. If `routeName` is `activate` and the record has an id of 5 the URL might
 * be /api/user/5/activate/
 * @param routeName the name of the route to call, eg. 'activate'
 * @param data any data to pass through. Only applicable if method is 'POST' or 'PATCH'
 * @param {Object} options @expand
 *
 * @example
 * On your viewset define a custom endpoint
 *
 * ```python
 * ‌‌ @action(methods=['post'], detail=True)
 *  def toggle_activate(self, request, pk):
 *      record = self.get_object()
 *      ...
 *      return Response(self.get_serializer(record).data)
 * ```
 *
 * In javascript call modelDetailRoute on it
 *
 * ```js
 * function ActivateButton(props) {
 *     return (
 *         <Button onClick={() => props.modelDetailRoute('post', props.record, 'toggle_activate')}>
 *             Activate
 *         </Button>
 *     );
 * }
 * export default connect(null, { modelDetailRoute })(ActivateButton)
 * ```
 *
 * > **REMEMBER:** You must dispatch your actions with redux. You normally do this with the second parameter
 * > to `connect`. See the redux documentation for more details.
 *
 */
export function modelDetailRoute(
    method: HttpMethod,
    record: Model,
    routeName: string,
    data: ?{} = null,
    options: CustomRouteOptions = {}
): Action {
    if (options && options.hasCustomResponse) {
        const { endpoint } = record[$modelDefinition];
        const methodFn = apiMethods[method.toLowerCase()];
        invariant(
            methodFn,
            `${method} is not a valid method. Should be one of ${Object.keys(apiMethods).join(
                ', '
            )}`
        );
        const url = `${endpoint}/${record.getId()}/${routeName}/`;
        return methodFn(url, data, options);
    }
    return customDetailRoute(method, record, routeName, data, options);
}

/**
 * Perform a call to a custom route for a model. In the backend this is typically defined
 * using the DRF action.
 *
 * If you don't wish to return a normal model response pass `options.hasCustomResponse`.
 * This prevents any updates from automatically occurring in redux and the response is
 * return directly.
 *
 * @param method the HTTP method to call
 * @param model the model to call the API endpoint for. This is used to determine
 * the base endpoint to use.
 * @param routeName the name of the route to call, eg. 'bulk-delete'
 * @param data any data to pass through. Only applicable if method is 'POST' or 'PATCH'
 * @param {Object} options @expand
 *
 * > **REMEMBER:** You must dispatch your actions with redux. You normally do this with the second parameter
 * > to `connect`. See the redux documentation for more details.
 *
 * @example
 *
 * Define the endpoint on your viewset:
 *
 * $python$: questionnaire.djrad # djrad: bulk_publish
 *
 * In javascript call modelListRoute on it
 *
 * ```jslive
 *   function QuestionnaireList(props) {
 *    return (
 *      <ModelFetchList
 *        model="questionnaire.questionnaire"
 *        filter={{ pageSize: 5 }}
 *        refetchOn={[]}
 *      >
 *        {({ records }) => (
 *          <Form
 *            name="questionnaire"
 *            layout="horizontal"
 *            defaultLabelCol={{ span: 12 }}
 *            defaultWrapperCol={{ span: 12 }}
 *            initialValues={records.reduce((acc, record) => {
 *                acc[`record_${record.id}`] = record.published;
 *                return acc;
 *            }, {})}
 *            onSubmit={data =>
 *              props.modelListRoute(
 *                'post',
 *                QuestionnaireModel,
 *                'bulk_publish',
 *                Object.entries(data).reduce((acc, [name, checked]) => {
 *                    acc[name.replace('record_', '')] = checked;
 *                    return acc;
 *                }, {})
 *              )
 *            }
 *          >
 *            {records.map(record => (
 *              <Form.Item
 *                key={record.id}
 *                label={`${record.published ? '✅' : '❌' } ${record.name}`}
 *              >
 *                <Form.Field
 *                  name={`record_${record.id}`}
 *                  widget={<CheckboxWidget>Published?</CheckboxWidget>}
 *                />
 *              </Form.Item>
 *            ))}
 *            <Form.Button htmlType="submit">Save</Form.Button>
 *          </Form>
 *        )}
 *      </ModelFetchList>
 *    );
 *  }
 *   const ConnectedQuestionnaireList = connect(
 *   null,
 *   { modelListRoute }
 *   )(QuestionnaireList);
 *   <ConnectedQuestionnaireList />;
 * ```
 */
export function modelListRoute(
    method: HttpMethod,
    model: Class<Model>,
    routeName: string,
    data: ?{} = null,
    options: CustomRouteOptions = {}
) {
    if (options && options.hasCustomResponse) {
        const { endpoint } = model[$modelDefinition];
        const methodFn = apiMethods[method.toLowerCase()];
        invariant(
            methodFn,
            `${method} is not a valid method. Should be one of ${Object.keys(apiMethods).join(
                ', '
            )}`
        );
        const url = `${endpoint}/${routeName}/`;
        return methodFn(url, data, options);
    }
    return customListRoute(method, model, routeName, data, options);
}

/**
 * Get the permissions the current user has for a record.
 *
 * This is called if the permissions for a record are not known or incomplete. Permissions can
 * be incomplete if some permissions have been marked as [async on the model registration](/api/registration/#djrad_rest.registration.registration.ModelRegistration.async_permissions).
 * All non-async permissions are fetched automatically when a record is retrieved from the backend
 * so if the record has already been retrieved these will be available.
 *
 * These requests are batched so calling it multiple times in a single frame will only
 * result in a single API call that is optimised to do 1 query per model.
 *
 * > **NOTE**: You typically don't need to call this directly. Use [useCheckPermission](/api/js/hooks/#useCheckPermission),
 * [useCheckPermission](/api/js/hooks/#useCheckPermission) or the component [CheckPermission](/components/CheckPermission)
 * > or the [PermissionChecker](/api/js/permissions/#PermissionChecker) class instead (you can get this
 * > from your [Site](/api/js/site/#Site) record with `site.permissionChecker`.)
 *
 * @param model The model or record to get the permission for
 * @param id The id of the record to get the permission for
 */
export function getModelPermissions(
    model: Class<Model> | Model,
    id: string | number
): Promise<List<string>> {
    const options = {
        requestType: {
            type: API_CALL_REQUEST,
            meta: {
                // Slightly confusing but this batches the model-permissions API call using
                // batchApiMiddleware. So essentially we heard you like batches, so we put
                // a batch in your batch... ;)
                // eg. Multiple calls to model-permissions will be batched together using
                // batchAction and then the resulting API call will be batched with anything
                // else using the batchApiMiddleware. The reason we use batchAction at all
                // is to make the backend implementation faster - instead of processing 20
                // requests, each doing it's own DB queries to model-permissions we can do one
                // request resulting in a single DB query. batchAction optimises for backend
                // query performance, batchApiMiddleware optimises away the overhead of doing a
                // http request.
                batchCall: true,
            },
        },
        successType: GET_MODEL_PERMISSIONS,
    };
    return batchAction(
        GET_MODEL_PERMISSIONS,
        (batch = {}) => {
            if (!batch[model._meta.modelId]) {
                batch[model._meta.modelId] = [];
            }
            batch[model._meta.modelId].push(id);
            return batch;
        },
        batch => dispatch =>
            dispatch(post('/model-permissions/', batch, options)).then(response => {
                if (response.error) {
                    throw response.payload;
                }
                return response;
            }),
        (response, index, { getState }) => {
            const entityPermissions = selectors.entityPermissions(getState());
            return entityPermissions.getIn([model._meta.modelId, id]);
        }
    );
}

/**
 * These requests are batched so calling it multiple times in a single frame will only
 * result in a single API call.
 * @param model The model the field belongs to
 * @param fieldName The name of the field on the model to get the default value for
 * @returns {Promise}
 */
export function getModelDefaultValue(
    model: Class<Model>,
    fieldName: string
): Promise<List<string>> {
    const options = {
        requestType: {
            type: API_CALL_REQUEST,
            meta: {
                batchCall: true,
            },
        },
        successType: GET_MODEL_DEFAULT_VALUES,
    };
    return batchAction(
        GET_MODEL_DEFAULT_VALUES,
        // Add the item to the batch. The batch looks like:
        // {
        //    'myapp.modelid2': ['field1', 'field2'],
        //    'myapp.modelid2': ['field3', 'field4'],
        // }
        (batch = {}) => {
            if (!batch[model._meta.modelId]) {
                batch[model._meta.modelId] = [];
            }
            if (!batch[model._meta.modelId].includes(fieldName)) {
                batch[model._meta.modelId].push(fieldName);
            }
            return batch;
        },
        batch => dispatch =>
            dispatch(post('/default-values/', batch, options)).then(response => {
                if (response.error) {
                    throw response.payload;
                }
                return response;
            }),
        // The response payload looks like
        // {
        //    'myapp.modelid1': {
        //        'field1': 'value1',
        //        'field2': 'value2',
        //    },
        //    'myapp.modelid2': {
        //        'field3': 'value3',
        //        'field4': 'value4',
        //    }
        // }
        response => {
            const { payload } = response;
            const { modelId } = model._meta;
            return payload[modelId][fieldName];
        }
    );
}

export { createModel, updateModel, deleteModel, getModel, listModel };
