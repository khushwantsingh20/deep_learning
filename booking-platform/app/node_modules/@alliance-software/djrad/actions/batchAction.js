// @flow
import invariant from 'invariant';
import Immutable from 'immutable';
import type { Action } from '../types/action';
import type { Dispatch, GetState } from '../types/store';

type DispatchBatch = (batchData: any) => Action;
type BatchedAction = (response: any) => void;
type ResolveAction = (
    response: any,
    index: number,
    { dispatch: Dispatch, getState: GetState }
) => any;
type AddToBatch = (batchData: any) => any;

class ActionBatch {
    batchData: ?any;
    batchedActions: Array<BatchedAction>;
    delay: number;
    dispatchBatch: DispatchBatch;
    isPending: boolean;
    redux: {
        dispatch: Dispatch,
        getState: GetState,
    };

    constructor(
        dispatch: Dispatch,
        getState: GetState,
        dispatchBatch: DispatchBatch,
        delay: number = 0
    ) {
        this.redux = { dispatch, getState };
        this.batchData = undefined;
        this.isPending = false;
        this.dispatchBatch = dispatchBatch;
        this.batchedActions = [];
        this.delay = delay;
    }

    /**
     * Enqueue an action. The action is responsible for adding it's relevant data to the batch via the `addToBatch`
     * method. It is passed the current batch which will originally be undefined; it is responsible for setting the
     * default batch data value.
     * @param addToBatch Function to call to add the action to the batch
     * @param resolveAction Function to call once the batch has been dispatched
     * @returns {Promise<any>} Promise that resolves once the action has been resolved (ie. after resolveAction has
     * been called). Resolves to the value returned from resolveAction.
     */
    enqueueAction(addToBatch: AddToBatch, resolveAction: ResolveAction): Promise<any> {
        this.batchData = addToBatch(this.batchData);
        invariant(this.batchData, 'addToBatch should return some data for the batch');
        if (!this.isPending) {
            this.isPending = true;
            if (this.delay === 0) {
                requestAnimationFrame(() => this.dispatch());
            } else {
                setTimeout(() => this.dispatch(), this.delay);
            }
        }
        const index = this.batchedActions.length;
        return new Promise((resolve, reject) => {
            this.batchedActions.push(response => {
                try {
                    resolve(resolveAction(response, index, this.redux));
                } catch (e) {
                    reject(e);
                }
            });
        });
    }

    dispatch() {
        this.isPending = false;
        const { batchData, batchedActions } = this;
        this.batchData = undefined;
        this.batchedActions = [];
        Promise.resolve(this.redux.dispatch(this.dispatchBatch(batchData))).then(response => {
            batchedActions.forEach(resolveAction => resolveAction(response));
        });
    }
}

// We batch together items with same batchId and same dispatch function. This is to ensure
// that we only batch together actions that are being dispatched via the same redux store.
// This is mostly an issue when running tests where you may end up with multiple stores in
// tests but this is a global singleton.
const BatchKey = Immutable.Record({ dispatch: null, batchId: null });

let batches: Immutable.Map<BatchKey, ActionBatch> = Immutable.Map();

/**
 * Batch an action so that it is delayed and grouped with other similar actions
 *
 * @example
 * ```js
 *  function customAction(group, id) {
 *      return batchAction(
 *          // Batch actions with same group together
 *          `CUSTOM_ACTION.${group}`,
 *          // Batch this particular action. Note that 'batch' will be
 *          // undefined for the first call - you should set the default
 *          // to determine the structure for your batched data. Here we
 *          // maintain a list of ids.
 *          (batch = []) => {
 *              batch.push(id);
 *              return batch;
 *          },
 *          // To dispatch the batch we do an API call and pass through the
 *          // group and all the id's that have been batched
 *          batch => get('test-endpoint', { group, id: batch }),
 *          // When the API call dispatched above has resolved we need to
 *          // call resolve (or reject) for this action. We lookup the id
 *          // in the response.
 *          (response, resolve, reject, batchIndex) => {
 *              resolve({
 *                  ...response,
 *                  payload: response.payload[id],
 *              });
 *          }
 *      );
 *  }
 *
 *  dispatch(customAction(1, 1));
 *  // We get the single record back even though the API call returned
 *  // multiple objects (see below)
 *  // { id: 1, group: 1 }
 *  dispatch(customAction(1, 2));
 *  // { id: 2, group: 1 }
 *  dispatch(customAction(2, 1));
 *  // { id: 1, group: 2 }
 *
 *  // Results in 2 api calls (imagine the endpoint returned the objects
 *  // indexed by the id)
 *  // test-endpoint?group=1&id=1&id=2
 *  // {
 *  //     1: { id: 1, group: 1 },
 *  //     2: { id: 2, group: 1 },
 *  // }
 *  // test-endpoint?group=2&id=1
 *  // {
 *  //     1: { id: 1, group: 2 },
 *  // }
 *  ```
 *
 * @param batchId The ID to use to group actions. All batched actions with same batch ID are batched together.
 * @param addToBatch Function to call to batch the calling action
 * @param dispatchBatch Function to dispatch the whole batch. This function is cached upon the first call to batchAction
 * for a batchId so the function definition should not change based on parameters.
 * @param resolve Function to resolve the response from dispatchBatch
 * @param delay Delay, in ms, before batch is dispatched. Defaults to 0 which uses requestAnimationFrame. This becomes
 * part of the batch ID - calling batchAction for the same batchId with a different delay will create separate batches.
 * @returns Promise promise that resolves to the value for this action once the batch has been
 * dispatched. The value resolved to is determined by the `resolve` function.
 */
export default function batchAction(
    batchId: string,
    addToBatch: AddToBatch,
    dispatchBatch: DispatchBatch,
    resolve: ResolveAction,
    delay: number = 0
) {
    return (dispatch: Dispatch, getState: GetState) => {
        const key = new BatchKey({ dispatch, batchId: `${batchId}${delay}` });
        if (!batches.has(key)) {
            batches = batches.set(key, new ActionBatch(dispatch, getState, dispatchBatch, delay));
        }
        const batch = batches.get(key);
        return batch.enqueueAction(addToBatch, resolve);
    };
}
