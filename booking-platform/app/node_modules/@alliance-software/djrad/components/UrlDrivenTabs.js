// @flow
import * as React from 'react';
import { Tabs as AntTabs } from 'antd';
import { Route, withRouter } from 'react-router';
import type { Location, RouterHistory, Match } from 'react-router-dom';
import type { Model } from '../model/Model';
import injectSite from '../site/injectSite';
import Site from '../site/Site';

import { appendToUrl } from '../util/url';

const TabPane = AntTabs.TabPane;

type RenderNoMatchProps = {
    match: Match,
};

type RenderPaneProps = {
    match: Match,
    isActive: boolean,
};

type TabPaneProps = {
    /** @ignore */
    isActive: boolean,
    /** @ignore */
    match: Match,
    /** One of `children` or `renderPane` must be provided */
    children?: React.Element<*>,
    /** Callback to render the pane. Receives an object with [match](https://reacttraining.com/react-router/web/api/match) and `isActive`. */
    renderPane?: (props: RenderPaneProps) => React.Element<*>,
    /** URL to use for this tab. Use this instead of `key`. */
    url: string,
    /** If true, only render this tab if the url match is exact */
    exact: boolean,
    /**
     * Permission to check before rendering this tab. If check fails tab does not show up.
     *
     * Can either be a string, array of strings or an object describing the permission. Use the object
     * to do record level checks or model action checks.
     *
     * @example
     * **Check a permission on a record**
     * ```js
     * perm={{
     *     perm: 'custom_record_perm',
     *     record: MyRecord,
     * }}
     * // Equivalent to
     * perm={{
     *     perm: 'custom_record_perm',
     *     model: RecordClass,
     *     id: 1,
     * }}
     * ```
     *
     * **Check an action permission on a record**
     * ```js
     * perm={{
     *     action: 'list',
     *     record: MyRecord
     * }}
     * ```
     *
     * **Check a permission by name only**
     * ```js
     * perm="my_permission_name"
     * ```
     *
     * **Check multiple permissions match**
     * ```js
     * perm={['perm1', 'perm2', 'perm3']}
     * ```
     */
    perm: ?(
        | Array<string>
        | string
        | {
              perm: ?Array<string> | string,
              action: ?string,
              id: number | string,
              model: Class<Model>,
              record: Model,
          }
    ),
    /**
     * Determine whether tab should be visible. Should either be a boolean or a function that returns
     * a boolean or promise that resolves to a boolean.
     *
     * This exists as a convenience - you can always just exclude the tabs programmatically, you just
     * can't wrap a pane in a component, eg.
     * ```js
     * <CheckSomething><TabPane .../></CheckSomething>
     * ```
     * will not work - children of `UrlDrivenTabs` _must_ be a `TabPane`
     *
     * @example
     * **Static boolean evaluation**
     * ```js
     * visible={userType === 'Staff'}
     * ```
     *
     * **Promise that resolves to a bool**
     * ```js
     * visible={getUserType().then(user => user.userType === 'Staff')}
     * ```
     */
    visible: ?(boolean | Promise<boolean> | (() => boolean | Promise<boolean>)),
};

/**
 * Pane that renders within `<UrlDrivenTabs>`
 *
 * Also accepts same props as [TabPane](https://ant.design/components/tabs/#Tabs.TabPane)
 */
export function TabPaneWrapper({ isActive, match, children, renderPane, ...rest }: TabPaneProps) {
    if (children && renderPane) {
        // eslint-disable-next-line
        console.warn(
            `Only one of 'renderPane' or 'children' should be specified on UrlDrivenTabs.TabPane. 'children' will be ignored`
        );
    }
    let finalChildren;
    if (renderPane) {
        finalChildren = renderPane({ match, isActive, ...rest });
    } else {
        finalChildren = isActive ? children : null;
    }
    return <TabPane {...rest}>{finalChildren}</TabPane>;
}
TabPaneWrapper.displayName = 'UrlDrivenTabs.TabPane';
TabPaneWrapper.defaultProps = {
    exact: false,
};

type TabsWrapperProps = {
    defaultActiveKey: any,
    match: Match,
    baseMatch: Match,
    history: RouterHistory,
    renderNoMatch?: (props: RenderNoMatchProps) => React.Element<*>,
    children: React.ChildrenArray<React.Element<typeof UrlDrivenTabs.TabPane>>, // eslint-disable-line
    location: Location,
    djradSite: Site,
};

type TabsWrapperState = {
    panes: ?Array<React.Element<TabPaneWrapper>>,
};

const wrapArray = value => (Array.isArray(value) ? value : [value]);

class TabsWrapper extends React.Component<TabsWrapperProps, TabsWrapperState> {
    state = {
        panes: null,
    };

    handleDefaultActiveKey() {
        const { defaultActiveKey, match, baseMatch } = this.props;
        if (defaultActiveKey && !match) {
            this.props.history.replace(appendToUrl(baseMatch.url, defaultActiveKey));
        }
    }

    _resolvingPermissions: ?Promise<*> = null;
    _mounted: boolean = false;

    componentDidMount() {
        this._mounted = true;
        this.handleDefaultActiveKey();
        this._resolvingPermissions = this.resolvePermissions();
    }

    componentWillUnmount() {
        this._mounted = false;
    }

    resolvePermissions = async () => {
        const panes = React.Children.toArray(this.props.children);
        const { djradSite } = this.props;
        const finalPanes = await Promise.all(
            panes.map(async pane => {
                const { perm: permDescriptor, visible } = pane.props;
                if (visible != null) {
                    if (typeof visible == 'function') {
                        if (!(await visible())) {
                            return false;
                        }
                    } else if (!(await visible)) {
                        return false;
                    }
                }
                if (permDescriptor) {
                    let promise;
                    if (typeof permDescriptor == 'object') {
                        const { perm, action, model, record, id } = permDescriptor;
                        const object = model || record;
                        if (action) {
                            if (!object) {
                                throw new Error(
                                    'If action is provided model or record must also be provided'
                                );
                            }
                            promise = object._meta.hasActionPerm(action, record);
                        } else {
                            promise = djradSite.permissionChecker.hasPerms(
                                wrapArray(perm),
                                object,
                                id
                            );
                        }
                    } else {
                        promise = djradSite.permissionChecker.hasPerms(wrapArray(permDescriptor));
                    }
                    if (!(await promise)) {
                        return false;
                    }
                }
                return pane;
            })
        );
        if (this._mounted) {
            this.setState({ panes: finalPanes.filter(Boolean) });
        }
    };

    componentDidUpdate(prevProps) {
        this.handleDefaultActiveKey();
        if (this.props.children !== prevProps.children) {
            this._resolvingPermissions = this.resolvePermissions();
        }
    }

    handleChange = key => this.props.history.push(appendToUrl(this.props.baseMatch.url, key));

    render() {
        const { match, location, renderNoMatch, children, ...rest } = this.props;
        const { panes } = this.state;
        if (!panes) {
            return null;
        }

        const isActive = ({ props: { exact, url } }) =>
            exact
                ? match && location.pathname === match.url && match.params.key === url
                : match && match.params.key === url;

        if (renderNoMatch) {
            // Check that at least one tab is active, else fallback to user supplied prop
            const hasMatch = panes.filter(isActive).length > 0;
            if (!hasMatch) {
                return renderNoMatch({ match });
            }
        }

        return (
            <AntTabs {...rest} activeKey={match && match.params.key} onChange={this.handleChange}>
                {panes.map(child =>
                    React.cloneElement(child, {
                        key: child.props.url,
                        match,
                        isActive: isActive(child),
                    })
                )}
            </AntTabs>
        );
    }
}

type Props = {
    /** @ignore */
    match: Match,
    /** @ignore */
    djradSite: Site,
    /** Default tab to select */
    defaultActiveKey?: string,
    /**
     * Fallback to render if no tab pane url is matched
     * @example
     * **Redirect to a global 404 handler page**
     * ```
     * () => <Redirect to="/404" />
     * ```
     * @example
     * **Render 404 page in place**
     * ```
     * () => <h4>Sorry, that page could not be found</h4>
     * ```
     */
    renderNoMatch?: (props: RenderNoMatchProps) => React.Element<*>,
    /** List of tabs to render. Should only be elements of `UrlDrivenTabs.TabPane`. */
    children: React.ChildrenArray<React.Element<typeof UrlDrivenTabs.TabPane>>, // eslint-disable-line
};

/**
 * A version of the [Tabs](http://ant.design/components/Tabs) component that uses the
 * current URL to control the active tab.
 *
 * Also accepts same props as [Tabs](http://ant.design/components/tabs) except children should
 * all be of type <UrlDrivenTabs.TabPane>
 *
 * @see http://ant.design/components/tabs
 */
class UrlDrivenTabs extends React.Component<Props> {
    static TabPane = TabPaneWrapper;

    render() {
        const { djradSite, children, match, ...rest } = this.props;
        return (
            <Route path={appendToUrl(this.props.match.url, ':key')}>
                {routeProps => (
                    <TabsWrapper {...rest} djradSite={djradSite} baseMatch={match} {...routeProps}>
                        {children}
                    </TabsWrapper>
                )}
            </Route>
        );
    }
}

export default withRouter(injectSite(UrlDrivenTabs));
