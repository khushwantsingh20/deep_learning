// @flow
import * as React from 'react';
import fromPairs from 'lodash/fromPairs';
import RangeField from '../../model/fields/RangeField';
import ButtonBar from '../form/ButtonBar';
import ModelForm from '../model/ModelForm';
import Field from '../../model/fields/Field';
import LookupChoiceField from '../../model/fields/LookupChoiceField';
import FormButton, { FORM_ACTIONS } from '../form/FormButton';
import ModelFormItem from '../model/ModelFormItem';
import ModelFormField from '../model/ModelFormField';
import ModelFormFieldWidget from '../model/ModelFormFieldWidget';

type Props = {
    /** List of field names to render. Must be passed even if passing children to properly initialise default values. */
    fieldNames: Array<string>,
    /** Render form items manually by passing children */
    children?: ?React.Node,
    /** Definitions for fields to render */
    fieldDefinitions: { [fieldName: string]: Field },
    /** Initial values to populate form with */
    initialValues?: { [fieldName: string]: any },
    onSubmit: (data: { [fieldName: string]: any }) => Promise<void>,
};

type State = {
    defaultValuesLoaded: boolean,
    defaultValues: { [fieldName: string]: any },
    fixedDefaultValues: { [fieldName: string]: any },
};

/**
 * Render a form for inputing filter values. Behaves mostly the same as a
 * ModelForm but has some logic specific to collecting data for filtering.
 *
 * For examples see [ModelFilterForm](/components/ModelFilterForm/).
 *
 * @acceptsProps ModelForm
 */
export default class FilterForm extends React.Component<Props, State> {
    static defaultProps = {
        footer: (
            <ButtonBar
                leftButtons={<FormButton action={FORM_ACTIONS.CLEAR}>Clear</FormButton>}
                rightButtons={
                    <FormButton type="primary" htmlType="submit">
                        Apply Filters
                    </FormButton>
                }
            />
        ),
    };

    static Item = ModelFormItem;
    static Field = ModelFormField;
    static Widget = ModelFormFieldWidget;
    static Button = FormButton;

    state = {
        defaultValuesLoaded: false,
        defaultValues: {},
        fixedDefaultValues: {},
    };

    loadingPromise = null;

    async initialize() {
        const defaults: Array<Promise<[string, any]>> = this.props.fieldNames.map(async name => {
            const field = this.props.fieldDefinitions[name];
            let value;
            if (field) {
                value = await field.getDefaultValue();
            }
            return [name, value];
        });
        this.loadingPromise = Promise.all(defaults);
        const defaultValues = (await this.loadingPromise).filter(([, value]) => value != null);
        // Track default values to use when resetting the form. This is primarily to
        // initialize the lookup expressions with a default value.
        const fixedDefaultValues = defaultValues
            .map(([name, value]) => {
                const field = this.props.fieldDefinitions[name];
                if (field && field instanceof LookupChoiceField && value) {
                    return [name, { lookupType: value.lookupType }];
                }
                return null;
            })
            .filter(Boolean);
        this.setState({
            defaultValues: fromPairs(defaultValues),
            defaultValuesLoaded: true,
            fixedDefaultValues: fromPairs(fixedDefaultValues),
        });
    }

    componentDidMount() {
        this.initialize();
    }

    transformInitialValues = (initialValues: ?{ [string]: any }) => {
        if (!initialValues) {
            return initialValues;
        }
        return this.props.fieldNames.reduce(
            (acc, name) => {
                const field = this.props.fieldDefinitions[name];
                if (field && field instanceof LookupChoiceField) {
                    const valueFieldName = `${name}${field.valueSuffix}`;
                    const lookupFieldName = `${name}${field.lookupSuffix}`;
                    const value = {
                        lookupType: this.state.defaultValues[name].lookupType,
                        lookupValue: null,
                    };
                    if (acc[valueFieldName]) {
                        value.lookupValue = acc[valueFieldName];
                        delete acc[valueFieldName];
                    }
                    if (acc[lookupFieldName]) {
                        value.lookupType = acc[lookupFieldName];
                        delete acc[lookupFieldName];
                    }
                    acc[name] = value;
                }
                if (field && field instanceof RangeField) {
                    // Transform values back from flat format:
                    //   total_lower=5&total_upper=10 into format
                    // used in RangeField:
                    // {
                    //    lower: 5,
                    //    upper: 10,
                    // }
                    const lowerFieldName = `${name}${field.lowerBoundSuffix}`;
                    const upperFieldName = `${name}${field.upperBoundSuffix}`;
                    const value = {};
                    if (acc[lowerFieldName]) {
                        value.lower = acc[lowerFieldName];
                        delete acc[lowerFieldName];
                    }
                    if (acc[upperFieldName]) {
                        value.upper = acc[upperFieldName];
                        delete acc[upperFieldName];
                    }
                    acc[name] = value;
                }
                return acc;
            },
            { ...initialValues }
        );
    };

    handleSubmit = (data: {}) => {
        const { fieldDefinitions, onSubmit } = this.props;
        const finalData = Object.entries(data).reduce((acc, [fieldName, value]) => {
            const field = fieldDefinitions[fieldName];
            const name = field ? field.source : fieldName;
            if (value == null) {
                return acc;
            }
            if (field) {
                const d = {
                    ...acc,
                    ...field.transformFilterValue(value, data),
                };
                Object.keys(d).forEach(key => {
                    if (d[key] === undefined) {
                        delete d[key];
                    }
                });
                return d;
            }
            return { ...acc, [name]: value };
        }, {});
        return onSubmit(finalData);
    };

    handleFormAction = (action: string) => {
        if (action === FORM_ACTIONS.CLEAR) {
            this.props.onSubmit({});
        }
    };

    render() {
        const { fieldDefinitions, initialValues, fieldNames, children, ...rest } = this.props;
        const { defaultValues, defaultValuesLoaded, fixedDefaultValues } = this.state;
        if (!defaultValuesLoaded) {
            return null;
        }
        const finalProps = {
            onFormAction: this.handleFormAction,
            fieldDefinitions,
            ...rest,
            initialValues: {
                ...defaultValues,
                ...this.transformInitialValues(initialValues),
            },
            valuesOnClear: fixedDefaultValues,
            onSubmit: this.handleSubmit,
        };
        // Only pass through one of children or fieldNames; ModelForm will warn if you pass both
        if (children) {
            finalProps.children = children;
        } else {
            finalProps.fieldNames = fieldNames;
        }
        return <ModelForm {...finalProps} />;
    }
}
