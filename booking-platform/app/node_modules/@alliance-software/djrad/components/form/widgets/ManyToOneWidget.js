import React from 'react';
import { Icon, Button, Row } from 'antd';
import { FieldArray, FormSection } from 'redux-form';

/**
 Original implementation flagged items to be deleted but still included them in
 payload. This is more difficult to support using WritableNestedModelSerializer
 so has been disabled for now
// Indicates an item has been flagged for deletion
// We set a field named this constant to true to indicate
// an existing data should be deleted
const DELETION_FLAG_CONSTANT = '___rad_delete';

class FieldRow extends React.Component {
    render() {
        const { member, currentFormValues, form } = this.props;
        if (currentFormValues[DELETION_FLAG_CONSTANT]) {
            return null;
        }
        return (
            <div style={{ borderBottom: '1px solid #ccc', marginBottom: 10 }}>
                {React.cloneElement(form, {
                    name: member,
                    wrapperComponent: FormSection,
                    footer: (
                        <Form.Item key="remove" wrapperCol={{ offset: 6, sm: 14 }} style={{ textAlign: 'right', marginBottom: 5, marginTop: -20 }}>
                            <Field
                                name={DELETION_FLAG_CONSTANT}
                                component={field => (
                                    <Button type="danger" size="small" onClick={() => field.input.onChange(true)}>
                                        <Icon type="minus" /> Remove
                                </Button>
                                )}
                            />
                        </Form.Item>
                    ),
                })}
            </div>
        );
    }
}

// We select form values so we can check for DELETION_FLAG_CONSTANT of true and not render row
const FieldRowConnected = formValues(props => ({ currentFormValues: props.member }))(FieldRow);
*/

const ManyToOneAddNewButton = ({ onClick }) => (
    <Button type="primary" size="small" onClick={onClick}>
        <Icon type="plus" /> Add New
    </Button>
);

const renderChildren = ({ fields, meta, renderForm, renderAddNewButton, initialValues }) => (
    <React.Fragment>
        <Row>{meta.submitFailed && meta.error && <span>{meta.error}</span>}</Row>
        {fields.map((member, index) =>
            renderForm({
                wrapperComponent: FormSection,
                key: index,
                fieldData: fields.get(index),
                onRemove() {
                    fields.remove(index);
                },
                formName: member,
            })
        )}
        <Row>{renderAddNewButton({ onClick: () => fields.push(initialValues || {}) })}</Row>
    </React.Fragment>
);

export default class ManyToOneWidget extends React.Component {
    state = {
        isLoadingInitialValues: true,
        initialValues: null,
    };

    componentWillUnmount() {
        this._mounted = false;
    }

    async componentDidMount() {
        this._mounted = true;
        // Initial values can be a promise, wait for them to resolve. This is due
        // to how default values work - see Field.getDefaultValue
        // TODO: Not handling props initialValues changing after initial mount... probably should
        const initialValues = await this.props.initialValues;
        if (this._mounted) {
            this.setState({
                isLoadingInitialValues: false,
                initialValues,
            });
        }
    }

    render() {
        const { name, renderForm, renderAddNewButton = ManyToOneAddNewButton } = this.props;
        if (this.state.isLoadingInitialValues) {
            return null;
        }
        return (
            <FieldArray
                name={name.split('.').pop()}
                component={renderChildren}
                renderForm={renderForm}
                initialValues={this.state.initialValues}
                renderAddNewButton={renderAddNewButton}
            />
        );
    }
}
