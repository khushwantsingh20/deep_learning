import React from 'react';
import PropTypes from 'prop-types';
import { requiredBy, mutuallyExclusiveProps } from 'airbnb-prop-types';
import debounce from 'lodash/debounce';
import oneLine from 'common-tags/lib/oneLine';
import { Spin, Transfer } from 'antd';

import componentPropType from '../../../prop-types/component';
import SelectWidget from './SelectWidget';
import InfiniteScrollContainer from '../../InfiniteScrollContainer';
import DjradPropTypes from '../../../prop-types';
import { escapeRegExpString } from '../../../util/regex';

import injectSite from '../../../site/injectSite';
import connectModel from '../../model/connectModel';

const numericSort = (a, b) => Number(a) > Number(b);

function ensureArray(maybeArrayOrList) {
    if (maybeArrayOrList && typeof maybeArrayOrList == 'object') {
        if (maybeArrayOrList.toArray) {
            return maybeArrayOrList.toArray();
        }
    }
    if (!Array.isArray(maybeArrayOrList)) {
        return [maybeArrayOrList];
    }
    return maybeArrayOrList;
}

function TransferWidget(props) {
    const {
        items,
        value,
        onChange,
        onSearch,
        onScroll,
        totalAvailableRecords,
        notFoundContent,
        searchPlaceholder,
        ...rest
    } = props;
    const titles = [];
    // Hack to indicate the 'items' count is innaccurate if we haven't
    // yet fetched all items. Unfortunately can't customise the rendering
    // of the Transfer 'X items' text.
    if (totalAvailableRecords > items.length) {
        titles.push(`(${totalAvailableRecords - items.length} more)`);
    }
    const locale = { ...(rest.locale || {}) };
    if (notFoundContent) {
        locale.notFoundContent = notFoundContent;
    }
    if (searchPlaceholder) {
        locale.searchPlaceholder = searchPlaceholder;
    }
    const handleSearch = (column, query) => {
        if (column === 'left') {
            onSearch(query);
        }
    };

    // Ant wants a predicate here: since filtering is handled by ModelLookup,
    // we want to disable any filtering by the ant component.
    const filterOptions = () => true;

    return (
        <Transfer
            render={item => item.label}
            rowKey={item => item.id.toString()}
            dataSource={items}
            targetKeys={value.map(({ key }) => key)}
            onChange={values => onChange(values.map(key => ({ key })))}
            onSearch={handleSearch}
            showSearch
            onScroll={(_, e) => onScroll(e)}
            titles={titles}
            filterOption={filterOptions}
            {...rest}
            locale={locale}
        />
    );
}

function SelectWrapper(props) {
    const { multiple, fetching, items, ...rest } = props;
    return (
        <SelectWidget
            mode={multiple ? 'multiple' : null}
            labelInValue
            showSearch
            filterOption={false}
            notFoundContent={fetching ? <Spin size="small" /> : <em>No results found</em>}
            onDropdownVisibleChange={open => !open && props.clearSearch()}
            {...rest}
        >
            {items.map(entity => (
                <SelectWidget.Option key={entity.id} value={entity.id}>
                    {entity.label}
                </SelectWidget.Option>
            ))}
        </SelectWidget>
    );
}

class ModelLookupWidget extends React.PureComponent {
    static defaultProps = {
        lookupWidget: SelectWrapper,
        searchOnMount: true,
    };

    state = {
        query: '',
        matchingRecordIdsByPage: {},
        initialDataFetched: false,
        totalAvailableRecords: 0,
    };
    // Used in tests
    fetchPromise = null;
    hasMounted = false;

    constructor(props) {
        super(props);
        this.handleSearch = debounce(this.handleSearch, 300);
    }

    fetchData = params => {
        const { baseFilter = {}, model, fromModel, fromFieldName, labelFieldName } = this.props;
        const finalParams = { ...params, ...baseFilter };
        // If fromModel is not specified we just lookup against the model directly
        if (!fromModel) {
            this.fetchPromise = this.props.djradSite.api.listModel(model, finalParams, {
                partialRecordFieldNames: [labelFieldName],
            });
        } else {
            this.fetchPromise = this.props.djradSite.api.listRelatedModel(
                fromModel,
                fromFieldName,
                finalParams
            );
        }
        return this.fetchPromise;
    };

    search = (searchKeywords = '', page = 1) => {
        const { fromFieldName } = this.props;
        this.setState({ fetching: true });
        this.fetchData({ query: searchKeywords, pageSize: 100, page }).then(response => {
            if (!this.hasMounted) {
                return;
            }
            const { ids, nextPage, count } = response;
            const matchingRecordIds = ids;
            const hasMoreResults = !!nextPage;
            if (hasMoreResults && !this.props.supportsServerSideSearch) {
                /* eslint-disable */
                console.warn(oneLine`
                        Field '${fromFieldName}' doesn't support sever side search but there's 
                        too many results to fetch in one request. You should add support to 
                        backend for this by defining 'related_lookup_filter_fields' on your viewset.
                        If you don't do this then users will not be able to see all results and
                        search will only be applied to data already fetched.`);
                /* eslint-enable */
            }
            this.setState(state => ({
                totalAvailableRecords: count,
                searchKeywords,
                page,
                hasMoreResults,
                fetching: false,
                matchingRecordIdsByPage: {
                    ...state.matchingRecordIdsByPage,
                    [page]: matchingRecordIds,
                },
            }));
        });
    };

    async componentDidMount() {
        this.hasMounted = true;
        if (this.props.searchOnMount) {
            this.search();
        }
        const { value } = this.props;
        if (value) {
            // Make sure relevant related data has been fetched
            // NOTE: We don't need to do anything about the return value; we just
            // read model data from redux which is updated whenever data is
            // fetched from the server (see connectModel)
            const ids = ensureArray(value);
            if (ids.length > 0) {
                await this.fetchData({ ids });
            }
        }
        if (this.hasMounted) {
            this.setState({ initialDataFetched: true }); // eslint-disable-line
        }
    }

    componentWillUnmount() {
        this.hasMounted = false;
    }

    handleSearch = value => {
        const { supportsServerSideSearch } = this.props;
        this.setState({ fetching: supportsServerSideSearch, query: value });
        if (supportsServerSideSearch) {
            this.setState({ matchingRecordIdsByPage: {}, hasMoreResults: false });
            this.search(value);
        }
    };

    handleFocus = () => {
        if (this.props.onFocus) {
            this.props.onFocus();
        }
        this.search();
    };

    callChangeFunction = (fn, value) => {
        if (this.props.multiple) {
            if (value == null) {
                value = [];
            }
            fn(value.map(({ key }) => key));
        } else if (value) {
            fn(value.key);
        } else {
            fn(null);
        }
    };

    handleSelect = value => {
        this.callChangeFunction(this.props.onChange, value);
    };

    handleBlur = value => {
        // Ant widget will call onBlur with the value - transform
        // it here same as we do for handleSelect
        if (this.props.onBlur) {
            this.callChangeFunction(this.props.onBlur, value);
        }
    };

    handleScroll = () => {
        const { hasMoreResults, fetching } = this.state;
        if (hasMoreResults && !fetching) {
            this.search(this.state.query, this.state.page + 1);
        }
    };

    render() {
        const {
            totalAvailableRecords,
            initialDataFetched,
            matchingRecordIdsByPage,
            fetching,
            query,
        } = this.state;
        if (!initialDataFetched) {
            return <Spin />;
        }
        const {
            allowClear,
            lookupWidget,
            labelFieldName,
            supportsServerSideSearch,
            size,
            multiple,
            style,
            records,
            // Exclude these props from ...rest
            fromFieldName,
            djradSite,
            fromModel,
            relationModel,
            ...rest
        } = this.props;
        let { value } = this.props;
        // TODO: Fetch initial values if wedon't have it (eg. for array of items)
        const getTransformedValue = val => {
            if (!val) {
                return undefined;
            }
            val = val.toString();
            if (val && records.get(val)) {
                return { key: val, label: records.get(val).get(labelFieldName) };
            }
            return { key: val };
        };
        const matchingRecordIds = Object.keys(matchingRecordIdsByPage)
            .sort(numericSort)
            .reduce((acc, page) => [...acc, ...matchingRecordIdsByPage[page]], []);
        const matchingRecordIdsAsString = matchingRecordIds.map(String);
        if (multiple) {
            value = ensureArray(value || []);
            value = value.map(getTransformedValue);
            const missingValues = value.filter(
                ({ key }) => matchingRecordIdsAsString.indexOf(key) === -1 && records.get(key)
            );
            missingValues.forEach(({ key }) => matchingRecordIds.push(key));
        } else {
            value = getTransformedValue(value);
            if (
                value &&
                matchingRecordIdsAsString.indexOf(value.key) === -1 &&
                records.get(value.key)
            ) {
                matchingRecordIds.push(value.key);
            }
        }
        let items = matchingRecordIds.map(id => ({
            // Always deal with strings so strict equality matches what we
            // have in value (see getTransformedValue above). Without this
            // if id is a Number but the value.key is a string antd Select
            // won't show the item as being selected.
            id: String(id),
            label: records.get(id).get(labelFieldName),
        }));
        if (query && !supportsServerSideSearch) {
            const r = new RegExp(escapeRegExpString(query), 'i');
            items = items.filter(item => item.label.match(r));
        }

        const lookupWidgetProps = {
            ...rest,
            allowClear,
            items,
            value,
            onBlur: this.handleBlur,
            onChange: this.handleSelect,
            onSearch: this.handleSearch,
            onFocus: this.handleFocus,
            multiple,
            size,
            totalAvailableRecords,
            notFoundContent: fetching ? <Spin size="small" /> : <em> No results found</em>,
            style,
            clearSearch: () => this.handleSearch(''),
        };
        if (React.isValidElement(lookupWidget)) {
            return React.cloneElement(lookupWidget, lookupWidgetProps);
        }
        const LookupWidget = lookupWidget;
        return (
            <InfiniteScrollContainer onReachBottom={this.handleScroll}>
                <LookupWidget {...lookupWidgetProps} />
            </InfiniteScrollContainer>
        );
    }
}

ModelLookupWidget.propTypes = {
    allowClear: PropTypes.bool,
    /** Optional filter to use for all server requests in addition to search keywords */
    baseFilter: PropTypes.object,
    /** Field name of relation on fromModel */
    fromFieldName: requiredBy('fromModel', DjradPropTypes.modelFieldName('fromModel')),
    /** Model related lookup is originates from. Relation field is specified with fromFieldName */
    fromModel: mutuallyExclusiveProps(
        requiredBy('fromFieldName', DjradPropTypes.modelClass()),
        'model',
        'fromModel'
    ),
    /** Field name on record used displayed in drop down */
    labelFieldName: DjradPropTypes.modelFieldName(props => props.relationModel),
    /**
     * Component to render the input widget for this item. Can either be a component or component element.
     * If an element is passed it will be cloned and passed normal widget props (value, onChange etc).
     * eg. `lookupWidget={Select}` and `lookupWidget={<Select />}` are equivalent.
     **/
    lookupWidget: componentPropType,
    /**
     * Model to do lookup directly on. Either set this or fromFieldName and fromModel. Note that if
     * you set this field the lookup is done against the regular API endpoint for that model and not
     * the related lookup endpoint as is the case when using fromModel.
     * DOC_TODO: Add link to documentation explaining this in more detail
     */
    model: mutuallyExclusiveProps(DjradPropTypes.modelClass(), 'model', 'fromModel'),
    /** True if can select multiple items */
    multiple: PropTypes.bool,
    /** Defaults to true. Set to false to not perform an initial search on mount. */
    searchOnMount: PropTypes.bool,
    /**
     * True if searching should be handled on the server side. If false filtering will occur client
     * side. Note that if you expect more than 100 records to ever exist you should support server
     * side search.
     * DOC_TODO: Add link that explains how to enable this on the server
     */
    supportsServerSideSearch: PropTypes.bool,
};

const EnhancedModelLookupWidget = connectModel(
    props => {
        if (props.fromModel) {
            let { fromModel } = props;

            if (typeof fromModel == 'string') {
                fromModel = props.djradSite.models.get(fromModel);
            }
            const field = fromModel._meta.fields[props.fromFieldName];
            if (!field) {
                throw new Error(oneLine`
                    No such field ${props.fromFieldName} on model ${fromModel._meta.modelId}. Check
                    value to prop 'fromFieldName' is spelt correctly.
                `);
            }
            if (!field.relation) {
                // TODO: DOC_TODO Add link in error to documentation explaining related model lookup
                throw new Error(oneLine`
                    ${props.fromFieldName} is a valid field on model ${
                    fromModel._meta.modelId
                } but is
                    not a relation. Either choose a relation field or remove the 'fromModel' & 'fromFieldName'
                    props and pass the model you wish to do a lookup on directly on the 'model' prop.
                `);
            }
            return fromModel._meta.fields[props.fromFieldName].relation.model;
        }
        return props.model;
    },
    (model, state, props) => {
        // Explicitly check this here otherwise partialFields selector below will throw
        // with a less specific message
        if (!model._meta.fields[props.labelFieldName]) {
            const knownFields = model._meta.fieldNames.join(', ');
            throw new Error(
                `Field '${
                    props.labelFieldName
                }' passed as labelFieldName is not a valid field. Known fields are ${knownFields}`
            );
        }
        return model.selectors.partialFields.synced(state)([props.labelFieldName]);
    },
    // Specifies the prop that the resolved model from connectModel gets passed as
    'relationModel'
)(injectSite(ModelLookupWidget));

EnhancedModelLookupWidget.TransferWidget = TransferWidget;
EnhancedModelLookupWidget.SelectWidget = SelectWrapper;

export default EnhancedModelLookupWidget;
