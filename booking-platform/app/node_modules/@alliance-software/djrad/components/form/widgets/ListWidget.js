import React from 'react';
import { nonNegativeInteger } from 'airbnb-prop-types';
import PropTypes from 'prop-types';
import { Row, Icon, Button } from 'antd';

import FormField from '../../form/FormField';
import ListItemWidget from './ListItemWidget';
import componentPropType from '../../../prop-types/component';

const defaultRenderAddNewButton = ({ onAdd, canAdd }) =>
    canAdd && (
        <Row>
            <Button type="primary" size="small" onClick={onAdd} className="djrad--list-item-add">
                <Icon type="plus" /> Add New
            </Button>
        </Row>
    );

const defaultRenderItem = (fieldName, props) => (
    <FormField name={fieldName} widget={<ListItemWidget {...props} />} />
);

export default class ListWidget extends React.Component {
    static defaultProps = {
        renderAddNewButton: defaultRenderAddNewButton,
        renderItem: defaultRenderItem,
        min: 0,
    };

    static propTypes = {
        /**
         * Render prop that should render the button that adds new rows. Receives
         *
         * | Param | Type | Desc |
         * |-------|------|------|
         * |props | Object | |
         * |props.onAdd|Func|Callback that will add a new item|
         * |props.canAdd|Boolean|Whether can add a new item. Will be false if default value hasn't resolved or number of items is at max.|
         * |props.isLoadingDefault|Boolean|Whether default value has resolved. canAdd will be false if this is true.|
         */
        renderAddNewButton: PropTypes.func,
        /**
         * Render prop that should render a single item. Default implementation uses `Form.Field` to track
         * changes in redux-form.
         *
         * | Param | Type | Desc |
         * |-------|------|------|
         * |name|String|form field name for this item|
         * |props | Object | |
         * |props.onRemove|Func|Callback that will remove this item|
         * |props.canRemove|Boolean|True if this item can be removed. Will be false if number of items is at min.|
         * |props.index|number|Index into list for this item|
         * |props.value|any|the value for this item|
         * |props.field|array|the [fields array](https://redux-form.com/8.2.2/docs/api/fieldarray.md/#fields-props) passed from redux-form. You can access anything relating to the fields from here (eg. fields.length for number of fields)|
         */
        renderItem: PropTypes.func,
        /**
         * Responsible for rendering a single item widget (excluding wrapper with remove button). If you
         * don't specify renderItem you must specify inputWidget. Can either be a component or component
         * element. If an element is passed it will be cloned and passed normal widget props (value, onChange etc).
         */
        inputWidget: PropTypes.oneOfType([componentPropType, PropTypes.node]),
        /** Minimum number of items required. Enforces at least this many items are present. */
        min: nonNegativeInteger,
        /** Max number of items allowed. Enforces at most this many items are present. */
        max: nonNegativeInteger,
    };

    state = {
        isLoadingDefault: true,
        defaultValue: null,
    };

    async resolveDefault() {
        // Initial values can be a promise, wait for them to resolve. This is due
        // to how default values work - see Field.getDefaultValue
        // TODO: Not handling props initialValues changing after initial mount... probably should
        const defaultValue = await this.props.defaultValue;
        this.setState({
            isLoadingDefault: false,
            defaultValue,
        });
        const { fields, min } = this.props;
        const diff = min - fields.length;
        if (diff > 0) {
            Array.from({ length: diff }).forEach(() => this.props.fields.push(defaultValue));
        }
    }

    componentDidMount() {
        this.defaultValuePromise = this.resolveDefault();
    }

    render() {
        const { fields, meta, renderItem, inputWidget, renderAddNewButton, min, max } = this.props;
        const { isLoadingDefault, defaultValue } = this.state;
        const canRemove = !min || fields.length - min > 0;
        const canAdd = (!max || max - fields.length > 0) && !isLoadingDefault;
        return (
            <React.Fragment>
                {meta.submitFailed && meta.error && <Row>{meta.error}</Row>}
                {fields.map((member, index) => (
                    <React.Fragment key={index}>
                        {renderItem(member, {
                            index,
                            inputWidget,
                            canRemove,
                            onRemove: () => {
                                if (!canRemove) {
                                    // eslint-disable-next-line
                                    console.warn(
                                        `ListWidget component has min=${min} but called onRemove with ${
                                            fields.length
                                        } items. Your remove button component should check 'canRemove' and conditionally render or render as disabled.`
                                    );
                                } else {
                                    fields.remove(index);
                                }
                            },
                            value: fields.get(index),
                            fields,
                        })}
                    </React.Fragment>
                ))}
                {renderAddNewButton({
                    onAdd: () => {
                        if (!canAdd) {
                            if (isLoadingDefault) {
                                // eslint-disable-next-line
                                console.warn(
                                    "ListWidget component called onAdd before default value resolved. Your renderAddNewButton prop should check 'canAdd' and conditionally render or render as disabled."
                                );
                            } else {
                                // eslint-disable-next-line
                                console.warn(
                                    `ListWidget component has max=${max} but called onAdd when at max. Your renderAddNewButton prop should check 'canAdd' and conditionally render or render as disabled.`
                                );
                            }
                        } else {
                            fields.push(defaultValue);
                        }
                    },
                    isLoadingDefault,
                    canAdd,
                })}
            </React.Fragment>
        );
    }
}
