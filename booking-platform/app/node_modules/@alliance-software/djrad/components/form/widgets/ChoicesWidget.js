// @flow
import * as React from 'react';
import type { WidgetProps } from '../FormField';
import SelectChoicesWidget from './SelectChoicesWidget';
import RadioChoicesWidget from './RadioChoicesWidget';

type Choice = [string, string];
// type Group = [string, Array<string>];

type Props = WidgetProps & {
    // Caused issues wit hflow
    // choices: Array<Choice> | Array<Group>,
    choices: Array<Choice>,
    /** If true allow selecting multiple options. Not valid with Radio widget */
    multiple?: boolean,
    /** If false defaults widget type to be Select rather than Radio so field can be cleared */
    required?: boolean,
    /**
     * Type of widget to use. auto will use [SelectChoicesWidget](/components/SelectChoicesWidget/) if there are more than 4 choices
     * @see [RadioChoicesWidget](/components/RadioChoicesWidget/)
     * @see [SelectChoicesWidget](/components/SelectChoicesWidget/)
     */
    type?: 'auto' | 'radio' | 'select',
    /** Custom widget to use to actually render the choices. If specified `type` is ignored */
    choicesWidget?: React.ComponentType<any>,
};

/**
 * Transform a value based on a function. null/undefined always return null;
 * @param value
 * @param fn
 * @returns {*}
 */
function transformChoiceValue(
    value: ?string | number | Array<string | number>,
    fn: (value: string | number) => ?string | number
) {
    // null is used to indicate no value so we can safely transform undefined into null
    // here to avoid this issue (ie. we don't need to be able to differentiate between
    // undefined and null - we just need some value to indicate no value)
    if (value == null) {
        return null;
    }
    if (Array.isArray(value)) {
        return value.map(fn);
    }
    return fn(value);
}

/**
 * Render choices for a user to select using either [RadioChoicesWidget](#radiochoiceswidget),  [SelectChoicesWidget](#selectchoiceswidget)
 * or a user provided widget (see `choicesWidget` prop).
 *
 * Many underlying widgets (especially if they just map directly to HTML elements) only work with string
 * values. This widget will transform numeric and boolean values for you so that the widget can render
 * a string value but the value passed to `onChange` will be the original type.
 */
export default function ChoicesWidget({
    choices,
    choicesWidget,
    value,
    required,
    multiple,
    type = 'auto',
    onChange,
    ...rest
}: Props) {
    const containsGroups = choices.filter(([, val]) => Array.isArray(val)).length > 0;
    let Widget: ?React.ComponentType<any> = choicesWidget;
    if (!Widget) {
        if (type === 'auto') {
            Widget =
                containsGroups || choices.length > 4 || !required || multiple
                    ? SelectChoicesWidget
                    : RadioChoicesWidget;
        } else {
            Widget = type === 'radio' ? RadioChoicesWidget : SelectChoicesWidget;
        }
    }
    // Inputs don't work unless values are strings so we map from the string representation
    // to the actual type and pass that back through in onChange (eg. a number). We don't handle
    // anything complex (objects) - only numbers.
    const transformChoiceKeys = ([key]) => {
        if (typeof key == 'string' || typeof key == 'number' || typeof key == 'boolean') {
            return [key.toString(), key];
        }
        return [key, key];
    };
    // Store a mapping from the stringified value to the actual original key value
    // On change we transform the selected value from the string back to it's original type
    // Currently this only happens for numbers.
    const valueMap = new Map(
        choices.reduce((acc, [key, val]) => {
            if (Array.isArray(val)) {
                acc.push(...val.map(transformChoiceKeys));
            } else {
                acc.push(transformChoiceKeys([key]));
            }
            return acc;
        }, [])
    );
    const transformVal = (v: ?string | number | boolean) => (valueMap.has(v) ? valueMap.get(v) : v);
    // On change we transform the stringified value back to it's original typed value
    const onChangeWrapper = (rawValue: ?string | number | boolean | Event) => {
        // If value is actually an event object extract it. So we do end up losing the
        // even information this way but it also depends entirely on the widget as to
        // whether this exists (eg. SelectChoicesWidget doesn't pass the event). As such
        // for this compound widget I think it's probably acceptable to normalize to just
        // the value. Most of the time this is handled transparently by redux-form
        // anyway.
        if (typeof rawValue == 'object' && rawValue && rawValue.target) {
            rawValue = rawValue.target.value;
        }
        onChange(transformChoiceValue(rawValue, transformVal));
    };
    if (multiple && value === '') {
        value = [];
    }
    return (
        <Widget
            // Always treat the value as a string at the widget level. While this could potential cause issues
            // custom widgets it resolves issues with plain HTML widgets (select, radio etc) and also with the antd
            // select and radio components.
            value={transformChoiceValue(value, v => v.toString())}
            choices={choices}
            allowClear={!required}
            multiple={multiple}
            onChange={onChangeWrapper}
            {...rest}
        />
    );
}
