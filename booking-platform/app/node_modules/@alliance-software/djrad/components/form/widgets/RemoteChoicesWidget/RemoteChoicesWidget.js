// @flow
import * as React from 'react';
import * as Immutable from 'immutable';
import { connect } from 'react-redux';
import { API_CALL_REQUEST, get } from 'alliance-redux-api/lib/api';
import PropTypes from 'prop-types';
import debounce from 'lodash/debounce';
import isEqual from 'lodash/isEqual';
import componentPropType from '../../../../prop-types/component';

import type { ApiListResponse } from '../../../../api/types';
import { ApiResponse } from '../../../../api/util';
import RemoteChoicesSelectWidget from './RemoteChoicesSelectWidget';

const Item = Immutable.Record({
    label: null,
    // Id forced to string
    id: null,
    // Original ID before being forced to a string
    rawId: null,
});

function toList(maybeArray) {
    if (!Array.isArray(maybeArray)) {
        if (maybeArray == null) {
            maybeArray = [];
        }
        maybeArray = [maybeArray];
    }
    return Immutable.List(maybeArray);
}

export type ChoicesWidgetProps = {
    isFetching: boolean,
    items: Immutable.List<Item>,
    keywords: string,
    multiple: boolean,
    onChange: (valueOrValues: ?Array<string | number> | string | number) => void,
    onBlur?: ?(valueOrValues: ?Array<string | number> | string | number) => void,
    onFetchMore: () => void,
    onSearch: (keywords: string) => Promise<ApiListResponse>,
    value: Item | Immutable.List<Item>,
};

type Props = {
    /** The endpoint to call to fetch choices */
    endpoint: string,
    /** Optional params to send with every call to backend */
    baseFilter: ?{},
    /** If true multiple values can be selected */
    multiple: boolean,
    /** Number of records to fetch at one time */
    pageSize: number,
    /**
     * If multiple is true this should be an array of values's
     * otherwise a single value representing current selection.
     * Should be the identifier for the item.
     */
    value: ?Array<string | number> | string | number,
    /** Field name on data returned from backend that should be used as label */
    labelFieldName: string,
    /**
     * Field name on data returned from backend that should be used as the id for this item.
     * This determines the value that will come through in `onChange`.
     */
    idFieldName: string,
    onFocus?: (e: Event) => void,
    /** Called when option(s) are selected. When `multiple` is true this will be an array of values. */
    onChange: (valueOrValues: ?number | string | Array<number | string>) => void,
    onBlur?: ?(valueOrValues: ?number | string | Array<number | string>) => void,
    /** Widget to use for rendering choices. Defaults to select box with autocomplete. */
    choicesWidget: React.ComponentType<ChoicesWidgetProps>,
    /** Set to true to batch this API call. Defaults to true so long as endpoint is not an absolute URL */
    shouldBatchApiCall?: boolean,
};

type CombinedProps = Props & {
    /** @ignore */
    get: (endpoint: string, params: {}, options: Object) => Promise<ApiListResponse>,
};

type IdValue = string;

type State = {
    isFetching: boolean,
    initialDataFetched: boolean,
    fetchedItems: Immutable.Map<IdValue, Item>,
    pageData: Immutable.OrderedMap<number, IdValue>,
    hasMoreResults: boolean,
    page: number,
    keywords: string,
};

const singleValuePropType = [PropTypes.string, PropTypes.number];
const multiValuePropType = PropTypes.arrayOf(PropTypes.oneOfType(singleValuePropType));

/**
 * Widget that renders options fetched from a remote endpoint.
 *
 * By default renders as a select but can be customised by passing a component
 * to `choicesWidget`.
 *
 * Used as default widget in filters to lookup available options for
 * ModelChoiceFilter etc from django-filters but works with any endpoint that
 * returns an array of data with an id field and label field (as determined by
 * `idFieldName` and `labelFieldName` props)
 */
class RemoteChoicesWidget extends React.Component<CombinedProps, State> {
    static defaultProps = {
        pageSize: 100,
        labelFieldName: '__str__',
        idFieldName: 'id',
        multiple: false,
        choicesWidget: RemoteChoicesSelectWidget,
    };

    static propTypes = {
        endpoint: PropTypes.string.isRequired,
        baseFilter: PropTypes.object,
        multiple: PropTypes.bool,
        pageSize: PropTypes.number,
        value: PropTypes.oneOfType([...singleValuePropType, multiValuePropType]),
        labelFieldName: PropTypes.string,
        idFieldName: PropTypes.string,
        onFocus: PropTypes.func,
        onChange: PropTypes.func.isRequired,
        onBlur: PropTypes.func,
        choicesWidget: componentPropType,
    };

    state = {
        isFetching: false,
        initialDataFetched: false,
        pageData: Immutable.OrderedMap(),
        fetchedItems: Immutable.Map(),
        keywords: '',
        page: 1,
        hasMoreResults: false,
    };

    constructor(props) {
        super(props);
        this.fetchDataResetDebounced = debounce(this.fetchDataReset, 300);
    }

    hasMounted: boolean = false;

    // Only used for unit tests
    fetchPromise: ?Promise<ApiListResponse> = null;

    fetchDataResetDebounced: () => Promise<ApiListResponse>;

    fetchExisting = (values: string | number | Array<string | number>) =>
        this.fetchData({ values });

    fetchPaginated = () => {
        const { baseFilter = {}, pageSize } = this.props;
        const { page, keywords } = this.state;
        const params = { ...baseFilter, pageSize, page, keywords };
        return this.fetchData(params, page);
    };

    fetchDataReset = () => {
        if (this.hasMounted) {
            this.setState({
                pageData: Immutable.OrderedMap({}),
                page: 1,
            });
        }
        return this.fetchPaginated();
    };

    fetchData = (params: {}, page: ?number) => {
        const { endpoint, labelFieldName, idFieldName } = this.props;
        this.setState({ isFetching: true });
        let { shouldBatchApiCall } = this.props;
        const isAbsoluteUrl = endpoint.startsWith('http://') || endpoint.startsWith('https://');
        if (shouldBatchApiCall == null) {
            shouldBatchApiCall = !isAbsoluteUrl;
        }
        const options = {
            requestType: {
                type: API_CALL_REQUEST,
                meta: {
                    // batch these calls so long as they are relative to this site
                    batchCall: shouldBatchApiCall,
                },
            },
        };
        this.fetchPromise = this.props.get(endpoint, params, options).then(rawResponse => {
            const response = new ApiResponse(rawResponse);
            const items = Immutable.OrderedMap(
                response.getResults().map(item => [
                    String(item[idFieldName]),
                    new Item({
                        id: String(item[idFieldName]),
                        label: item[labelFieldName],
                        rawId: item[idFieldName],
                    }),
                ])
            );
            if (this.hasMounted) {
                this.setState(state => ({
                    isFetching: false,
                    hasMoreResults: !!response.getNextPage(),
                    fetchedItems: state.fetchedItems.merge(items),
                    // Only update page data is page specified. This won't happen
                    // when fetching individual values
                    pageData: page
                        ? state.pageData.set(page, items.keySeq().toList())
                        : state.pageData,
                }));
            }
            return rawResponse;
        });
        return this.fetchPromise;
    };

    handleSearch = keywords => {
        this.setState({ keywords });
        // We need to fetch data but we have to reset pagination at same time
        return this.fetchDataResetDebounced();
    };

    componentDidMount() {
        const { value } = this.props;
        this.hasMounted = true;
        if ((!Array.isArray(value) && value) || (Array.isArray(value) && value.length > 0)) {
            this.fetchExisting(value).then(() => {
                if (this.hasMounted) {
                    this.setState({ initialDataFetched: true });
                }
            });
        } else {
            this.setState({ initialDataFetched: true });
        }
    }

    componentWillUnmount() {
        this.hasMounted = false;
    }

    hasFocused = false;
    onFocus = (e: Event) => {
        if (this.props.onFocus) {
            this.props.onFocus(e);
        }
        if (!this.hasFocused) {
            this.hasFocused = true;
            this.fetchPaginated();
        }
    };

    handleFetchMore = () => {
        const { hasMoreResults, isFetching } = this.state;
        if (hasMoreResults && !isFetching) {
            this.setState(state => ({ page: state.page + 1 }), this.fetchPaginated);
        }
    };

    handleChange = (value: ?string | Array<string | number> | number) => {
        // Internally we always use strings to simplify things but
        // when we pass data back we want to use whatever type was
        // originally returned for the item.
        if (!value) {
            this.props.onChange(value);
            return;
        }
        if (Array.isArray(value)) {
            this.props.onChange(value.map(id => this.state.fetchedItems.get(id).rawId));
            return;
        }
        this.props.onChange(this.state.fetchedItems.get(value).rawId);
    };

    handleBlur = (value: ?string | Array<string | number> | number) => {
        if (this.props.onBlur) {
            if (!value) {
                this.props.onBlur(value);
                return;
            }
            if (Array.isArray(value)) {
                this.props.onBlur(value.map(id => this.state.fetchedItems.get(id).rawId));
                return;
            }
            this.props.onBlur(this.state.fetchedItems.get(value).rawId);
        }
    };

    componentDidUpdate(prevProps) {
        const requiresReset =
            prevProps.endpoint !== this.props.endpoint ||
            prevProps.labelFieldName !== this.props.labelFieldName ||
            prevProps.idFieldName !== this.props.idFieldName ||
            !isEqual(prevProps.baseFilter, this.props.baseFilter);
        if (requiresReset) {
            this.setState({
                fetchedItems: Immutable.OrderedMap(),
                pageData: Immutable.OrderedMap(),
                page: 1,
            });
            this.fetchPaginated();
        } else if (prevProps.value !== this.props.value && this.props.value != null) {
            const valueList = toList(this.props.value);
            const { fetchedItems } = this.state;
            const filteredItems = valueList.map(id => fetchedItems.get(String(id))).filter(Boolean);
            if (filteredItems.size !== valueList.size) {
                this.setState({ initialDataFetched: false });
                this.fetchData({ values: valueList.toJS() }).then(() => {
                    this.setState({ initialDataFetched: true });
                });
            }
        }
    }

    render() {
        const {
            fetchedItems,
            hasMoreResults,
            initialDataFetched,
            isFetching,
            keywords,
            pageData,
        } = this.state;
        if (!initialDataFetched) {
            return null;
        }
        const { multiple, choicesWidget: ChoicesWidget, ...rest } = this.props;
        const valueList = toList(this.props.value);
        const items = pageData.valueSeq().flatMap(ids => ids.map(id => fetchedItems.get(id)));
        const filteredItems = valueList.map(id => fetchedItems.get(String(id))).filter(Boolean);
        const value = multiple ? filteredItems : filteredItems.first();
        return (
            <ChoicesWidget
                {...rest}
                hasMoreResults={hasMoreResults}
                isFetching={isFetching}
                items={items}
                keywords={keywords}
                multiple={multiple}
                onBlur={this.handleBlur}
                onChange={this.handleChange}
                onFetchMore={this.handleFetchMore}
                onFocus={this.onFocus}
                onSearch={this.handleSearch}
                clearSearch={() => this.handleSearch('')}
                value={value}
            />
        );
    }
}

export default connect(
    null,
    { get }
)(RemoteChoicesWidget);
