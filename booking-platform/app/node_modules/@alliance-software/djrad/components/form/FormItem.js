import React, { PureComponent } from 'react';
import cx from 'classnames';
import PropTypes from 'prop-types';
import { Form as AntForm } from 'antd';
import FormContext from './formContext';

export const requiredClassName = 'djrad--item--required';

export function Message({ message }) {
    if (Array.isArray(message)) {
        message = message.join(', ');
    }
    return <div>{message}</div>;
}

export const FormItemContext = React.createContext();

/**
 * For rendering purposes errors ideally need to show at the FormItem level so this component renders any errors that come from descendant
 * [FormField](/components/FormField/)'s.
 *
 * `FormItem` must appear within a [Form](/components/Form/).
 **/
export default class FormItem extends PureComponent {
    state = {
        errors: {},
    };

    static contextType = FormContext;

    static propTypes = {
        /**
         * Field label. Note that if you exclude this space is still allocated for the label when the parent form layout is 'horizontal'.
         * If you exclude label and want to also exclude the space for the label set `fullWidth`.
         **/
        label: PropTypes.node,
        /** Force item to take full width of form rather than using parent form layout specification */
        fullWidth: PropTypes.bool,
        /** Element this item is for (this should map to underlying input id) */
        htmlFor: PropTypes.string,
        /** Array of errors to render */
        errors: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),
        /** Array of warnings to render */
        warnings: PropTypes.arrayOf(PropTypes.string),
        /** Children to render. Normally a widget would be rendered but anything is supported. */
        children: PropTypes.node.isRequired,
        /**
         * Layout specification for label. eg. `{ span: 3, offset: 12 }`
         * @see https://ant.design/components/grid/#Col
         */
        labelCol: PropTypes.object,
        /**
         * Layout specification for input controls.
         * @see https://ant.design/components/grid/#Col
         */
        wrapperCol: PropTypes.object,
        /** Extra content to render in addition to any warnings or errors */
        extra: PropTypes.node,
        /** Whether field is required or not. Adds the class `djrad--item--required` if so. */
        required: PropTypes.bool,
        /** Class name to apply */
        className: PropTypes.string,
    };

    componentDidMount() {
        this.checkProps({}, this.props);
    }

    componentDidUpdate(nextProps) {
        this.checkProps(this.props, nextProps);
    }

    checkProps(lastProps, nextProps) {
        if (nextProps.id && lastProps.id !== nextProps.id) {
            // eslint-disable-next-line
            console.warn(
                "Setting the 'id' prop on FormItem is not supported due to API exposed by Ant."
            );
        }
    }

    componentWillUnmount() {
        this.unmounting = true;
    }

    unregisterError = fieldName => {
        this.setState(({ errors }) => {
            const nextErrors = { ...errors };
            delete nextErrors[fieldName];
            return {
                errors: nextErrors,
            };
        });
    };

    registerError = (fieldName, error) => {
        // FormField can register an error so we can display relevant error
        // + set validateStatus. (basic issue is validation from redux-form
        // is received at field level but we have to set some props at the FormItem
        // level)
        // TODO: Dave: This is a huge pain and possibly stupid - revisit
        this.setState(({ errors }) => ({
            errors: { ...errors, [fieldName]: error },
        }));
    };

    _formItemContext = { registerError: this.registerError, unregisterError: this.unregisterError };

    render() {
        const {
            children,
            fullWidth,
            className,
            required,
            errors = [],
            warnings = [],
            ...rest
        } = this.props;
        const finalErrors = {
            ...this.state.errors,
            ...(typeof errors == 'string' ? [errors] : errors),
        };
        let errorMessages = null;
        if (Object.keys(finalErrors).length > 0) {
            errorMessages = Object.values(finalErrors)
                .reduce((acc, error) => {
                    if (Array.isArray(error)) {
                        return [...acc, ...error.filter(err => typeof err == 'string')];
                    }
                    if (typeof error == 'string') {
                        return [...acc, error];
                    }
                    // We ignore other values - these will be objects for nested
                    // forms which are handled at the nested form level
                    return acc;
                }, [])
                .join(', ');
        }

        const layoutProps = this.context.getLayoutProps(this.props);
        if (fullWidth) {
            if (layoutProps.wrapperCol) {
                // TODO: probably pretty fragile, assumes format:
                // {
                //     sm: { span: 16, offset: 8 },
                // }
                Object.keys(layoutProps.wrapperCol).forEach(bp => {
                    layoutProps.wrapperCol[bp].span += layoutProps.wrapperCol[bp].offset;
                    layoutProps.wrapperCol[bp].offset = 0;
                });
            } else {
                layoutProps.wrapperCol = { offset: 0 };
            }
        }
        const extraProps = {};
        const help = [];
        if (errorMessages && errorMessages.length > 0) {
            extraProps.validateStatus = 'error';
            help.push(<Message key="errors" message={errorMessages} />);
        }
        if (warnings && warnings.length > 0) {
            extraProps.validateStatus = extraProps.validateStatus || 'warning';
            help.push(<Message key="warnings" message={warnings} />);
        }
        if (help.length) {
            extraProps.help = help;
        }
        const finalClassName = cx(className, { [requiredClassName]: required });
        return (
            <FormItemContext.Provider value={this._formItemContext}>
                <AntForm.Item className={finalClassName} {...rest} {...layoutProps} {...extraProps}>
                    {children}
                </AntForm.Item>
            </FormItemContext.Provider>
        );
    }
}
