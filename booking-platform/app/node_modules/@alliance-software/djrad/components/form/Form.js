import { Alert } from 'antd';
import cx from 'classnames';
import cloneDeep from 'lodash/cloneDeep';
import get from 'lodash/get';
import pick from 'lodash/pick';
import PropTypes from 'prop-types';
import React from 'react';
import { Form as ReduxForm, FormSection, reduxForm, SubmissionError } from 'redux-form';
import injectSite from '../../site/injectSite';
import { getObjectFieldPaths } from '../../util/object';
import { matchingColumnProps } from '../layout/util';
import ButtonBar from './ButtonBar';
import FormButton, { FORM_ACTIONS } from './FormButton';
import FormContext from './formContext';
import FormField from './FormField';
import FormItem from './FormItem';
import componentPropType from '../../prop-types/component';

import './Form.less';

const formAttributeWhitelist = [
    'accept',
    'acceptCharset',
    'action',
    'autocapitalize',
    'autocomplete',
    'enctype',
    'id',
    'method',
    'name',
    'novalidate',
    'target',
    'style',
    'className',
];

export const SUBMISSION_ACTION_FIELD_NAME = '_submitAction';

/**
 * Render errors as a list in an Alert
 */
export function SubmissionErrors({ errors, message = 'There was a problem with your submission' }) {
    if (!Array.isArray(errors)) {
        errors = [errors];
    }
    const desc =
        errors.length > 1 ? (
            <ul>
                {errors.map(error => (
                    <li key={error}>{error}</li>
                ))}
            </ul>
        ) : (
            errors[0]
        );
    return <Alert message={message} description={desc} type="error" showIcon />;
}

class BaseForm extends React.Component {
    static contextType = FormContext;

    _formContext = null;
    getContext() {
        const formDepth = (this.context.formDepth || 1) + 1;
        if (!this._formContext || this._formContext.formDepth !== formDepth) {
            this._formContext = {
                onFormAction: this.onFormAction,
                getFormPath: this.getFormPath,
                getLayoutProps: this.getLayoutProps,
                formDepth,
            };
        }
        return this._formContext;
    }

    getLayoutProps = elementProps => {
        const horizontal = this.props.layout === 'horizontal';
        const { defaultLabelCol, defaultWrapperCol } = this.props;
        const extraProps = {};
        // These two should add up to the default grid size of 24
        const smLabelSpan = 6;
        const smWrapperSpan = 18;
        if (!elementProps.labelCol && horizontal) {
            if (typeof defaultLabelCol == 'function') {
                extraProps.labelCol = cloneDeep(defaultLabelCol(elementProps));
            } else {
                extraProps.labelCol = cloneDeep(defaultLabelCol) || {
                    xs: { span: 24 },
                    sm: { span: smLabelSpan },
                };
            }
        }
        if (!elementProps.wrapperCol && horizontal) {
            let labelColSpan =
                matchingColumnProps(elementProps.labelCol || extraProps.labelCol, 'sm') ||
                smLabelSpan;
            if (typeof labelColSpan == 'object') {
                labelColSpan = labelColSpan.span;
            }
            if (typeof defaultWrapperCol == 'function') {
                extraProps.wrapperCol = cloneDeep(defaultWrapperCol(elementProps));
            } else {
                extraProps.wrapperCol = cloneDeep(defaultWrapperCol) || {
                    xs: { span: 24 },
                    sm: { span: smWrapperSpan, offset: elementProps.label ? 0 : labelColSpan },
                };
            }
        }

        return extraProps;
    };

    /**
     * Get unique path to a field in a form. Used to generate matching htmlFor and id's on
     * labels and input fields respectively. The path is generated using the form name on
     * each form (they can be nested) and finally the field name itself. Note that fieldName
     * may be in dotted notation (eg. fridges[0].name) which actually contains the nested form
     * name as well (this is how redux-form works). In these cases we only use the last portion
     * and discard everything before it as that is contained in the form name as returned by
     * getFormPath(). As an example:
     * <Form name="kitchensink">
     *     <Form name="fridge">
     *        <Field name="name">
     *        <Form name="inventory">
     *          <Field name="name">
     *        </Form>
     *     </Form>
     *     <Field name="name" />
     * </Form>
     * Here there are 3 fields all called 'name' but the path to each is:
     * kitchensink.fridge.name
     * kitchensink.fridge.inventory.name
     * kitchensink.name
     *
     * TODO: This currently won't work properly if you use dotted notation in the name itself, eg.
     *
     * <Form name="myForm">
     *   <Form.Item label="blah">
     *     <Form.Field name="foo.bar.baz" widget={Test} />
     *   </Form.Item>
     *  </Form>
     *
     * In this case the output will be `myForm.baz`.  Currently dotted notation is expected to only be used when
     * nested forms are in play in which case it will resolve correct as each call to getFormPath will go via
     * the parent form.
     */
    getFormPath = fieldName => {
        const parts = [];
        if (this.context.getFormPath) {
            parts.push(this.context.getFormPath());
        }
        parts.push(this.props.name);
        if (fieldName) {
            parts.push(fieldName.split('.').pop());
        }
        return parts.join('.');
    };

    lastFormAction = '';

    // This is called via context from FormButton. We cache the form button pressed so that
    // in onSubmit it's available to us and we can include it in the data passed through
    // to this.props.onSubmit
    onFormAction = (action, triggerSubmit) => {
        this.lastFormAction = action;
        if (this.props.onFormAction) {
            this.props.onFormAction(action, { submit: this.props.submit, reset: this.props.reset });
        }
        if (triggerSubmit) {
            this.props.submit();
        }
        if (action === FORM_ACTIONS.CLEAR) {
            this.props.initialize(this.props.valuesOnClear);
        }
    };

    onSubmit = async data => {
        try {
            const action = this.lastFormAction;
            this.lastFormAction = '';
            return await this.props.onSubmit({ ...data, [SUBMISSION_ACTION_FIELD_NAME]: action });
        } catch (err) {
            // Capture any field errors that have no matching field on form and put
            // them in the catch all _error key
            if (err instanceof SubmissionError && err.errors) {
                const { store } = this.props.djradSite;
                // These fields use dot notation to store field names, eg.
                // kitchensink.fridges[0].name
                // corresponds to structure like:
                // {
                //    fridges: [{ name: '' }],
                // }
                const registeredFields = get(
                    store.getState(),
                    ['form', this.props.form, 'registeredFields'].join('.')
                );
                const unhandledErrors = getObjectFieldPaths(err.errors, true).reduce(
                    (acc, fieldPath) => {
                        // The errors are actually an array of values - we don't care about each value just that
                        // there are any values at all. As such we remove the array notation from the end. eg.
                        // {
                        //   fridges: [
                        //     {
                        //        name: ['error message'],
                        //     },
                        //   ],
                        // }
                        // Comes through as fridges[0].name[0] but we just need firdges[0].name as that matches
                        // redux form field registration name
                        fieldPath = fieldPath.replace(/\[[0-9]+\]$/, '');
                        if (!registeredFields[fieldPath] && fieldPath !== '_error') {
                            acc.push(`${fieldPath}: ${get(err.errors, fieldPath)}`);
                        }
                        return acc;
                    },
                    []
                );
                if (unhandledErrors.length > 0) {
                    let nonFieldErrors = err.errors._error || [];
                    if (typeof nonFieldErrors == 'string') {
                        nonFieldErrors = [nonFieldErrors];
                    }
                    const errors = {
                        ...err.errors,
                        // Make sure these error messages are unique
                        _error: [...new Set([...nonFieldErrors, ...unhandledErrors])],
                    };
                    throw new SubmissionError(errors);
                }
            } else {
                console.warn('Unexpected error on form', err); // eslint-disable-line
            }
            throw err;
        }
    };

    handleSubmit = maybeEvent => {
        // Event may not be available in the case of calling this.props.submit() directly
        // If it is we don't want submissions to propagate. Consider the case of forms
        // that are nested in React (eg. a Modal that renders a form using a portal - so
        // in the DOM the <form> elements aren't nested by in the React component structure
        // they are). It appears due to either internals of redux-form or the react event
        // system the submission event here ends up propagating up to the parent form causing
        // the parent form to submit when the child form submits (I use parent and child here
        // to indicate relationship within the component heirarchy, not to indicate a subform
        // which is handled using FormSection's).
        if (maybeEvent) {
            maybeEvent.stopPropagation();
        }
        return this.props.handleSubmit(this.onSubmit)(maybeEvent);
    };

    render() {
        // We don't want to pass through all redux form attributes as they aren't valid
        // for a <form> - just pass through whitelist.
        const validFormProps = pick(this.props, formAttributeWhitelist);
        const {
            className,
            children,
            footer,
            layout,
            submitFailed,
            renderErrors,
            error,
            wrapperComponent: WrapperComponent = this.context.formDepth > 1
                ? FormSection
                : ReduxForm,
        } = this.props;
        // We don't use the ant Form directly but it's expected the layout styles should work. Add
        // them here based on layout prop.
        const prefixCls = 'ant-form';
        const formClassName = cx(
            prefixCls,
            'djrad--form',
            {
                [`${prefixCls}-horizontal`]: layout === 'horizontal',
                [`${prefixCls}-vertical`]: layout === 'vertical',
                [`${prefixCls}-inline`]: layout === 'inline',
            },
            className
        );
        let errors = error;
        if (error && !Array.isArray(error)) {
            errors = [error];
        }
        return (
            <FormContext.Provider value={this.getContext()}>
                <WrapperComponent
                    {...validFormProps}
                    className={formClassName}
                    layout={layout}
                    // For nested forms we won't have a submit at all
                    onSubmit={this.props.handleSubmit && this.handleSubmit}
                >
                    {children}
                    {(submitFailed || errors) && renderErrors(errors)}
                    {footer && <FormItem fullWidth>{footer}</FormItem>}
                </WrapperComponent>
            </FormContext.Provider>
        );
    }
}

BaseForm = injectSite(BaseForm);

// TODO: Validation
const ConnectedForm = reduxForm()(BaseForm);

/**
 * Base Form component backed by [redux-form](https://redux-form.com).
 *
 * If you are working with a model you can use [ModelForm](/components/ModelForm/).
 *
 * For an overview of how to use forms see the [forms quickstart](/docs/quickstart/forms/)
 *
 * Also accepts all props accepted by [redux-form](https://redux-form.com/8.2.2/docs/api/reduxform.md/)
 */
export default class Form extends React.Component {
    static contextType = FormContext;

    static defaultProps = {
        valuesOnClear: {},
        layout: 'vertical',
        renderErrors: (errors = 'Please check your submission and try again') => (
            <FormItem fullWidth>
                <SubmissionErrors errors={errors} />
            </FormItem>
        ),
    };

    static propTypes = {
        /**
         * Name of the form. For top level forms this will be the redux state key for the underlying redux-form. For nested
         * forms it will be the name passed to [FormSection](https://redux-form.com/7.3.0/docs/api/formsection.md/) and will
         * dictate the key in the final data object the nested form data will appear under.
         */
        name: PropTypes.string.isRequired,
        /**
         * Initial values to populate form with. Should be a mapping of field name to field value.
         */
        initialValues: PropTypes.object,
        /**
         * When using custom form actions this function will be called if supplied.
         *
         * Receives:
         *
         * | Param | Type | Desc |
         * |-------|------|------|
         * |action | String | name of action called |
         * | callbacks | Object | object of callbacks to execute form related behaviour |
         * | callbacks.reset | Function | reset the form (accepts no parameters) |
         * | callbacks.reset | Function | submit the form (accepts no parameters) |
         *
         * @see [FormButton](/components/FormButton/) |
         */
        onFormAction: PropTypes.func,
        /**
         * Body of form to render.
         * Structure is:
         * ```js
         * <FormWrapperComponent>
         *     {children}
         *     {errors}
         *     {footer}
         * </FormWrapperComponent>
         * ```
         */
        children: PropTypes.node.isRequired,
        /** Element to render at bottom of form under `children` and any form errors */
        footer: PropTypes.node,
        /**
         * Controls the default layout of the form.
         * DOC_TODO: Link to layout docs
         */
        layout: PropTypes.oneOf(['inline', 'horizontal', 'vertical']),
        /**
         * Component to use to contain the form. By default for top level forms this will be a [Form](https://redux-form.com/7.3.0/docs/api/form.md/) and for nested
         * forms it will be a [FormSection](https://redux-form.com/7.3.0/docs/api/formsection.md/)
         */
        wrapperComponent: componentPropType,
        /** Values to use when clearing a form. Defaults to empty object. */
        valuesOnClear: PropTypes.object,
        /**
         * Called when any errors occur on the form.
         *
         * There are two types of errors - field level and global form errors.
         * Field level errors are rendered by FormItem and aren't accessible here.
         * This method will be called when _any_ errors occur. If there are _only_
         * field level errors then the `errors` passed to `renderErrors` will be
         * null. You can use this to render a generic message or return null to
         * render nothing.
         *
         * Global form errors typically come from the API endpoint returning a message
         * on the api_settings.NON_FIELD_ERRORS_KEY key. Any field level errors
         * returned that don't also have a matching field in the form will also be
         * included along with any errors passed directly to the form on the `errors`
         * prop.
         *
         * Defaults to rendering the `SubmissionErrors` component wrapped in a
         * <Form.Item fullWidth />. It will always render with a generic message if
         * there are only field level errors. To override this to only render something
         * if global errors are present use:
         *
         * ```
         * renderErrors={errors => errors && (
         *     <FormItem fullWidth>
         *         <SubmissionErrors errors={errors} />
               </FormItem>
         * )}
         * ```
         */
        renderErrors: PropTypes.func,
        /**
         * Default layout specification for label. eg. `{ span: 3, offset: 12 }`
         * Can be overridden at the [FormItem](/components/FormItem/#labelCol) level.
         * @see https://ant.design/components/grid/#Col
         */
        defaultLabelCol: PropTypes.object,
        /**
         * Layout specification for input controls.
         * Can be overridden at the [FormItem](/components/FormItem/#wrapperCol) level.
         * @see https://ant.design/components/grid/#Col
         */
        defaultWrapperCol: PropTypes.object,
        /**
         * The submission function that will be passed the form data as an object
         * indexed by field name when form is submitted.
         *
         * Should return a promise if performing an async action as a result of the
         * submission. This will set the loading state on the form.
         *
         * Errors can be passed through to the form by raising a [SubmissionError](https://redux-form.com/8.2.2/docs/api/submissionerror.md/).
         * See [handleErrorResponse](/api/js/form-utils/#handleErrorResponse) for converting
         * standard DRF error response to form errors.
         */
        onSubmit: PropTypes.func.isRequired,
    };

    render() {
        // forceConnected is a workaround for situations where we have nested forms in the component
        // hierarchy but they aren't really nested as is the case of Modals. The modal component may
        // be embedded within another form but it renders outside the form - so <form> tags work fine.
        const { name, forceConnected = false } = this.props;
        const FormComponent =
            this.context.formDepth > 1 && !forceConnected ? BaseForm : ConnectedForm;
        return <FormComponent name={name} form={name} {...this.props} />;
    }

    static Item = FormItem;
    static Field = FormField;
    static Button = FormButton;
    static ButtonBar = ButtonBar;
}
