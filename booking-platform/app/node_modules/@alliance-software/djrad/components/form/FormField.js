// @flow
import * as React from 'react';
import cx from 'classnames';
import get from 'lodash/get';
import type { FieldProps } from 'redux-form';
import type { InputProps } from 'redux-form/lib/FieldProps.types.js.flow';
import { Field } from 'redux-form';
import { FormItemContext, requiredClassName } from './FormItem';
import InputWidget from './widgets/InputWidget';

export type FormFieldMeta = {
    // Form name
    form: string,
    error?: string,
    warning?: string,
    initial?: any,
    active: boolean,
    asyncValidating: boolean,
    autofilled: boolean,
    dirty: boolean,
    invalid: boolean,
    pristine: boolean,
    submitting: boolean,
    submitFailed: boolean,
    touched: boolean,
    valid: boolean,
    visited: boolean,
};
export type BaseWidgetProps = {
    name: string,
    disabled: boolean,
    onBlur: (eventOrValue: Event | any) => void,
    onChange: (eventOrValue: Event | any) => void,
    onFocus: (e: Event) => void,
    meta: FormFieldMeta,
    children: ?React.Node,
};
export type WidgetProps = BaseWidgetProps & {
    value: any,
};
export type BaseFormFieldProps = {
    required?: boolean,
    name: string,
    disabled?: boolean,
    children?: ?React.ChildrenArray<any>,
    // I couldn't work out how to type this but this can also
    // be an element which will then be cloned
    widget?: ?React.ComponentType<WidgetProps> | React.Element<*>,
    reduxFormFieldComponent?: React.ComponentType<*>,
    placeholder?: string,
    id?: string,
    className?: string,
    type?: string,
    autoFocus?: boolean,
    style?: {},
};
export type ReduxFormFieldProps = {
    /** Supplied passed by redux-form */
    input: InputProps,
    /** Supplied passed by redux-form */
    meta: FormFieldMeta,
    /** Only available if used with FieldArray */
    fields?: Array<BaseFormFieldProps>,
};
export type FormFieldProps = BaseFormFieldProps & ReduxFormFieldProps;

function getName(props) {
    if (props.djradFieldName) {
        return props.djradFieldName;
    }
    if (props.input) {
        return props.input.name;
    }
    return props.name;
}

class PassErrorsUpField extends React.Component<FieldProps & FormFieldProps> {
    static contextType = FormItemContext;

    checkFieldErrorChange(prevField, nextField) {
        if (!this.context) {
            return;
        }
        if (getName(prevField) !== getName(nextField)) {
            this.context.unregisterError(getName(prevField));
        }
        if (
            prevField.meta.error !== nextField.meta.error ||
            (!prevField.meta.touched && nextField.meta.touched)
        ) {
            if (nextField.meta.error && Object.values(nextField.meta.error).length > 0) {
                if (nextField.meta.touched) {
                    this.context.registerError(getName(nextField), nextField.meta.error);
                }
            } else {
                this.context.unregisterError(getName(nextField));
            }
        }
    }

    componentDidUpdate(prevProps) {
        if (this.props.names) {
            // When multiple fields are present they exist under this.props[name] where name is the field name
            // Note that dot notation is supported (eg. fieldName.subFieldName) and so we use get() here.
            prevProps.names.map(name =>
                this.checkFieldErrorChange(get(prevProps, name), get(this.props, name))
            );
        } else {
            // For a single field it exists directly on props
            this.checkFieldErrorChange(prevProps, this.props);
        }
    }

    componentWillUnmount() {
        if (!this.context) {
            return;
        }
        if (this.props.names) {
            this.props.names.map(name => this.context.unregisterError(name));
        } else {
            this.context.unregisterError(getName(this.props));
        }
    }

    render() {
        // format and parse come through when reduxFormFieldComponent is FieldArray but not Field
        // redux-form docs don't mention it as a prop that should be passed through to your component.
        // Removing them here as we don't want them to go through to the widget - we expect to only
        // pass explicit props and standard handlers (onChange etc) through to widgets.
        const {
            format,
            parse,
            children,
            required,
            className,
            fields,
            input,
            widget,
            meta = {},
            disabled = meta.submitting,
            ...extraProps
        } = this.props;
        const finalClassName = cx(className, { [requiredClassName]: required });
        let InputComponent = widget;
        if (!InputComponent) {
            InputComponent = InputWidget;
        }
        const finalProps = {
            ...input,
            ...extraProps,
            className: finalClassName,
            fields,
            disabled,
            meta,
        };
        if (React.isValidElement(InputComponent)) {
            // $FlowFixMe
            return React.cloneElement(InputComponent, finalProps, ...(children || []));
        }
        return (
            // $FlowFixMe
            <InputComponent {...finalProps}>{children}</InputComponent>
        );
    }
}

export default function FormField(props: BaseFormFieldProps): React.Element<typeof Field> {
    const { reduxFormFieldComponent: FieldComponent = Field, ...rest } = props;
    return <FieldComponent {...rest} component={PassErrorsUpField} />;
}
