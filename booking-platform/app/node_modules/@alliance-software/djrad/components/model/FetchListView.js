// @flow
import * as React from 'react';
import { withRouter } from 'react-router';
import type { Location, Match, RouterHistory } from 'react-router-dom';
import isEqual from 'lodash/isEqual';
import { appendToUrl, parseLocationQuery } from '../../util/url';
import ModelFetchList from './ModelFetchList';
import type { Model } from '../../model/Model';

type PaginationConfig = {
    showSizeChanger?: boolean,
    defaultPageSize?: number,
    onChange: (page: number, newSize: number) => void,
    pageSize: number,
    current: number,
    total: number,
};

type Pagination = {
    pageSize: number,
    current: number,
    total: number,
};

type Sorter = {
    field?: string,
    order?: string,
};

export type ListViewProps = {
    model: Class<Model>,
    data: Array<Model>,
    /** @deprecated Use isLoading instead */
    loading: boolean,
    isLoading: boolean,
    onChange: (pagination: Pagination, filters: ?{}, sorter: Sorter) => void,
    pagination: false | PaginationConfig,
    forceRefetch: () => Promise<*>,
    filter: ?{},
    onFilterChange: (filter: {}) => void,
};

export type ListFilterProps = {
    model: Class<Model>,
    data: Array<Model>,
    isLoading: boolean,
    onTableChange: (pagination: Pagination, filters: ?{}, sorter: Sorter) => void,
    pagination: false | PaginationConfig,
    forceRefetch: () => Promise<*>,
    filter: ?{},
    form: string,
    onSubmit: (data: {}) => void,
    onChange?: ?(filters: ?{}) => void,
};

type Props = {
    /** The model to fetch records for */
    model: Class<Model>,
    /** A filter to apply to all API calls */
    baseFilter?: { [fieldName: string]: any },
    /** Default filter to use when none has been specified. If syncUrl is true and no filter is set URL will be redirected to include defaultFilter */
    defaultFilter?: { [fieldName: string]: any },
    /** Callback to render the list of fetched records */
    renderList: (listProps: ListViewProps) => React.Element<any>,
    /** Optional callback to render a filter above the list */
    renderFilter?: (filterProps: ListFilterProps) => React.Element<any>,
    /** Set to true to hide pagination when there's only 1 page */
    paginationAutoHide?: boolean,
    /** Set to false to disable pagination otherwise specify pagination preferences */
    pagination?:
        | boolean
        | {
              showSizeChanger?: boolean,
              defaultPageSize?: number,
          },
    /** If set any filter or pagination changes will be persisted in and loaded from the URL */
    syncUrl?: boolean,
    /** Optionally limit data fetch to include only these field names. Useful for keeping API calls fast & small by only fetching what you use. */
    partialRecordFieldNames?: Array<string>,
    /** Generate payload for API call. Can be used to transform filters do different format expected by backend */
    generateFetchPayload?: (page: number, pageSize: number, filter: ?{}) => ?{},
    /** @ignore */
    location: Location,
    /** @ignore */
    match: Match,
    /** @ignore */
    history: RouterHistory,
};

type State = {
    sortBy: ?string,
};

/**
 * Fetches records for the specified `model` and renders them using specified `renderList` callback. Handles
 * pagination and optional filtering.
 *
 * Accepts all props accepted by [ModelFetchList](/components/ModelFetchList/)
 *
 * > Since v0.26 the recommended approach is to implement a custom hook that uses
 * > [useListModel](/api/js/hooks/#useListModel) for fetching data, [useUrlQueryState](/api/js/hooks/#useUrlQueryState)
 * > for syncing to the URL. This allows you to control the defaults and define
 * > the standard specific to your project. For an example implementation see
 * > useListView in the django template project.
 *
 * @acceptsProps ModelFetchList
 */
export class FetchListView extends React.Component<Props, State> {
    static defaultProps = {
        baseFilter: null,
        syncUrl: false,
        pagination: true,
        paginationAutoHide: false,
    };

    // Prop to track whether we are doing an initial redirect to set default filters
    // This is necessary to avoid initial render without default while we wait for
    // re-render to occur as a result of route change.
    isRedirecting = false;

    constructor(props: Props) {
        super(props);
        const { syncUrl, history, location, match, defaultFilter } = this.props;
        const query = parseLocationQuery(location);
        if (syncUrl && defaultFilter && !query.filter) {
            query.filter = JSON.stringify(defaultFilter);
            history.replace(appendToUrl(match.url, '', { query }));
            // Flag property on component to indicate a redirect is occurring. We always
            // reset this flag in componentDidMount which happens immediately after
            // initial render.
            this.isRedirecting = true;
        }
    }

    componentDidMount() {
        this.isRedirecting = false;
    }

    render() {
        if (this.isRedirecting) {
            return null;
        }
        const {
            model,
            match,
            history,
            location,
            renderList,
            renderFilter,
            partialRecordFieldNames,
            generateFetchPayload,
            defaultFilter,
            baseFilter,
            syncUrl,
            pagination,
            paginationAutoHide,
            ...rest
        } = this.props;
        let paginationConfig = {};
        if (pagination && pagination !== true) {
            paginationConfig = pagination;
        }
        const extraProps: Object = { ...rest };
        if (syncUrl) {
            const query = parseLocationQuery(location);
            extraProps.filter = null;
            if (typeof query.filter == 'string') {
                extraProps.filter = JSON.parse(query.filter);
            }
            extraProps.page = Number(query.page || 1);
            if (query.pageSize) {
                extraProps.pageSize = Number(query.pageSize);
            }
        }
        if (partialRecordFieldNames) {
            extraProps.partialRecordFieldNames = partialRecordFieldNames;
        }
        if (paginationConfig && paginationConfig.defaultPageSize) {
            extraProps.defaultPageSize = paginationConfig.defaultPageSize;
        }
        if (generateFetchPayload) {
            extraProps.generateFetchPayload = generateFetchPayload;
        }
        return (
            <ModelFetchList
                model={model}
                defaultFilter={defaultFilter}
                baseFilter={baseFilter}
                {...extraProps}
            >
                {({
                    isLoading,
                    count,
                    pageSize,
                    records,
                    currentPage,
                    gotoPage,
                    filter,
                    setFilter,
                    forceRefetch,
                }) => {
                    const getUrlFilter = _filter => {
                        const urlFilter = { ...(_filter || {}) };
                        if (baseFilter) {
                            Object.keys(baseFilter).forEach(filterName => {
                                delete urlFilter[filterName];
                            });
                        }
                        return urlFilter;
                    };
                    let finalPagination;
                    if (!pagination || (paginationAutoHide && count <= pageSize)) {
                        finalPagination = false;
                    } else {
                        finalPagination = {
                            ...paginationConfig,
                            pageSize,
                            current: currentPage,
                            onShowSizeChange: (currentSize: number, newSize: number) => {
                                if (syncUrl) {
                                    const query: {
                                        page: number,
                                        pageSize: number,
                                        filter?: string,
                                    } = {
                                        page: currentPage,
                                        pageSize: newSize,
                                    };
                                    const urlFilter = getUrlFilter(filter);
                                    if (Object.keys(urlFilter).length > 0) {
                                        query.filter = JSON.stringify(urlFilter);
                                    }
                                    history.push(appendToUrl(match.url, '', { query }));
                                } else {
                                    gotoPage(currentPage, newSize);
                                }
                            },
                            onChange: (page: number, newSize: number) => {
                                if (syncUrl) {
                                    const query: {
                                        page: number,
                                        pageSize: number,
                                        filter?: string,
                                    } = {
                                        page,
                                        pageSize: newSize,
                                    };
                                    const urlFilter = getUrlFilter(filter);
                                    if (Object.keys(urlFilter).length > 0) {
                                        query.filter = JSON.stringify(urlFilter);
                                    }
                                    history.push(appendToUrl(match.url, '', { query }));
                                } else {
                                    gotoPage(page, newSize);
                                }
                            },
                            total: count,
                        };
                    }

                    const handleFilterChange = newFilter => {
                        if (syncUrl) {
                            const query: { page: number, pageSize: number, filter?: string } = {
                                page: 1,
                                pageSize,
                            };
                            const urlFilter = getUrlFilter(newFilter);
                            if (urlFilter && Object.keys(urlFilter).length > 0) {
                                query.filter = JSON.stringify(urlFilter);
                            }
                            history.push(appendToUrl(match.url, '', { query }));
                        } else {
                            setFilter(newFilter);
                        }
                        if (isEqual(newFilter, filter)) {
                            // Trigger a refetch when the filter is applied but is the same. This handles the case where user
                            // re-submits the form without changing the filter (this wouldn't trigger a refetch as
                            // the props are the same).
                            forceRefetch();
                        }
                    };

                    const handleTableChange = (
                        nextPagination: Pagination,
                        filters: ?{},
                        sorter: Sorter
                    ) => {
                        // As of antd 3.15.2 field will always be set when you click a
                        // column. Order will be one of `sortDirections` which defaults
                        // to ['ascend', 'descend'].
                        const { field, order } = sorter;
                        if (field && order) {
                            const ordering = (order === 'descend' ? '-' : '') + field;
                            // As handleFilterChange resets to page 1 only do this if ordering has
                            // actually changed
                            if (!filter || filter.ordering !== ordering) {
                                handleFilterChange({ ...filter, ordering });
                            }
                        } else if (filter && filter.ordering) {
                            const newFilter = { ...filter };
                            delete newFilter.ordering;
                            handleFilterChange(newFilter);
                        }
                    };

                    const listProps = {
                        model,
                        data: records,
                        loading: isLoading,
                        isLoading,
                        onChange: handleTableChange,
                        pagination: finalPagination,
                        filter,
                        forceRefetch,
                        onFilterChange: handleFilterChange,
                    };
                    return (
                        <React.Fragment>
                            {renderFilter &&
                                renderFilter({
                                    model,
                                    data: records,
                                    onTableChange: handleTableChange,
                                    pagination: finalPagination,
                                    filter,
                                    forceRefetch,
                                    isLoading,
                                    form: `${model._meta.modelId}_listFilter`,
                                    onSubmit: handleFilterChange,
                                    initialValues: filter,
                                })}
                            {renderList(listProps)}
                        </React.Fragment>
                    );
                }}
            </ModelFetchList>
        );
    }
}

export default withRouter(FetchListView);
