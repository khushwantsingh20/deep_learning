// @flow
import * as React from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { initialize, reset, SubmissionError } from 'redux-form';
// eslint-disable-next-line import/no-unresolved
import type { Initialize, Reset } from 'redux-form/lib/actions.types';
import { message } from 'antd';
import type { Location, RouterHistory } from 'react-router-dom';
import { createModel, updateModel } from '../../actions';

import { ApiError } from '../../api';
import { FORM_ACTIONS } from '../../components/form/FormButton';
import type { FormActionType } from '../../components/form/FormButton';
import Form, { SUBMISSION_ACTION_FIELD_NAME } from '../../components/form/Form';
import type { Model } from '../../model/Model';
import type { ModelId } from '../../model/types';
import { ActionUrlContext } from '../../site/components/context';
import injectSite from '../../site/injectSite';
import Site from '../../site/Site';
import withLastLocation from '../routing/withLastLocation';

export type RenderModelFormProps = {
    record?: Model,
    formName: string,
    destroyOnUnmount?: boolean,
    initialValues?: {},
    model: Class<Model>,
    onFormAction: (action: FormActionType) => void,
    onSubmit: (data: Object) => Promise<void>,
    onSubmitFail: () => void,
};

type Props = {
    /** @ignore */
    djradSite: Site,
    formName: string,
    /** Optional function to transform data after for submission but before it's sent to the API endpoint. Receives data and the action prop of the `FormButton` pressed. */
    transformData: (data: {}, buttonAction: string) => {},
    /** Initial values for form. If not specified and `record` has been provided defaults to `record.toJS()` */
    initialValues?: {},
    /** Whether to destroy form on unmount. See redux-form for more details. */
    destroyOnUnmount?: boolean,
    /** Function that renders the form */
    renderForm: (renderProps: RenderModelFormProps) => React.Element<React.ComponentType<Form>>,
    /** Model the form is for. Optional if `record` is provided. */
    model: Class<Model>,
    /** @ignore */
    history: RouterHistory,
    /** @ignore */
    lastLocation?: Location,
    /** Instance of Model when updating a record */
    record?: Model,
    /** Function called when form submission is successful */
    onSuccess?: (
        record: Model,
        relatedRecords: { [ModelId]: { [recordId: string | number]: Model } },
        action: FormActionType,
        extra: { history: RouterHistory, response: any }
    ) => void,
    /** Api action function to call. Should be a redux action and it _will_ be dispatched for you so you don't need to manually bind it. Defaults to `updateModel` when `record` is passed otherwise `createModel`. */
    apiAction?: (modelOrRecord: Class<Model> | Model, data: {}, submitAction: string) => Promise<*>,
};

type CombinedProps = Props & {
    /** @ignore */
    initializeForm: Initialize,
    /** @ignore */
    resetForm: Reset,
    /** @ignore */
    dispatch: (action: any) => any,
};

/**
 * > Legacy use only. For all new applications use
 * > [useModelFormProcessor](/api/js/hooks/#useModelFormProcessor) instead
 */
class ModelFormProcessor extends React.Component<CombinedProps> {
    static defaultProps = {
        transformData: data => data,
    };

    static contextType = ActionUrlContext;

    handleFormAction = (action: FormActionType) => {
        if (this.props.record && action === FORM_ACTIONS.DELETE) {
            const { model, record, history } = this.props;
            const url = this.context.getActionUrl(model, 'delete', { id: record.getId() });
            history.push(url);
        }
    };

    handleSubmitFail = () => {
        // Scroll to first error
        const el = document.querySelector('.has-error');
        if (el) {
            const input = el.querySelector && el.querySelector('input');
            if (el.scrollIntoView) {
                el.scrollIntoView();
            }
            if (input) {
                input.focus();
            }
        }
    };

    handleSubmit = (data: Object) => {
        const { record, onSuccess, history, djradSite } = this.props;
        const {
            [SUBMISSION_ACTION_FIELD_NAME]: action = FORM_ACTIONS.SAVE,
            ...dataNoAction
        } = data;
        const finalData = this.props.transformData(dataNoAction, action);
        const model = djradSite.getModelClass(this.props.model);

        const { apiAction } = this.props;
        const params = record ? [record, finalData] : [model, finalData];
        let promise;
        if (apiAction) {
            promise = this.props.dispatch(apiAction(...params, action));
        } else {
            const defaultApiAction = record ? updateModel : createModel;
            promise = this.props.dispatch(defaultApiAction(...params));
        }
        return promise.then(
            response => {
                // TODO:
                if (onSuccess) {
                    onSuccess(response.record, response.recordsByModelId, action, {
                        history,
                        response,
                    });
                } else {
                    message.success(
                        !record ? 'Record created successfully' : 'Record saved successfully'
                    );
                    switch (action) {
                        case FORM_ACTIONS.SAVE_AND_CONTINUE: {
                            if (!record) {
                                const url = this.context.getActionUrl(model, 'update', {
                                    id: response.record.getId(),
                                });
                                history.push(url);
                            } else {
                                this.props.initializeForm(
                                    this.props.formName,
                                    response.record.toJS(),
                                    false,
                                    {}
                                );
                            }
                            break;
                        }
                        case FORM_ACTIONS.SAVE_AND_ADD_ANOTHER: {
                            this.props.resetForm(this.props.formName);
                            const { getActionUrl } = this.context;
                            const url = getActionUrl(model, 'create');
                            history.push(url);
                            break;
                        }
                        default:
                            // Only use goBack if we know there was a previous page. This prevents
                            // issues like visiting the page directly in a new tab - going back in this
                            // case goes back to the new tab page in the browser. Also prevents leaving
                            // the site - lastLocation won't be set if user got to this page from outside
                            // the app (lastLocation just tracks the internal react-router location changes)
                            if (this.props.lastLocation) {
                                history.goBack();
                            } else {
                                // Otherwise choose a valid model action URL to go back to with a preference
                                // for the detail route first.
                                const { getActionUrl } = this.context;
                                const validActions = model._meta.getValidLinkActions({
                                    recordOnly: true,
                                });
                                if (validActions.length) {
                                    const urlParams = { id: response.record.getId() };
                                    if (validActions.includes('detail')) {
                                        history.push(getActionUrl(model, 'detail', urlParams));
                                    } else {
                                        history.push(
                                            getActionUrl(model, validActions[0], urlParams)
                                        );
                                    }
                                }
                            }
                    }
                }
            },
            (apiError: ApiError | Error) => {
                // instanceof ApiError doesn't work, some issues with extending built in Error types
                if (
                    apiError &&
                    typeof apiError == 'object' &&
                    apiError.status === 400 &&
                    apiError.response
                ) {
                    const errors = apiError.response;
                    let finalErrors = errors;
                    if (errors && typeof errors == 'object' && errors.nonFieldErrors) {
                        const { nonFieldErrors, ...rest } = errors;
                        finalErrors = {
                            ...rest,
                            _error: nonFieldErrors,
                        };
                    }
                    // $FlowFixMe
                    throw new SubmissionError(finalErrors);
                }
                console.error(apiError); // eslint-disable-line
                throw new SubmissionError({
                    _error: 'Unexpected error. Please try again.',
                });
            }
        );
    };

    render() {
        const { renderForm, record, formName, destroyOnUnmount, model, initialValues } = this.props;
        const formProps = {
            record,
            formName,
            destroyOnUnmount,
            model,
            initialValues,
            onFormAction: this.handleFormAction,
            onSubmit: this.handleSubmit,
            onSubmitFail: this.handleSubmitFail,
        };
        return renderForm(formProps);
    }
}

const actions = {
    initializeForm: initialize,
    resetForm: reset,
};
function mapDispatchToProps(dispatch) {
    return {
        dispatch,
        ...bindActionCreators(actions, dispatch),
    };
}

function mapStateToProps(state, props) {
    const { record } = props;
    let { model, initialValues } = props;
    // If record is provided we can infer model from it
    if (!model && record) {
        model = record;
    }
    // If no initialValues have been provided and a record has use the record to generate
    if (initialValues === undefined && record) {
        initialValues = record.toJS();
    }

    return {
        model,
        initialValues,
    };
}

const EnhancedModelFormProcessor: React.ComponentType<Props> = withLastLocation(
    injectSite(
        connect(
            mapStateToProps,
            mapDispatchToProps
        )(ModelFormProcessor)
    )
);

export default EnhancedModelFormProcessor;
