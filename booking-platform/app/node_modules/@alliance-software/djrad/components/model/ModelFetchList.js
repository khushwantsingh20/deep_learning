// @flow
import * as React from 'react';
import isEqual from 'lodash/isEqual';
import oneLine from 'common-tags/lib/oneLine';

import injectSite from '../../site/injectSite';
import connectModel from './connectModel';
import type { ConnectModelProps } from './connectModel';
import type { InjectSiteProps } from '../../site/injectSite';
import type { Model } from '../../model/Model';

type RenderProps = {
    error: ?string,
    records: Array<Model>,
    filter: ?{},
    setFilter: (filter: {}) => void,
    currentPage: number,
    totalPages: number,
    gotoPage: (pageNumber: number, pageSize: number) => void,
    pageSize: number,
    isLoading: boolean,
    count: number,
    forceRefetch: () => Promise<*>,
};

type Props = {
    /** model to fetch data for */
    model: Class<Model>,
    defaultPageSize?: number,
    /** Defines a filter that applies to every API call. */
    baseFilter?: ?{},
    /** Default filter to use when none has been specified. */
    defaultFilter?: { [string]: any },
    /** If specified this component becomes uncontrolled and `gotoPage` function can no longer be used */
    page?: number,
    pageSize?: number,
    /** Optional filter to pass through to API. If specified this component becomes uncontrolled and `setFilter` function can no longer be used */
    filter?: ?{},
    /** Optionally specify limited list of fields to retrieve from API */
    partialRecordFieldNames?: Array<string>,
    /** Function that handles rendering the result */
    children: (props: RenderProps) => React.Element<any>,
    /**
     * Control when data is refetched. Options are:
     * add - whenever a new record of same type is added to the redux store
     * delete - whenever any record of same type is deleted from redux
     * update - whenever any record of same type is updated in redux
     * Data is always read from the cache so you can get away with not
     * refetching on update in most cases. It defaults to refetching in all
     * cases so things like changes in ordering will properly be handled.
     */
    refetchOn?: Array<'add' | 'delete' | 'update'>,
    /** Generate payload for API call. Can be used to transform filters to different format expected by backend */
    generateFetchPayload: (page: number, pageSize: number, filter: ?{}) => ?{},
};

type State = {
    count: number,
    filter: ?{},
    error: ?string,
    recordIds: Array<string | number>,
    currentPage: number,
    totalPages: number,
    pageSize: number,
    isLoading: boolean,
};

type CombinedProps = InjectSiteProps & Props & ConnectModelProps;

const defaultPageSize = 20;

/**
 * Fetch a list of records
 *
 * > In most cases [useListModel](/api/js/hooks/#useListModel) is more flexible
 * > and should be used in preference to this component.
 */
class ModelFetchList extends React.Component<CombinedProps, State> {
    hasMounted: boolean = false;
    controlledProps: { page: boolean, filter: boolean } = { page: true, filter: true };
    // Just using this to make test cases easier
    getRecordsPromise: Promise<void>;

    static defaultProps = {
        refetchOn: ['delete', 'add', 'update'],
        defaultPageSize,
        generateFetchPayload: (page: number, pageSize: number, filter: ?{}) => ({
            page,
            pageSize,
            ...filter,
        }),
    };

    state = {
        count: 0,
        error: null,
        filter: this.props.defaultFilter,
        recordIds: [],
        currentPage: 1,
        pageSize: this.props.defaultPageSize || defaultPageSize,
        totalPages: 0,
        isLoading: false,
    };

    constructor(props) {
        super(props);
        this.controlledProps.page = props.page == null;
        // We accept filter={null} as indicating uncontrolled (ie. you want to clear filters)
        this.controlledProps.filter = props.filter === undefined;
    }

    gotoPage = (pageNumber: number, pageSize: number) => {
        if (!this.controlledProps.page) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList is not in control of pagination props so calling gotoPage will do
                nothing. To change page pass in the "page" prop or change to using controlled
                version by excluding "page" prop entirely.`);
            /* eslint-enable */
            return;
        }
        if (!pageSize) {
            pageSize = this.state.pageSize || this.props.defaultPageSize;
        }
        this.setState({ currentPage: pageNumber, pageSize });
    };

    setFilter = (filter: {}) => {
        if (!this.controlledProps.page) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList is not in control of filter props so calling setFilter will do
                nothing. To change filter pass in the "filter" prop or change to using controlled
                version by excluding "filter" prop entirely.`);
            /* eslint-enable */
            return;
        }
        this.setState({
            filter: Object.keys(filter).reduce((acc, key) => {
                const value = filter[key];
                // Exclude any null/undefined values - these represent filters that have been removed
                if (value == null) {
                    return acc;
                }
                acc[key] = value;
                return acc;
            }, {}),
            currentPage: 1,
        });
    };

    getPage(props = this.props, state = this.state): number {
        if (this.controlledProps.page) {
            return state.currentPage;
        }
        return props.page || 1;
    }

    getPageSize(props = this.props, state = this.state): number {
        if (this.controlledProps.page) {
            return state.pageSize;
        }
        return props.pageSize || props.defaultPageSize || defaultPageSize;
    }

    getFilter(props = this.props, state = this.state): ?{} {
        const { baseFilter } = props;
        let filter;
        if (this.controlledProps.filter) {
            filter = state.filter;
        } else {
            filter = props.filter;
        }
        if (baseFilter) {
            if (!filter) {
                return baseFilter;
            }
            return { ...filter, ...baseFilter };
        }
        return filter;
    }

    getPayload(props = this.props, state = this.state) {
        return props.generateFetchPayload(
            this.getPage(props, state),
            this.getPageSize(props, state),
            this.getFilter(props, state)
        );
    }

    refetch = () => {
        this.getRecordsPromise = this.getRecords();
        return this.getRecordsPromise;
    };

    async getRecords(): Promise<void> {
        if (!this.hasMounted) {
            return;
        }
        this.setState({ isLoading: true, error: null });
        const filter = this.getPayload();
        try {
            let fetchOptions;
            if (this.props.partialRecordFieldNames) {
                fetchOptions = {
                    partialRecordFieldNames: this.props.partialRecordFieldNames,
                };
            }
            const data = await this.props.djradSite.api.listModel(
                this.props.model._meta.modelId,
                filter,
                fetchOptions
            );
            const { count, ids } = data;
            if (this.hasMounted) {
                this.setState({
                    isLoading: false,
                    count,
                    totalPages: Math.ceil(data.count / this.getPageSize()),
                    recordIds: ids,
                });
            }
        } catch (error) {
            console.error('Unexpected error', error); // eslint-disable-line
            const response = (error || {}).response || {};
            const { message = 'Unexpected server error' } = response;
            if (this.hasMounted) {
                this.setState({
                    isLoading: false,
                    error: message,
                });
            }
        }
    }

    componentDidUpdate(prevProps: CombinedProps, prevState: State) {
        if (this.controlledProps.page && (this.props.page || this.props.pageSize)) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList(${this.props.model._meta.modelId}) is changing from 
                controlling pagination to uncontrolled. You should not switch from
                controlled to uncontrolled (or vice versa). Decide between using as 
                controlled or uncontrolled for the lifetime of the component`);
            /* eslint-enable */
        }
        if (!this.controlledProps.page && this.props.page == null) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList(${this.props.model._meta.modelId}) is changing from 
                uncontrolled pagination to controlled. You should not switch from 
                uncontrolled to controlled (or vice versa). Decide between using as 
                uncontrolled or controlled for the lifetime of the component`);
            /* eslint-enable */
        }
        if (this.controlledProps.filter && this.props.filter !== undefined) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList(${this.props.model._meta.modelId}) is changing from 
                controlling filter to uncontrolled. You should not switch from
                controlled to uncontrolled (or vice versa). Decide between using as 
                controlled or uncontrolled for the lifetime of the component`);
            /* eslint-enable */
        }
        if (!this.controlledProps.filter && this.props.filter === undefined) {
            /* eslint-disable */
            console.warn(oneLine`
                ModelFetchList(${this.props.model._meta.modelId}) is changing from 
                uncontrolled filter to controlled. You should not switch from 
                uncontrolled to controlled (or vice versa). Decide between using as 
                uncontrolled or controlled for the lifetime of the component`);
            /* eslint-enable */
        }
        const prevPayload = this.getPayload(prevProps, prevState);
        const payload = this.getPayload();
        let { refetchOn } = this.props;
        if (refetchOn == null) {
            refetchOn = [];
        }
        if (!isEqual(prevPayload, payload) || prevProps.model !== this.props.model) {
            this.refetch();
        } else if (this.props.records) {
            if (refetchOn.includes('delete') && this.props.records.size < prevProps.records.size) {
                this.refetch();
            } else if (
                refetchOn.includes('add') &&
                this.props.records.size > prevProps.records.size
            ) {
                this.refetch();
                // $FlowFixMe: equals failing as expects Iterable but gets KeyedCollection... but KeyedCollection extends Iterable so appears to be a flow issue
            } else if (
                refetchOn.includes('update') &&
                !this.props.records.equals(prevProps.records)
            ) {
                // Note that we have to to a .equals call here rather than !== because
                // the partial fields selector currently results in a new object each
                // time
                // TODO: ^ Is it possible to resolve this?
                this.refetch();
            }
        }
    }

    componentDidMount() {
        this.hasMounted = true;
        this.refetch();
    }

    componentWillUnmount() {
        this.hasMounted = false;
    }

    render() {
        const { error, isLoading, totalPages, count, recordIds } = this.state;
        const { records } = this.props;
        let finalRecords = [];
        if (records) {
            finalRecords = recordIds.map(id => records.get(id)).filter(r => !!r);
        }
        return this.props.children({
            error,
            records: finalRecords,
            currentPage: this.getPage(),
            filter: this.getFilter(),
            totalPages,
            gotoPage: this.gotoPage,
            setFilter: this.setFilter,
            pageSize: this.getPageSize(),
            isLoading,
            count,
            forceRefetch: this.refetch,
        });
    }
}

function getSelector(model: Class<Model>, state, props) {
    const { partialRecordFieldNames } = props;
    if (partialRecordFieldNames != null) {
        return model.selectors.partialFields.synced(state)(partialRecordFieldNames);
    }
    return model.selectors.all(state);
}
// Exporting injectSite() directly doesn't seem to work when you go to use it - complains
// about not passing in the injected props. Adding explicit annotation here fixes it. (flow)
const ModelFetchListEnhanced: React.ComponentType<Props> = connectModel(
    props => props.model,
    getSelector
)(injectSite(ModelFetchList));

export default ModelFetchListEnhanced;
