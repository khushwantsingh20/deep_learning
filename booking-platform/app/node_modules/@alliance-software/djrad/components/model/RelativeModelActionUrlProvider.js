// @flow
import * as React from 'react';
import type { Match } from 'react-router-dom';
import type { Model } from '../../model/Model';
import type { ModelId } from '../../model/types';
import { ActionUrlContext } from '../../site/components/context';

type Props = {
    /** The react-router match links under this should be relative to */
    relativeToMatch: Match,
    /**
     * URL part to use after `relativeToMatch`. In not provided uses the default model prefix.
     * If you had a model Course that had a default prefix of /courses/ and your match URL was
     * `/my-site/base/` then the output when urlBase is not provided would be `/my-site/base/courses/`.
     * If you set `urlBase` to `c` it would be `/my-site/base/courses/` or an empty string would
     * be `/my-site/base/`.
     */
    urlBase: ?string,
    /**
     * If provided only models that match this whitelist will have links generated relative
     * to this component.
     */
    modelWhitelist: ?Array<Model>,
    children: React.Node,
};

/**
 * Provider that means URL's created within by descendant components will be relative
 * to the specified match. This can be used to nest model routes, eg. to have list /
 * add / update / delete routes for related models on a model view.
 *
 * Works with links created with [ActionLink](/components/ActionLink/) or manually
 * via getActionUrl from context.
 */
export default class RelativeModelActionUrlProvider extends React.Component<Props> {
    static contextType = ActionUrlContext;

    getWhitelist() {
        if (!this.props.modelWhitelist) {
            return null;
        }
        return this.props.modelWhitelist.map(modelOrId => {
            if (typeof modelOrId != 'string') {
                return modelOrId._meta.modelId;
            }
            return modelOrId;
        });
    }

    getActionUrl = (
        modelClass: Class<Model> | Model | ModelId,
        action: string,
        params: {},
        options?: {} = {}
    ) => {
        const finalOptions = {
            match: this.props.relativeToMatch,
            urlBase: this.props.urlBase,
            ...options,
        };
        const whitelist = this.getWhitelist();
        const modelId = typeof modelClass != 'string' ? modelClass._meta.modelId : modelClass;
        if (whitelist && whitelist.indexOf(modelId) === -1) {
            return this.context.getActionUrl(modelClass, action, params, options);
        }
        return this.context.getActionUrl(modelClass, action, params, finalOptions);
    };

    _providedContext = { getActionUrl: this.getActionUrl };

    render() {
        return (
            <ActionUrlContext.Provider value={this._providedContext}>
                {this.props.children}
            </ActionUrlContext.Provider>
        );
    }
}
