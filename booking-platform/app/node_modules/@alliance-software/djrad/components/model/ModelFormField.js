// @flow
import * as React from 'react';
import PropTypes from 'prop-types';
import FormField from '../form/FormField';
import ModelFormContext from './modelFormContext';
import ModelFormFieldWidget from './ModelFormFieldWidget';
import type { WidgetProps } from '../form/FormField';
import componentPropType from '../../prop-types/component';

type Props = {
    /**
     * For multi-value fields like LookupChoiceField or RangeField djradFieldName may be used in place
     * of the 'name' prop. This is because when using redux-form Fields option it passes through
     * each field on a prop that matches the field name - so if you have a field 'name' it will
     * conflict with the 'name' prop used to identify the name of the field. This is true of all
     * props here unfortunately - for now not worrying about others as likely requires a big refactor
     * to support.
     */
    djradFieldName: ?string,
    /** Name of the field */
    name: string,
    className?: string,
    /** @deprecated Use isUserDefinedField instead */
    custom?: boolean,
    /** Set to true if `name` doesn't exist on model */
    isUserDefinedField?: boolean,
    /** Is field required? Adds a class to field for styling. Defaults to Model field `required` value. */
    required?: boolean,
    /** The widget to use for rendering this field */
    widget?: ?React.ComponentType<WidgetProps>,
    /** @deprecated Optional props to pass through to widget. Can now be passed through directly to `ModelFormField` */
    widgetProps?: {},
    /**
     * redux-form component to use - should be one of [Field](https://redux-form.com/7.3.0/docs/api/field.md/) or [FieldArray](https://redux-form.com/7.3.0/docs/api/fieldarray.md/).
     * Defaults to using component specified by model Field class.
     */
    reduxFormFieldComponent?: React.ComponentType<*>,
};

const propTypes = {
    djradFieldName: PropTypes.string,
    name: PropTypes.string.isRequired,
    className: PropTypes.string,
    custom: PropTypes.bool,
    isUserDefinedField: PropTypes.bool,
    required: PropTypes.bool,
    widget: PropTypes.oneOfType([componentPropType, PropTypes.node]),
    widgetProps: PropTypes.object,
    reduxFormFieldComponent: componentPropType,
};

/**
 * Create a `FormField` with widget and other props dictated by the type of field.
 *
 * Must be a child of a [ModelFormItem](/components/ModelFormItem/) and that within a [ModelForm](/components/ModelForm/)
 *
 * - Sets up form field format / parse functions based on the underlying model `Field` class.
 * - If no widget is specified sets it to [ModelFormFieldWidget](/components/ModelFormFieldWidget/)
 * - Sets required based on underlying field `required` value if not specified
 * - Chooses the underlying redux-form component to used; this allows list / repeater fields to use
 *   `FieldArray` and single fields use `Field`.
 *
 * DOC_TODO: Link to docs about how widgets are chosen based on field type
 * @acceptsProps FormField
 */
export default class ModelFormField extends React.Component<Props> {
    static contextType = ModelFormContext;
    static propTypes = propTypes;

    /**
     * Parse value. See https://redux-form.com/7.3.0/docs/api/field.md/#-code-parse-value-name-gt-parsedvalue-code-optional-
     * @param value {*} value to parse
     * @param name {String} only available when [Fields](https://redux-form.com/7.3.0/docs/api/fields.md/) is
     * used (see RangeField)
     * @returns {*}
     */
    parse = (value: any, name: ?string) => {
        const field = this.context.getFieldDefinition(this.props.name);
        return field.parse(value, name);
    };

    /**
     * Format value. See https://redux-form.com/7.3.0/docs/api/field.md/#-code-format-value-name-gt-formattedvalue-code-optional-
     * @param value {*} value to format
     * @param name {String} only available when [Fields](https://redux-form.com/7.3.0/docs/api/fields.md/) is
     * used (see RangeField)
     * @returns {*}
     */
    format = (value: any, name: ?string) => {
        const field = this.context.getFieldDefinition(this.props.name);
        return field.format(value, name);
    };

    render() {
        const {
            name,
            custom = false,
            isUserDefinedField = custom,
            widget,
            widgetProps = {},
            ...rest
        } = this.props;
        let { required, reduxFormFieldComponent } = this.props;
        delete rest.reduxFormFieldComponent;
        const extraProps = {};
        let finalWidget = widget;
        if (!isUserDefinedField) {
            const field = this.context.getFieldDefinition(name);
            if (!reduxFormFieldComponent) {
                reduxFormFieldComponent = field.getReduxFormFieldComponent();
            }
            if (!finalWidget) {
                finalWidget = <ModelFormFieldWidget name={name} />;
            }
            extraProps.format = this.format;
            extraProps.parse = this.parse;
            if (required == null && field.required) {
                required = field.required;
            }
        }
        return (
            <FormField
                required={required}
                name={name}
                djradFieldName={name}
                widget={finalWidget}
                reduxFormFieldComponent={reduxFormFieldComponent}
                {...widgetProps}
                {...extraProps}
                {...rest}
            />
        );
    }
}
