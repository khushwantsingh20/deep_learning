// @flow
import { Table } from 'antd';
import cx from 'classnames';
import oneLine from 'common-tags/lib/oneLine';
import stripIndent from 'common-tags/lib/stripIndent';
import invariant from 'invariant';
import PropTypes from 'prop-types';
import * as React from 'react';
import type { Model } from '../../model/Model';
import { isValidModel } from '../../model/Model';
import type { ModelId } from '../../model/types';

import { modelClass, modelInstance } from '../../prop-types/model';
import injectSite from '../../site/injectSite';
import Site from '../../site/Site';
import FieldFormatter from './FieldFormatter';

import './ListTableView.less';

type Column = {
    nested?: boolean,
    dataIndex: string,
    key?: string,
    title?: React.Node,
    // This is array of column... breaks docgen though
    // https://github.com/reactjs/react-docgen/issues/215
    // children?: Array<Column>,
    children?: Array<
        | string
        | {
              dataIndex: string,
              key?: string,
              title?: React.Node,
              children?: Array<any>,
          }
    >,
};

type Props = {
    className?: string,
    /** Array of records to display */
    data: Array<Model>,
    /** The model class data is for. */
    model: ModelId | Class<Model>,
    /** Either a string field name or an object. See https://ant.design/components/table/#Column for props. */
    columns: Array<string | Column>,
    /** If true nested tables within this table will have special styles applied */
    nested?: boolean,
    sortableFields?: Array<string>,
    /**
     * If set then sorting will be controlled by this value. If this isn't specified then
     * the sorting is controlled internally by the antd table.
     *
     * Descending sort is indicated by leading '-'.
     *
     * eg. `-name` means sort descending by `name`; specifying just `name` implies
     * ascending ordering.
     *
     * Internally setting this value results in all columns that don't match having
     * the `sortOrder` prop set to false and the one matching set to `ascend` or
     * `descend`.
     *
     * Also accepts an array of sorted fields. At this stage ant table doesn't
     * support this directly and only the first option is used.
     */
    sortedField?: string | Array<string>,
};

type CombinedProps = Props & {
    /** @ignore */
    djradSite: Site,
};

/**
 * See https://ant.design/components/table/#Table for all other props that can be passed.
 */
export function ListTableView(props: CombinedProps) {
    const {
        djradSite,
        className,
        nested,
        sortableFields = [],
        data,
        columns,
        sortedField,
        ...rest
    } = props;
    delete rest.model;
    let model = props.model;
    if (typeof model == 'string') {
        model = djradSite.models.get(model);
    }
    if (!model || !isValidModel(model)) {
        // $FlowFixMe
        throw new Error(`Model passed to ListTableView must be a valid model. Got: ${model}`);
    }
    const dataIndices = new Set();
    const duplicateIndices = new Set();
    const addIndex = column => {
        const index = column.key || column.dataIndex;
        if (dataIndices.has(index)) {
            duplicateIndices.add(index);
        }
        dataIndices.add(index);
    };
    const sortControlled = sortedField !== undefined;
    const sortedFieldDetails = (Array.isArray(sortedField) ? sortedField : [sortedField]).reduce(
        (acc, sf) => {
            const isSortDescending = sf && sf[0] === '-';
            const sortedFieldName = isSortDescending ? sf.slice(1) : sf;
            acc[sortedFieldName] = isSortDescending ? 'descend' : 'ascend';
            return acc;
        },
        {}
    );

    const transformColumn = column => {
        if (typeof column == 'object') {
            invariant(
                column.dataIndex || column.children,
                stripIndent`
                When passing column object to ListTableView you must specify a unique dataIndex value, eg. 
                {
                    // this should be unique across all columns
                    dataIndex: 'actions',
                    // if dataIndex matches a field on record value will
                    // be that fields value, otherwise undefined.
                    render(value, record) {
                        return <strong>{value}</strong>
                    },
                }
                `
            );
            if (column.children) {
                return {
                    ...column,
                    children: column.children.map(transformColumn),
                };
            }
            addIndex(column);
            const finalColumn = { ...column };
            const field = model._meta.fields[column.dataIndex];
            if (!column.render) {
                if (!field) {
                    // $FlowFixMe: ^
                    throw new Error(
                        stripIndent`When passing column object to ListTableView you must specify a render function if data index is not a valid field.
                        Column with dataIndex ${
                            column.dataIndex
                        } does not have a render function and is not a valid field for ${
                            model._meta.modelId
                        } 
                        `
                    );
                }
                finalColumn.render = (value, record) => (
                    <FieldFormatter record={record} value={value} field={field} />
                );
            }
            if (field && !('title' in column)) {
                finalColumn.title = field.label;
            }
            if (field && !('sorter' in column) && sortableFields.includes(field.name)) {
                finalColumn.sorter = true;
            }
            if (sortControlled) {
                finalColumn.sortOrder =
                    finalColumn.sorter && (sortedFieldDetails[finalColumn.dataIndex] || '');
            }
            return finalColumn;
        }
        const fieldName = column;
        // This fixes the flow error below but is dumb as we already have done that above
        // if (!model || typeof model == 'string') return;
        // $FlowFixMe: ^
        const field = model._meta.fields[fieldName];
        if (!field) {
            // $FlowFixMe: ^
            throw new Error(
                `Invalid field '${fieldName} supplied for model ${
                    model._meta.modelId
                }. Known fields: ${Object.keys(model._meta.fields).join(', ')}`
            );
        }
        column = {
            title: field.label,
            dataIndex: fieldName,
            sorter: sortableFields.indexOf(fieldName) !== -1,
            render(value, record) {
                return <FieldFormatter record={record} value={value} field={field} />;
            },
        };
        if (sortControlled) {
            column.sortOrder = column.sorter && (sortedFieldDetails[field.name] || '');
        }
        addIndex(column);
        return column;
    };

    const finalColumns = columns.map(transformColumn);

    if (duplicateIndices.size > 0) {
        throw new Error(oneLine`
            Duplicate dataIndex or key used for columns: ${[...duplicateIndices].join(', ')}.
            You must pass a unique dataIndex or key for each column.
        `);
    }
    return (
        <Table
            className={cx({ 'djrad-table-nested': nested }, className)}
            columns={finalColumns}
            dataSource={data}
            rowKey={record => record.getId()}
            {...rest}
        />
    );
}

// $FlowFixMe
const ColumnShapeObject = {
    nested: PropTypes.bool,
    dataIndex: PropTypes.string,
    key: PropTypes.string,
    title: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    // Object here is actually same values as ColumnShape
    children: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.object])),
};
// This caused issues with flow so removing for now
// ColumnShapeObject.children = PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape(ColumnShapeObject)]));
const ColumnShape = PropTypes.shape(ColumnShapeObject);

ListTableView.propTypes = {
    className: PropTypes.string,
    /** Array of records to display */
    data: PropTypes.arrayOf(modelInstance()).isRequired,
    /** The model class data is for. */
    model: modelClass(),
    /** Either a string field name or an object. See https://ant.design/components/table/#Column for props. */
    columns: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, ColumnShape])).isRequired,
    /** If true nested tables within this table will have special styles applied */
    nested: PropTypes.bool,
    sortableFields: PropTypes.arrayOf(PropTypes.string),
};

const EnhancedListTableView: React.ComponentType<Props> = injectSite(ListTableView);

export default EnhancedListTableView;
