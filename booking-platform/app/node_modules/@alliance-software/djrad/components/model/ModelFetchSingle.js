// @flow
import * as React from 'react';

import PageNotFound from '../../components/pages/PageNotFound';
import PageLoading from '../../components/pages/PageLoading';
import PagePermissionDenied from '../../components/pages/PagePermissionDenied';
import PageServerError from '../../components/pages/PageServerError';
import { ApiError } from '../../api';
import injectSite from '../../site/injectSite';
import connectModel from './connectModel';
import type { ConnectModelProps } from './connectModel';
import type { InjectSiteProps } from '../../site/injectSite';
import type { Model } from '../../model/Model';
import type { ModelId } from '../../model/types';

type FetchErrorType = 'notFound' | 'permissionDenied' | 'unknown';

type ErrorComponentProps = {
    type: FetchErrorType,
};

type Props = {
    id: string | number,
    model: Class<Model> | ModelId,
    /** This component will be rendered while the record is being fetched */
    loadingComponent?: React.ComponentType<*>,
    /** This component will be rendered if there is an error fetching the record */
    errorComponent?: React.ComponentType<ErrorComponentProps>,
    children: ({ record: Model }) => React.Node,
};

type CombinedProps = Props & InjectSiteProps & ConnectModelProps;

type State = {
    isFetching: boolean,
    fetchError: ?FetchErrorType,
};

/**
 * Fetch a single record
 *
 * > In most cases [useGetModel](/api/js/hooks/#useGetModel) is more flexible
 * > and should be used in preference to this component.
 */
class ModelFetchSingle extends React.Component<CombinedProps, State> {
    hasMounted: boolean = false;

    // For use in test cases
    fetchPromise = null;

    state = {
        recordId: null,
        isFetching: false,
        fetchError: null,
    };

    componentDidMount() {
        this.fetchRecord();
        this.hasMounted = true;
    }

    componentWillUnmount() {
        this.hasMounted = false;
    }

    componentDidUpdate(prevProps: CombinedProps) {
        if (
            prevProps.model !== this.props.model ||
            prevProps.djradSite !== this.props.djradSite ||
            prevProps.id !== this.props.id
        ) {
            this.fetchRecord();
        }
    }

    getModel = () => {
        let { model } = this.props;
        if (typeof model == 'string') {
            model = this.props.djradSite.models.get(model);
            if (!model) {
                throw new Error('Invalid model specified');
            }
        }
        return model;
    };

    fetchRecord() {
        this.setState({ isFetching: true });
        const { djradSite, id } = this.props;
        const model = this.getModel();
        const recordId: string | number = id;
        if (!recordId) {
            this.setState({ isFetching: false, fetchError: 'notFound' });
            return;
        }
        this.fetchPromise = djradSite.api.getModel(model, recordId).then(
            () => {
                if (this.hasMounted) {
                    this.setState({ isFetching: false });
                }
            },
            (error: ApiError | Error) => {
                let fetchError = 'unknown';
                if (error && typeof error == 'object') {
                    if (error.status === 404) {
                        fetchError = 'notFound';
                    }
                    if (error.status === 403) {
                        fetchError = 'permissionDenied';
                    }
                }
                console.error('Unexpected failure', error); // eslint-disable-line
                if (this.hasMounted) {
                    this.setState({ isFetching: false, fetchError });
                }
            }
        );
    }

    renderError(fetchError: FetchErrorType) {
        if (fetchError === 'notFound') {
            return <PageNotFound />;
        }
        if (fetchError === 'permissionDenied') {
            return <PagePermissionDenied />;
        }
        return <PageServerError />;
    }

    render() {
        const { fetchError, isFetching } = this.state;
        const { children, id, records } = this.props;
        const { loadingComponent: LoadingComponent, errorComponent: ErrorComponent } = this.props;

        const record = records.get(id);
        const model = this.getModel();

        if (isFetching) {
            return LoadingComponent ? (
                <LoadingComponent />
            ) : (
                <PageLoading message={`Loading ${model._meta.labelPlural}`} />
            );
        }
        if (fetchError) {
            return ErrorComponent ? (
                <ErrorComponent type={fetchError} />
            ) : (
                this.renderError(fetchError)
            );
        }
        if (!record) {
            return ErrorComponent ? <ErrorComponent type="notFound" /> : <PagePermissionDenied />;
        }
        return children({ record });
    }
}

// Exporting injectSite() directly doesn't seem to work when you go to use it - complains
// about not passing in the injected props. Adding explicit annotation here fixes it.
const EnhancedModelFetchSingle: React.ComponentType<Props> = connectModel(props => props.model)(
    injectSite(ModelFetchSingle)
);

export default EnhancedModelFetchSingle;
