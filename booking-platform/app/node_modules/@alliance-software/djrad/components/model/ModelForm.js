// @flow
import isPlainObject from 'lodash/isPlainObject';
import isEqual from 'lodash/isEqual';
import * as React from 'react';
import Field from '../../model/fields/Field';
import type { Model } from '../../model/Model';
import { isValidModel } from '../../model/Model';
import type { ModelId } from '../../model/types';
import { DjradContext } from '../../site/components/context';
import Form from '../form/Form';
import FormButton from '../form/FormButton';
import ModelFormButtonBar from './ModelFormButtonBar';
import ModelFormContext from './modelFormContext';
import ModelFormField from './ModelFormField';
import ModelFormFieldWidget from './ModelFormFieldWidget';
import ModelFormItem from './ModelFormItem';

type Props = {
    /**
     * Specify this to control how the form is rendered. Only what you specify here will be rendered plus the default
     * footer. To disable or override the footer pass the `footer` prop.
     */
    children?: ?React.Node,
    /**
     * Explicitly specify the field definitions rather than extracting them from `model`. You rarely need this;
     * it's used by `ModelFilterForm` to specify filter field definitions instead of the underlying model form fields.
     */
    fieldDefinitions?: { [fieldName: string]: Field },
    /**
     * When `children` is not specified you can limit what fields are automatically rendered by specifying each field name here.
     */
    fieldNames: ?Array<string>,
    /**
     * If provided, when the definition for a field cannot be found, this function will be called with the unknown
     * field name. This should throw an appropriate error message if supplied, as form creation cannot continue.
     */
    onUnknownField?: (fieldName: string) => void,
    /**
     * Name of the form. Required if `model` isn't specified. Defaults to the model ID if not provided and `model` is available.
     */
    formName?: string,
    /**
     * Initial values for the form. Can either be an object mapping field name to value or a Promise that resolves
     * to the same thing. If not specified initialValues will either be populated from
     * - If `record` is provided `initialValues` will be populated from the record.
     * - Otherwise `initialValues` will be populated from the model default values.
     */
    initialValues?: { [fieldName: string]: any } | Promise<{ [fieldName: string]: any }>,
    /**
     * The model the form is for. Required unless you specify `fieldDefinitions`.
     */
    model?: ModelId | Class<Model>,
    /**
     * If existing record pass record here. If this is passed and initialValues is not passed initialValues will be populated with
     * record field values. Also used to generate available buttons in the default footer (eg. will show a
     * delete button only if it's an existing record).
     */
    record?: Model,
};

type State = {
    isLoadingInitialValues: boolean,
    initialValues: ?{ [fieldName: string]: any },
};

/**
 * Render a form for model. Chooses default widgets based on the underlying model field types.
 *
 * @acceptsProps Form
 */
export default class ModelForm extends React.Component<Props, State> {
    static contextType = DjradContext;

    state = {
        isLoadingInitialValues: false,
        initialValues: null,
    };

    _isMounted = true;

    constructor(props: Props, context) {
        super(props, context);
        this.checkProps(props);
        this.state = this.resolveDefaultValues();
    }

    componentDidMount() {
        this._isMounted = true;
    }

    componentWillUnmount() {
        this._isMounted = false;
    }

    /**
     * Resolve default values and return next state to set. We do this so we can set the state
     * initially in constructor so can be available before component is mounted
     */
    resolveDefaultValues(): Object {
        let initialValues;
        const props = this.props;
        if (props.initialValues !== undefined) {
            initialValues = props.initialValues;
        } else {
            const model = this.getModel(props);
            if (props.record) {
                initialValues = props.record.toJS();
            } else if (model) {
                initialValues = model._meta.getDefaultValues();
            }
        }
        if (initialValues) {
            // If plain object we don't need to be async - just set state directly
            if (isPlainObject(initialValues)) {
                return { isLoadingInitialValues: false, initialValues };
            }
            // Treat everything else as a promise (it's a pain to check if something is a promise
            // as it depends if the promise implementation is native or has been polyfilled etc - could
            // check for present of .then but as we only support plain object or promise we make an
            // assumption here)
            Promise.resolve(initialValues)
                .then(values => {
                    if (this._isMounted) {
                        this.setState({ initialValues: values, isLoadingInitialValues: false });
                    }
                })
                .catch(err => {
                    console.error('Failed to initialise default values', err); // eslint-disable-line
                    this.setState({ isLoadingInitialValues: false, initialValues: null });
                });
            return { isLoadingInitialValues: true };
        }
        return {};
    }

    getFieldDefinition = (fieldName: string) => {
        const model = this.getModel();
        let { fieldDefinitions } = this.props;
        if (model) {
            fieldDefinitions = model._meta.fields;
        } else if (!fieldDefinitions) {
            throw new Error('model or fieldDefinitions prop must be passed');
        }
        // For nested forms dotted notation will be used, eg.
        // addresses[0].name
        // We need just the field name portion.
        const finalFieldName = fieldName.split('.').pop();
        const field = fieldDefinitions[finalFieldName];
        if (!field) {
            if (this.props.onUnknownField) {
                this.props.onUnknownField(finalFieldName);
                throw new Error('onUnknownField should throw an error.');
            }

            if (model) {
                const { fieldNames } = model._meta;
                throw new Error(
                    `Unknown field '${finalFieldName}' on model ${
                        model._meta.modelId
                    }. Known fields: ${fieldNames.join(
                        ', '
                    )}. Check your serializer includes the field '${finalFieldName}'.`
                );
            }
            const fieldNames = Object.keys(fieldDefinitions);
            throw new Error(
                `Unknown field '${finalFieldName}'. Known fields: ${fieldNames.join(
                    ','
                )}. Check you are passing the expected field in the 'fieldDefinitions' prop. If this comes from a nested serializer check the serializer class includes the field '${finalFieldName}'.`
            );
        }
        return field;
    };

    getModel(props: ?Props): ?Class<Model> {
        const { djradSite } = this.context;
        props = props || this.props;
        let { model } = props;
        const { record } = props;
        if (!model && record) {
            model = record.constructor;
        }
        if (!model) {
            return null;
        }
        if (typeof model == 'string') {
            const modelId = model;
            model = djradSite.models.get(modelId);
            if (!model) {
                throw new Error(
                    `No such model ${modelId} exists. Known models are: ${[
                        ...djradSite.models.keys(),
                    ].join(', ')}`
                );
            }
        }
        if (!model || !isValidModel(model)) {
            // $FlowFixMe
            throw new Error(`Model passed to ModelForm must be a valid model. Got: ${model}`);
        }
        return model;
    }

    componentDidUpdate(prevProps: Props) {
        this.checkProps(this.props);
        const model = this.getModel(this.props);
        const prevModel = this.getModel(prevProps);
        if (model !== prevModel) {
            // If model changes we have to resolve default values again
            this.setState(this.resolveDefaultValues());
        } else if (
            this.props.enableReinitialize &&
            // If it's a plain object we want to check if it differs from the value
            // we have in state _not_ the prevProps value. This handles the case where
            // enableReinitialize is set some time after initialValues prop changes.
            // For promise values we have no choice but to just compare them directly.
            ((isPlainObject(this.props.initialValues) &&
                !isEqual(this.state.initialValues, this.props.initialValues)) ||
                !isEqual(this.props.initialValues, prevProps.initialValues))
        ) {
            this.setState(this.resolveDefaultValues());
        }
    }

    checkProps(props: Props) {
        if (props.fieldNames && props.children) {
            // eslint-disable-next-line
            console.warn(
                "Either provide 'fieldNames' or 'children', not both. fieldNames have been ignored."
            );
        }
        const model = this.getModel(props);
        if (!model && !props.formName) {
            throw new Error('You must specify the formName prop if the model prop is not passed');
        }
        if (!model && !props.fieldDefinitions) {
            throw new Error(
                'You must specify the fieldDefinitions prop if the model prop is not passed'
            );
        }
    }

    _modelFormContext = { getFieldDefinition: this.getFieldDefinition };

    render() {
        if (this.state.isLoadingInitialValues) {
            return null;
        }
        const model = this.getModel();
        let children = this.props.children;
        if (this.props.fieldNames && !children) {
            children = this.props.fieldNames.map(fieldName => (
                <ModelFormItem key={fieldName} name={fieldName} />
            ));
        }
        const {
            initialValues: ignore,
            fieldNames,
            formName = model ? model._meta.modelId : null,
            record,
            ...rest
        } = this.props;
        const { initialValues } = this.state;
        return (
            <ModelFormContext.Provider value={this._modelFormContext}>
                <Form
                    name={formName}
                    footer={<ModelFormButtonBar model={model} record={record} />}
                    initialValues={initialValues}
                    {...rest}
                >
                    {children}
                </Form>
            </ModelFormContext.Provider>
        );
    }

    static Item = ModelFormItem;
    static Field = ModelFormField;
    static Widget = ModelFormFieldWidget;
    static Button = FormButton;
}
