import React from 'react';
import pick from 'lodash/pick';
import invariant from 'invariant';
import injectSite from '../../site/injectSite';
import ModelForm from '../model/ModelForm';
import { handleErrorResponse } from '../form/errors';

const defaultRenderForm = ({
    fieldNames,
    fieldDefinitions,
    formName,
    onSubmit,
    initialValues,
    ...rest
}) => (
    <ModelForm
        initialValues={initialValues}
        fieldNames={fieldNames}
        fieldDefinitions={fieldDefinitions}
        formName={formName}
        onSubmit={onSubmit}
        {...rest}
    />
);

class ReverseRelationFormProcessor extends React.Component {
    static defaultProps = {
        renderForm: defaultRenderForm,
    };

    state = {
        loadingDefaultValues: false,
        defaultValues: null,
    };

    async componentDidMount() {
        this.validateProps();
        if (!this.props.fromRecord) {
            this.setState({ isLoadingDefaultValues: true });
            const { toRecord, relationFieldName } = this.props;
            const field = toRecord._meta.fields[relationFieldName];
            const { relation } = field;
            const defaultValues = await relation.model._meta.getDefaultValues();
            this.setState({
                loadingDefaultValues: false,
                defaultValues,
            });
        }
    }

    componentDidUpdate() {
        this.validateProps();
    }

    validateProps = () => {
        const { toRecord, relationFieldName } = this.props;
        const field = toRecord._meta.fields[relationFieldName];
        invariant(
            field,
            `Expected a field ${relationFieldName} on model ${
                toRecord._meta.modelId
            } but none was found`
        );
        invariant(
            field.relation && field.relation.isReverse(),
            `Expected a field ${relationFieldName} on model ${
                toRecord._meta.modelId
            } to be a reverse relation`
        );
    };

    handleSubmit = data => {
        const { djradSite, toRecord, fromRecord, relationFieldName } = this.props;
        const method = fromRecord ? 'PATCH' : 'POST';
        const finalData = { ...data };
        if (fromRecord) {
            finalData.relationpk = fromRecord.id;
        }
        return djradSite.api
            .customDetailRoute(method, toRecord, toRecord.getId(), relationFieldName, finalData)
            .then(() => this.props.onSuccess(), handleErrorResponse);
    };

    render() {
        const { loadingDefaultValues, defaultValues } = this.state;
        const {
            toRecord,
            fromRecord,
            relationFieldName,
            fieldNames = [],
            renderForm,
            ...rest
        } = this.props;

        if (!fromRecord && loadingDefaultValues) {
            return null;
        }

        const field = toRecord._meta.fields[relationFieldName];
        const fieldDefinitions = field.relation.model._meta.fields;
        if (fieldNames.length === 0) {
            field.relation.model._meta.fieldNames.forEach(fieldName => {
                if (!fieldDefinitions[fieldName].readOnly) {
                    fieldNames.push(fieldName);
                }
            });
        }

        return renderForm({
            initialValues: fromRecord ? pick(fromRecord, fieldNames) : defaultValues,
            fieldDefinitions,
            formName: relationFieldName,
            fieldNames,
            onSubmit: this.handleSubmit,
            layout: 'horizontal',
            record: fromRecord,
            ...rest,
        });
    }
}

export default injectSite(ReverseRelationFormProcessor);
