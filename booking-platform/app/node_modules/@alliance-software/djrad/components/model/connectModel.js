// @flow
import * as React from 'react';
import { KeyedCollection, OrderedMap } from 'immutable';
import { connect } from 'react-redux';
import invariant from 'invariant';
import type { MapDispatchToProps } from 'react-redux';
import injectSite from '../../site/injectSite';
import Site from '../../site/Site';
import { isModelInstance, BaseModel } from '../../model/Model';
import type { Action } from '../../types/action';
import type { State } from '../../types/state';
import type { Model } from '../../model/Model';
import type { ModelId } from '../../model/types';

export type ConnectModelProps = {
    records: KeyedCollection<number | string, Model>,
};

/**
 * Connect's to redux for a particular model and selects records based on the provided selector (defaults to all). Use
 * this to get the data from redux for a particular model that is passed in props.
 *
 * @param getModelFromProps - A function that returns the model class, a record or the model ID from props
 * @param select - A function that returns data to inject into you component. Selected data will be available on the 'records' prop. Defaults to selectors.all().
 * @param passThroughModel - Prop name to pass through resolved model class through on. Defaults to 'model'
 * @param mapStateToProps - function to pass through to redux connect() first parameter. Use this instead of
 * connect'ing the component as well as using connectModel
 * @param mapDispatchToProps - function to pass through to redux connect() second parameter
 *
 * @example
 *
 * ```js
 * connectModel(
 *    props => props.model,
 *    (model, state) => model.selectors.myCustomSelector(state),
 *    'model',
 *    (state) => ({
 *        extraData: AnotherModel.selectors.all(state),
 *    }),
 *    {
 *        myAction1,
 *        myAction2,
 *    }
 * )(MyComponent)
 *
 * <MyComponent model="mysite.user" />
 *
 * // MyComponent will receive props that look like:
 * {
 *     model: User,            // the actual class for mysite.user
 *     records: OrderedMap,    // all the users matched by myCustomSelector
 *     extraData: OrderedMap,  // all the data from AnotherModel
 *     myAction1: Function,    // myAction1 bound to dispatch
 *     myAction2: Function,    // myAction2 bound to dispatch
 * }
 * ```
 *
 * @hoc
 */
export default function connectModel<Props: {}>(
    getModelFromProps: (props: Props) => Class<Model> | Model | ModelId,
    select: (
        model: Class<Model>,
        state: State,
        props: Props
    ) => KeyedCollection<number | string, Model> = (
        model: Class<Model>,
        state: State /* , props: Props*/
    ) => model.selectors.all(state),
    // Prop to pass through resolved model on. Set to false to exclude prop
    passThroughModel: ?string = 'model',
    mapStateToProps: ?(state: State, props: Props) => Object,
    mapDispatchToProps: ?MapDispatchToProps<Action>
): (
    WrappedComponent: React.ComponentType<ConnectModelProps & Props>
) => React.ComponentType<Props> {
    return (WrappedComponent: React.ComponentType<ConnectModelProps & Props>) => {
        function wrappedMapStateToProps(
            state: State,
            props: Props & { djradSite: Site }
        ): ConnectModelProps {
            let model = getModelFromProps(props);
            if (typeof model == 'string') {
                model = props.djradSite.models.get(model);
            }
            invariant(
                model && model._meta,
                'Expected a model id, model class or instance returned from first parameter to connectModel'
            );
            // The model instanceof BaseModel check is just to help Flow - the real check we care about is isModelInstance
            if (model instanceof BaseModel || isModelInstance(model)) {
                model = model.constructor;
            }
            const finalProps = {
                records: select(model, state, props) || OrderedMap(),
            };
            if (passThroughModel) {
                finalProps[passThroughModel] = model;
            }
            if (mapStateToProps) {
                return {
                    ...finalProps,
                    ...mapStateToProps(state, props),
                };
            }
            return finalProps;
        }
        return injectSite(
            connect(
                wrappedMapStateToProps,
                mapDispatchToProps
            )(WrappedComponent)
        );
    };
}
