// @flow
import * as React from 'react';
import { Iterable, OrderedMap } from 'immutable';
import { List } from 'antd';
import { connect } from 'react-redux';
import { DjradContext } from '../../site/components/context';
import { warn } from '../../util/log';
import type { State as ReduxState } from '../../types/state';
import type { Model } from '../../model/Model';
import ActionLink from '../model/ActionLink';
import TextPlaceholder from '../TextPlaceholder';

type Props = {
    /** Record to lookup relation on */
    record: Model,
    /** A single ID or array of ids to lookup */
    value: any,
    /** The name of the field to lookup. This should be the relation field. */
    fieldName: string,
    /** Optional name of action to link item to. Only used if action is valid for record. */
    linkAction?: 'view' | 'update',
};

type CombinedProps = Props & {
    relatedModel: Class<Model>,
    relatedRecords: OrderedMap<number | string, Model>, // eslint-disable-line
    relatedRecord?: Model,
    relatedRecordIds: Array<number | string>, // eslint-disable-line
    isMany: boolean,
};

type State = {
    isLoading: boolean,
};

function SingleRecordActionLink({ action, label, record, id, relatedModel }) {
    if (!action || (!record && !id)) {
        return label;
    }
    return (
        <ActionLink
            model={relatedModel}
            record={record}
            action={action}
            params={{ id }}
            // If permission is denied on linking to record we still want to render the label
            permissionDeniedComponent={() => label}
        >
            {label}
        </ActionLink>
    );
}

export class RelatedModelFormatter extends React.Component<CombinedProps, State> {
    state = {
        isLoading: false,
    };

    static contextType = DjradContext;

    static defaultProps = {
        loadingComponent: TextPlaceholder,
    };

    /**
     * Special case - if dealing with a single record there's a special convention of
     * appending __relatedLabel to the field name on the original record. This bypasses
     * doing an API call if it exists but is only relevant if we are formatting a single
     * record.
     */
    getSingleLabel() {
        const { fieldName, record, relatedRecord, isMany } = this.props;
        if (isMany) {
            return null;
        }
        const relatedFieldName = `${fieldName}__relatedLabel`;
        if (record.get(relatedFieldName)) {
            return record.get(relatedFieldName);
        }
        if (relatedRecord) {
            return relatedRecord.__str__;
        }
        return null;
    }

    async maybeFetchRelatedRecord() {
        const { relatedRecordIds, fieldName } = this.props;
        if (!this.getSingleLabel() && relatedRecordIds.length > 0) {
            this.setState({ isLoading: true });
            await this.context.djradSite.api.listRelatedModel(this.props.record, fieldName, {
                ids: relatedRecordIds,
            });
            this.setState({ isLoading: false });
        }
    }

    componentDidMount() {
        this.maybeFetchRelatedRecord();
    }

    componentDidUpdate(prevProps: CombinedProps) {
        if (
            prevProps.value !== this.props.value ||
            this.props.record !== prevProps.record ||
            this.props.fieldName !== prevProps.fieldName
        ) {
            this.maybeFetchRelatedRecord();
        }
    }

    render() {
        const {
            relatedModel,
            relatedRecord,
            relatedRecords,
            isMany,
            value,
            linkAction,
            loadingComponent,
        } = this.props;
        const { isLoading } = this.state;
        if (isLoading) {
            if (loadingComponent) {
                return React.createElement(loadingComponent);
            }
            return null;
        }
        if (value == null) {
            return null;
        }
        let action: ?string;
        const validActions = relatedModel._meta.getValidLinkActions({
            recordOnly: true,
            includeDelete: false,
        });
        if (linkAction) {
            if (validActions.includes(linkAction)) {
                action = linkAction;
            } else {
                warn(`
                    linkAction of '${linkAction}' specified for RelatedModelFormatter
                    but that action is not valid for model ${relatedModel._meta.modelId};
                    field will not be linked to anything. Valid actions are: ${validActions.join(
                        ', '
                    )}
                `);
            }
        } else if (validActions.length > 0) {
            if (validActions.includes('detail')) {
                action = 'detail';
            } else if (validActions.includes('update')) {
                action = 'update';
            }
        }
        if (isMany) {
            return (
                <List
                    dataSource={relatedRecords}
                    renderItem={item => (
                        <List.Item>
                            <SingleRecordActionLink
                                action={action}
                                record={item}
                                relatedModel={this.props.relatedModel}
                                label={item.__str__}
                            />
                        </List.Item>
                    )}
                />
            );
        }
        return (
            <SingleRecordActionLink
                action={action}
                record={relatedRecord}
                id={this.props.relatedRecordIds[0]}
                relatedModel={this.props.relatedModel}
                label={this.getSingleLabel(this.props) || value}
            />
        );
    }
}

function mapStateToProps(state: ReduxState, props: Props) {
    const { record, fieldName } = props;
    const field = record._meta.fields[fieldName];
    const { relation } = field;
    if (!relation) {
        throw new Error(`Field ${fieldName} is not a relation`);
    }
    const relatedModel = relation.model;
    let relatedRecordIds = props.value;
    if (Iterable.isIterable(relatedRecordIds)) {
        relatedRecordIds = relatedRecordIds.toArray();
    }
    if (relatedRecordIds == null) {
        relatedRecordIds = [];
    }
    if (!Array.isArray(relatedRecordIds)) {
        relatedRecordIds = [relatedRecordIds];
    }

    const allRelatedRecords = relatedModel.selectors.related(state) || OrderedMap();
    const relatedRecords = relatedRecordIds.map(id => allRelatedRecords.get(id)).filter(Boolean);
    const isMany = relation.isToMany();
    const relatedRecord = isMany ? null : allRelatedRecords.get(props.value);
    return {
        relatedModel,
        relatedRecordIds,
        isMany,
        relatedRecords,
        relatedRecord,
    };
}

// $FlowFixMe: Type issue with connect, can't work out what it wants
const EnhancedRelatedModelFormatter: React.ComponentType<Props> = connect(mapStateToProps)(
    RelatedModelFormatter
);

export default EnhancedRelatedModelFormatter;
