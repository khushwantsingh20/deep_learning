const path = require('path');
const fs = require('fs');
const stripAnsi = require('strip-ansi');
const mkdirp = require('mkdirp');

const defaultOptions = {
    // Directory to output files to
    outputDir: '.',
    // Filename of stats JSON file
    filename: 'webpack-stats.json',
    // By default let the frontend handle the error by server the bundle
    // (which will just contain the error)
    // If set to false the error will be written to the json file.
    stopOnError: false,
    // Indent to pass to JSON.stringify for files written out
    indent: 2,
    // Defaults to webpack config output.publicPath
    publicPath: null,
};

/**
 * Write out a json file for each entry point specifying what initial chunks are required.
 *
 * Usage:
 *   const options = { stopOnError: true };
 *   const config = {
 *       mode: 'development',
 *       entry: path.resolve(__dirname, './does-not-exist.js'),
 *       plugins: [new EntryPointBundleTracker(options)],
 *  };
 *  webpack(config);
 *
 * Example of valid json file strucures:
 *      When compiling:
 *      {
 *        "status": "compiling",
 *      }
 *
 *      Error (when stopOnError set):
 *      {
 *        "status": "error",
 *        "resource": "/path/to/file.js",
 *        "error": "ModuleBuildError",
 *        "message": "Module build failed <snip>"
 *      }
 *
 *      Compiled:
 *      {
 *        "status": "done",
 *        "entrypoints": {
 *          "admin": [
 *            {
 *              "name": "runtime.bundle.js",
 *              "contentHash": "e2b781da02d36dad3aff"
 *            },
 *            {
 *              "name": "vendor.bundle.js",
 *              "contentHash": "774c52f57ce30a5e1382"
 *            },
 *            {
 *              "name": "common.bundle.js",
 *              "contentHash": "639269b921c8cf869c5f"
 *            },
 *            {
 *              "name": "common.bundle.css",
 *              "contentHash": "d60a0fa36613ea58a23d"
 *            }
 *            {
 *              "name": "admin.bundle.js",
 *              "contentHash": "c78fb252d4e00207afef"
 *            },
 *          ],
 *          "app": [
 *            {
 *              "name": "runtime.bundle.js",
 *              "contentHash": "e2b781da02d36dad3aff"
 *            },
 *            {
 *              "name": "vendor.bundle.js",
 *              "contentHash": "774c52f57ce30a5e1382"
 *            },
 *            {
 *              "name": "common.bundle.js",
 *              "contentHash": "639269b921c8cf869c5f"
 *            },
 *            {
 *              "name": "common.bundle.css",
 *              "contentHash": "d60a0fa36613ea58a23d"
 *            },
 *            {
 *              "name": "app.bundle.js",
 *              "contentHash": "806fc65dbad8a4dbb1cc"
 *            },
 *          ]
 *        },
 *        "publicPath": "http://hostname/"
 *      }
 */
class EntryPointBundleTracker {
    constructor(options = {}) {
        this.options = { ...defaultOptions, ...options };
    }

    /**
     * Get the public path to the file. Will be available in the "publicPath" key in outputted JSON.
     *
     * @param {Object} compiler the webpack compiler
     * @returns String
     */
    getPublicPath(compiler) {
        return this.options.publicPath || compiler.options.output.publicPath;
    }

    /**
     * Write output to file as JSON
     *
     * @param {Object} contents contents to write, will be JSON encoded
     */
    writeOutput(contents) {
        const outputDir = this.options.outputDir;
        const outputFilename = path.join(outputDir, this.options.filename);
        mkdirp.sync(path.dirname(outputFilename));

        fs.writeFileSync(outputFilename, JSON.stringify(contents, null, this.options.indent));
    }

    /**
     * Hook called when compiler is finished
     *
     * @param {Object} stats Stats object from output
     * @param {String} publicPath Public path as returned by this.getPublicPath. Written to "publicPath" key in outputted JSON.
     */
    compilerDone(stats, publicPath) {
        if (
            (this.options.stopOnError || stats.compilation.entrypoints.size === 0) &&
            stats.compilation.errors.length > 0
        ) {
            const error = stats.compilation.errors[0];
            this.writeOutput({
                status: 'error',
                resource: error.module ? error.module.userRequest : 'Unknown',
                error: error.name || 'unknown-error',
                message: stripAnsi(error.message || 'Unknown Error'),
            });
            return;
        }

        const entrypoints = {};
        /**
         * We only care about entry points. For each entry point write out the necessary initial chunks
         * and associated contentHash for each chunk.
         */
        for (const [name, entryPoint] of stats.compilation.entrypoints.entries()) {
            const files = [];
            for (const chunk of entryPoint.chunks) {
                // This looks like:
                // {
                //    javascript: 'abc123',
                //    "/some/path/to/mini-css-extract-plugin/loader/": "def456"
                // }
                // Couldn't find any documentation specifically about it what to expect here
                // but the below seems reliable enough.
                const { contentHash } = chunk;
                let jsContentHash;
                let cssContentHash;
                // Only worry about it if a content hash has been generated
                // For some files there will be none - eg. .js.map files
                if (Object.keys(contentHash).length > 0) {
                    const { javascript, ...rest } = contentHash;
                    jsContentHash = javascript;
                    if (Object.keys(rest).length > 1) {
                        throw new Error(
                            "Expected at most 1 key other than 'javascript' in contentHash."
                        );
                    }
                    if (Object.keys(rest).length === 1) {
                        cssContentHash = rest[Object.keys(rest)[0]];
                    }
                }
                files.push(
                    ...chunk.files.map((chunkName) => ({
                        name: chunkName,
                        contentHash: chunkName.endsWith('.js')
                            ? jsContentHash
                            : chunkName.endsWith('.css')
                                ? cssContentHash
                                : '',
                    }))
                );
            }
            entrypoints[name] = files;
        }
        const output = {
            status: 'done',
            entrypoints,
            publicPath,
        };

        this.writeOutput(output);
    }

    apply(compiler) {
        compiler.hooks.done.tapAsync('BundleTracker.done', (stats, callback) => {
            this.compilerDone(stats, this.getPublicPath(compiler));
            callback();
        });

        compiler.hooks.compile.tap('BundleTracker.compile', () => {
            this.writeOutput({ status: 'compiling' });
        });
    }
}

module.exports = EntryPointBundleTracker;
