from enum import Enum

from django.contrib.auth import login
from django.contrib.auth import update_session_auth_hash
from django.core import signing
from django.http import HttpResponse
from django.utils import timezone
from djrad_rest.viewsets import DjradGenericViewSet
from rest_framework import serializers
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response

from scbp_core.djrad.app.base import ScbpAppModelRegistration
from scbp_core.djrad.app.base import ScbpAppViewSetPermissions
from scbp_core.djrad.common.user import BaseUserSerializer
from scbp_core.djrad.sites import app_site
from scbp_core.models import ClientUser
from scbp_core.models import User
from scbp_core.rules import can_manage_user
from scbp_core.services.campaign_monitor import create_or_update_subscription


class AppUserSerializer(BaseUserSerializer):
    user_type = serializers.SerializerMethodField()

    class Meta:
        model = ClientUser
        fields = (
            "first_name",
            "last_name",
            "email",
            "password",
            "confirm_password",
            "user_type",
            "title",
            "contact_phone",
            "contact_phone_alternate",
            "driver_instructions",
            "internal_instructions",
        )
        extra_kwargs = {
            "driver_instructions": {"label": "Default Driver Instructions"},
            "internal_instructions": {"label": "Default Office Notes"},
        }

    def get_user_type(self, user):
        user_type = user.get_profile().user_type
        if isinstance(user_type, Enum):
            return user_type.name
        return user_type


class AppUserViewSetPermissions(ScbpAppViewSetPermissions):
    actions_to_perms_map = {
        "signup": [],
        "activate": [],
        "request_password_reset": [],
        "validate_password_reset": [],
        "reset_password": [],
        "update_self": ["%(app_label)s.update_self_%(model_name)s"],
        "change_own_password": ["%(app_label)s.update_self_%(model_name)s"],
        # We enforce checks manually in this endpoint
        "booking_notes": [],
    }


class AppUserViewSet(DjradGenericViewSet):
    serializer_class = AppUserSerializer
    queryset = ClientUser.objects.none()
    permission_classes = (AppUserViewSetPermissions,)

    def get_queryset(self):
        if not self.request.user or not self.request.user.is_authenticated:
            return self.queryset
        return ClientUser.objects.filter(id=self.request.user.id)

    # For a few actions listed here we'll want to maintain the usage of base User class instead of ClientUser
    # as otherwise a ClientUser's email might conflict with a User's, etc.
    @action(methods=["POST"], detail=False)
    def activate(self, request):
        """
        Attempt to activate a user given a token in the request. Typically this will happen
        in response to a user following an activation link that was emailed to them.
        :param request: request containing an activation token { 'token': '...' } that was
        generated by User.generate_activation_token.
        """
        token = request.data["token"]
        try:
            user = User.get_user_from_activation_token(token)
            if user.is_active and user.activated_at:
                return Response(
                    {"error": "account active"}, status=status.HTTP_400_BAD_REQUEST
                )
            user.activate()
            return Response(status=status.HTTP_200_OK)
        except signing.SignatureExpired:
            return Response(
                {"error": "signature expired"}, status=status.HTTP_400_BAD_REQUEST
            )
        except signing.BadSignature:
            return Response({"error": "bad token"}, status=status.HTTP_400_BAD_REQUEST)

    @action(methods=["POST"], detail=False)
    def signup(self, request):
        """
        Handle new user sign-up/registration. If a user attempts to sign-up with an existing email
        address (e.g. a user record exists matching the supplied email address), we allow the sign-up
        if that user record was not previously activated (we overwrite the existing user details),
        else we return an error.
        """
        # bobbytrap: if this field is filled, its a bot. just return 200.
        if "contact_phone_workplace" in request.data:
            return HttpResponse()

        if "middle_name" not in request.data:
            return Response(
                {
                    "middle_name": "Please perform the calculation on these two numbers to show you are human"
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        # See FrontendView.get_app_context for where this is initialised
        if request.data["middle_name"] != str(
            request.session.get("makeshift captcha", -1)
        ):
            return Response(
                {
                    "middle_name": "The answer is not correct. Delete your answer to see question again."
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Allow duplicate email addresses, we validate this below
        user_serializer = AppUserSerializer(
            data=request.data, allow_duplicate_email=True
        )
        if not user_serializer.is_valid():
            return Response(user_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        existing_user = User.objects.filter(
            email__iexact=user_serializer.validated_data["email"]
        ).first()
        if existing_user:
            if existing_user.is_active or existing_user.was_activated():
                # User exists, and has been activated
                return Response(
                    {"email": "An account with this email address already exists"},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            # User has previously signed up, but not been activated, so we overwrite the existing user
            # details with the new data
            existing_user.date_joined = timezone.localtime()
            user_serializer.instance = existing_user

        is_new_user = user_serializer.instance is None
        user = user_serializer.save()
        user.activate()
        user.send_welcome_email()
        create_or_update_subscription.delay(user.pk)

        login(request, user, backend="django_site.backends.ProfileModelBackend")

        response_status = status.HTTP_201_CREATED if is_new_user else status.HTTP_200_OK
        serializer = self.get_serializer(user)
        response = {
            "user": serializer.data,
            **app_site.get_extra_login_response_data(request),
            "djradContext": app_site.get_runtime_context(request),
        }
        request.session["makeshift captcha"] = ""  # no replay
        return Response(response, status=response_status)

    @action(methods=["POST"], detail=False)
    def request_password_reset(self, request):
        """
        Handle the initial step of requesting a password reset. We'll send a password reset email if the
        email account corresponds to one of our users, and a non-existent account email otherwise.
        """
        email = request.data["email"].strip()
        try:
            user = User.objects.get(email__iexact=email)
            user.send_password_reset_email(request)
        except User.DoesNotExist:
            return Response(
                {"email": "Email does not correspond to any user"},
                status=status.HTTP_400_BAD_REQUEST,
            )
        return Response({"email": email}, status=status.HTTP_200_OK)

    @action(methods=["POST"], detail=False)
    def validate_password_reset(self, request):
        """
        Validate that the request is a valid password reset request
        """
        token = request.data["token"]
        try:
            User.get_user_from_password_reset_token(token)
            return Response(status=status.HTTP_200_OK)
        except signing.SignatureExpired:
            return Response(
                {"error": "signature expired"}, status=status.HTTP_400_BAD_REQUEST
            )
        except signing.BadSignature:
            return Response(
                {"error": "invalid token"}, status=status.HTTP_400_BAD_REQUEST
            )

    @action(methods=["POST"], detail=False)
    def reset_password(self, request):
        """
        Actually change the password
        """
        token = request.data["token"]
        try:
            user = User.get_user_from_password_reset_token(token).get_profile()
            serializer = AppUserSerializer(
                instance=user,
                data={
                    "password": request.data["password"],
                    "confirm_password": request.data["confirm_password"],
                },
                partial=True,
                context={"request": request},
            )
            serializer.is_valid(raise_exception=True)
            serializer.save()
            login(request, user, backend="django_site.backends.ProfileModelBackend")
            response = {
                "user": serializer.data,
                **app_site.get_extra_login_response_data(request),
                "djradContext": app_site.get_runtime_context(request),
            }
            return Response(response)
        except signing.SignatureExpired:
            return Response(
                {"error": "signature expired"}, status=status.HTTP_400_BAD_REQUEST
            )
        except signing.BadSignature:
            return Response(
                {"error": "invalid token"}, status=status.HTTP_400_BAD_REQUEST
            )

    @action(methods=["POST"], detail=True, url_path="update-self")
    def update_self(self, request, pk):
        user = self.get_object()
        serializer = self.get_serializer(user, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    @action(methods=["POST"], detail=True, url_path="change-own-password")
    def change_own_password(self, request, pk):
        user = self.get_object()
        current_password = request.data.pop("current_password", "")
        if not user.check_password(current_password):
            raise ValidationError(
                {"current_password": "Please check your password and try again"}
            )
        serializer = self.get_serializer(
            user,
            require_password=True,
            data={
                "password": request.data.get("password", ""),
                "confirm_password": request.data.get("confirm_password", ""),
            },
            partial=True,
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        update_session_auth_hash(request, user)
        return Response(serializer.data)

    @action(methods=["GET"], detail=False, url_path="booking-notes")
    def booking_notes(self, request):
        try:
            user = ClientUser.objects.get(id=request.query_params.get("clientUserId"))
        except ClientUser.DoesNotExist:
            return Response(status=status.HTTP_403_FORBIDDEN)
        if not can_manage_user(request.user, user):
            return Response(status=status.HTTP_403_FORBIDDEN)
        context = {
            **self.get_serializer_context(),
            "partial_fields": ["driver_instructions", "internal_instructions"],
        }
        serializer = AppUserSerializer(user, context=context)
        return Response(serializer.data)


class AppUserRegistration(ScbpAppModelRegistration):
    viewset_class = AppUserViewSet


app_site.register(ClientUser, AppUserRegistration)
# Set the class to use for serializing user data
app_site.set_user_serializer_class(AppUserSerializer)
